/*
** Copyright (c) 2018-2023 Valve Corporation
** Copyright (c) 2018-2023 LunarG, Inc.
** Copyright (c) 2023 Advanced Micro Devices, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "generated_vulkan_struct_to_dive.h"
#include "generated_vulkan_enum_to_dive.h"
#include "util/to_string.h"

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)
using util::to_hex_variable_width;
using util::uuid_to_string;


void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264SpsVuiFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SpsVuiFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SpsVuiFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.aspect_ratio_info_present_flag);
        FieldToDive(data_map, decoded_value.overscan_info_present_flag);
        FieldToDive(data_map, decoded_value.overscan_appropriate_flag);
        FieldToDive(data_map, decoded_value.video_signal_type_present_flag);
        FieldToDive(data_map, decoded_value.video_full_range_flag);
        FieldToDive(data_map, decoded_value.color_description_present_flag);
        FieldToDive(data_map, decoded_value.chroma_loc_info_present_flag);
        FieldToDive(data_map, decoded_value.timing_info_present_flag);
        FieldToDive(data_map, decoded_value.fixed_frame_rate_flag);
        FieldToDive(data_map, decoded_value.bitstream_restriction_flag);
        FieldToDive(data_map, decoded_value.nal_hrd_parameters_present_flag);
        FieldToDive(data_map, decoded_value.vcl_hrd_parameters_present_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264HrdParameters* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264HrdParameters& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264HrdParameters& meta_struct = *data;

        FieldToDive(data_map, decoded_value.cpb_cnt_minus1);
        FieldToDive(data_map, decoded_value.bit_rate_scale);
        FieldToDive(data_map, decoded_value.cpb_size_scale);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, &meta_struct.bit_rate_value_minus1);
        FieldToDive(data_map, &meta_struct.cpb_size_value_minus1);
        FieldToDive(data_map, &meta_struct.cbr_flag);
        FieldToDive(data_map, decoded_value.initial_cpb_removal_delay_length_minus1);
        FieldToDive(data_map, decoded_value.cpb_removal_delay_length_minus1);
        FieldToDive(data_map, decoded_value.dpb_output_delay_length_minus1);
        FieldToDive(data_map, decoded_value.time_offset_length);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264SequenceParameterSetVui* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SequenceParameterSetVui& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SequenceParameterSetVui& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.aspect_ratio_idc);
        FieldToDive(data_map, decoded_value.sar_width);
        FieldToDive(data_map, decoded_value.sar_height);
        FieldToDive(data_map, decoded_value.video_format);
        FieldToDive(data_map, decoded_value.colour_primaries);
        FieldToDive(data_map, decoded_value.transfer_characteristics);
        FieldToDive(data_map, decoded_value.matrix_coefficients);
        FieldToDive(data_map, decoded_value.num_units_in_tick);
        FieldToDive(data_map, decoded_value.time_scale);
        FieldToDive(data_map, decoded_value.max_num_reorder_frames);
        FieldToDive(data_map, decoded_value.max_dec_frame_buffering);
        FieldToDive(data_map, decoded_value.chroma_sample_loc_type_top_field);
        FieldToDive(data_map, decoded_value.chroma_sample_loc_type_bottom_field);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, meta_struct.pHrdParameters);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264SpsFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SpsFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.constraint_set0_flag);
        FieldToDive(data_map, decoded_value.constraint_set1_flag);
        FieldToDive(data_map, decoded_value.constraint_set2_flag);
        FieldToDive(data_map, decoded_value.constraint_set3_flag);
        FieldToDive(data_map, decoded_value.constraint_set4_flag);
        FieldToDive(data_map, decoded_value.constraint_set5_flag);
        FieldToDive(data_map, decoded_value.direct_8x8_inference_flag);
        FieldToDive(data_map, decoded_value.mb_adaptive_frame_field_flag);
        FieldToDive(data_map, decoded_value.frame_mbs_only_flag);
        FieldToDive(data_map, decoded_value.delta_pic_order_always_zero_flag);
        FieldToDive(data_map, decoded_value.separate_colour_plane_flag);
        FieldToDive(data_map, decoded_value.gaps_in_frame_num_value_allowed_flag);
        FieldToDive(data_map, decoded_value.qpprime_y_zero_transform_bypass_flag);
        FieldToDive(data_map, decoded_value.frame_cropping_flag);
        FieldToDive(data_map, decoded_value.seq_scaling_matrix_present_flag);
        FieldToDive(data_map, decoded_value.vui_parameters_present_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264ScalingLists* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264ScalingLists& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264ScalingLists& meta_struct = *data;

        FieldToDive(data_map, decoded_value.scaling_list_present_mask);
        FieldToDive(data_map, decoded_value.use_default_scaling_matrix_mask);
        FieldToDive(data_map, &meta_struct.ScalingList4x4);
        FieldToDive(data_map, &meta_struct.ScalingList8x8);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264SequenceParameterSet* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SequenceParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SequenceParameterSet& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.profile_idc);
        FieldToDive(data_map, decoded_value.level_idc);
        FieldToDive(data_map, decoded_value.chroma_format_idc);
        FieldToDive(data_map, decoded_value.seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.bit_depth_luma_minus8);
        FieldToDive(data_map, decoded_value.bit_depth_chroma_minus8);
        FieldToDive(data_map, decoded_value.log2_max_frame_num_minus4);
        FieldToDive(data_map, decoded_value.pic_order_cnt_type);
        FieldToDive(data_map, decoded_value.offset_for_non_ref_pic);
        FieldToDive(data_map, decoded_value.offset_for_top_to_bottom_field);
        FieldToDive(data_map, decoded_value.log2_max_pic_order_cnt_lsb_minus4);
        FieldToDive(data_map, decoded_value.num_ref_frames_in_pic_order_cnt_cycle);
        FieldToDive(data_map, decoded_value.max_num_ref_frames);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.pic_width_in_mbs_minus1);
        FieldToDive(data_map, decoded_value.pic_height_in_map_units_minus1);
        FieldToDive(data_map, decoded_value.frame_crop_left_offset);
        FieldToDive(data_map, decoded_value.frame_crop_right_offset);
        FieldToDive(data_map, decoded_value.frame_crop_top_offset);
        FieldToDive(data_map, decoded_value.frame_crop_bottom_offset);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, meta_struct.pOffsetForRefFrame);
        FieldToDive(data_map, meta_struct.pScalingLists);
        FieldToDive(data_map, meta_struct.pSequenceParameterSetVui);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264PpsFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264PpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264PpsFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.transform_8x8_mode_flag);
        FieldToDive(data_map, decoded_value.redundant_pic_cnt_present_flag);
        FieldToDive(data_map, decoded_value.constrained_intra_pred_flag);
        FieldToDive(data_map, decoded_value.deblocking_filter_control_present_flag);
        FieldToDive(data_map, decoded_value.weighted_pred_flag);
        FieldToDive(data_map, decoded_value.bottom_field_pic_order_in_frame_present_flag);
        FieldToDive(data_map, decoded_value.entropy_coding_mode_flag);
        FieldToDive(data_map, decoded_value.pic_scaling_matrix_present_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH264PictureParameterSet* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264PictureParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264PictureParameterSet& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.pic_parameter_set_id);
        FieldToDive(data_map, decoded_value.num_ref_idx_l0_default_active_minus1);
        FieldToDive(data_map, decoded_value.num_ref_idx_l1_default_active_minus1);
        FieldToDive(data_map, decoded_value.weighted_bipred_idc);
        FieldToDive(data_map, decoded_value.pic_init_qp_minus26);
        FieldToDive(data_map, decoded_value.pic_init_qs_minus26);
        FieldToDive(data_map, decoded_value.chroma_qp_index_offset);
        FieldToDive(data_map, decoded_value.second_chroma_qp_index_offset);
        FieldToDive(data_map, meta_struct.pScalingLists);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH264PictureInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264PictureInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.field_pic_flag);
        FieldToDive(data_map, decoded_value.is_intra);
        FieldToDive(data_map, decoded_value.IdrPicFlag);
        FieldToDive(data_map, decoded_value.bottom_field_flag);
        FieldToDive(data_map, decoded_value.is_reference);
        FieldToDive(data_map, decoded_value.complementary_field_pair);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH264PictureInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264PictureInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.pic_parameter_set_id);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, decoded_value.frame_num);
        FieldToDive(data_map, decoded_value.idr_pic_id);
        FieldToDive(data_map, &meta_struct.PicOrderCnt);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH264ReferenceInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264ReferenceInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.top_field_flag);
        FieldToDive(data_map, decoded_value.bottom_field_flag);
        FieldToDive(data_map, decoded_value.used_for_long_term_reference);
        FieldToDive(data_map, decoded_value.is_non_existing);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH264ReferenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264ReferenceInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.FrameNum);
        FieldToDive(data_map, decoded_value.reserved);
        FieldToDive(data_map, &meta_struct.PicOrderCnt);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264WeightTableFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264WeightTableFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264WeightTableFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.luma_weight_l0_flag);
        FieldToDive(data_map, decoded_value.chroma_weight_l0_flag);
        FieldToDive(data_map, decoded_value.luma_weight_l1_flag);
        FieldToDive(data_map, decoded_value.chroma_weight_l1_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264WeightTable* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264WeightTable& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264WeightTable& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.luma_log2_weight_denom);
        FieldToDive(data_map, decoded_value.chroma_log2_weight_denom);
        FieldToDive(data_map, &meta_struct.luma_weight_l0);
        FieldToDive(data_map, &meta_struct.luma_offset_l0);
        FieldToDive(data_map, &meta_struct.chroma_weight_l0);
        FieldToDive(data_map, &meta_struct.chroma_offset_l0);
        FieldToDive(data_map, &meta_struct.luma_weight_l1);
        FieldToDive(data_map, &meta_struct.luma_offset_l1);
        FieldToDive(data_map, &meta_struct.chroma_weight_l1);
        FieldToDive(data_map, &meta_struct.chroma_offset_l1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264SliceHeaderFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264SliceHeaderFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264SliceHeaderFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.direct_spatial_mv_pred_flag);
        FieldToDive(data_map, decoded_value.num_ref_idx_active_override_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264PictureInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264PictureInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.IdrPicFlag);
        FieldToDive(data_map, decoded_value.is_reference);
        FieldToDive(data_map, decoded_value.no_output_of_prior_pics_flag);
        FieldToDive(data_map, decoded_value.long_term_reference_flag);
        FieldToDive(data_map, decoded_value.adaptive_ref_pic_marking_mode_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264ReferenceInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.used_for_long_term_reference);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264ReferenceListsInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceListsInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceListsInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.ref_pic_list_modification_flag_l0);
        FieldToDive(data_map, decoded_value.ref_pic_list_modification_flag_l1);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264RefListModEntry* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264RefListModEntry& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264RefListModEntry& meta_struct = *data;

        FieldToDive(data_map, decoded_value.modification_of_pic_nums_idc);
        FieldToDive(data_map, decoded_value.abs_diff_pic_num_minus1);
        FieldToDive(data_map, decoded_value.long_term_pic_num);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264RefPicMarkingEntry* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264RefPicMarkingEntry& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264RefPicMarkingEntry& meta_struct = *data;

        FieldToDive(data_map, decoded_value.memory_management_control_operation);
        FieldToDive(data_map, decoded_value.difference_of_pic_nums_minus1);
        FieldToDive(data_map, decoded_value.long_term_pic_num);
        FieldToDive(data_map, decoded_value.long_term_frame_idx);
        FieldToDive(data_map, decoded_value.max_long_term_frame_idx_plus1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264ReferenceListsInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceListsInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceListsInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.num_ref_idx_l0_active_minus1);
        FieldToDive(data_map, decoded_value.num_ref_idx_l1_active_minus1);
        FieldToDive(data_map, &meta_struct.RefPicList0);
        FieldToDive(data_map, &meta_struct.RefPicList1);
        FieldToDive(data_map, decoded_value.refList0ModOpCount);
        FieldToDive(data_map, decoded_value.refList1ModOpCount);
        FieldToDive(data_map, decoded_value.refPicMarkingOpCount);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, meta_struct.pRefList0ModOperations);
        FieldToDive(data_map, meta_struct.pRefList1ModOperations);
        FieldToDive(data_map, meta_struct.pRefPicMarkingOperations);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264PictureInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264PictureInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.pic_parameter_set_id);
        FieldToDive(data_map, decoded_value.idr_pic_id);
        FieldToDive(data_map, decoded_value.primary_pic_type);
        FieldToDive(data_map, decoded_value.frame_num);
        FieldToDive(data_map, decoded_value.PicOrderCnt);
        FieldToDive(data_map, decoded_value.temporal_id);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, meta_struct.pRefLists);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264ReferenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.primary_pic_type);
        FieldToDive(data_map, decoded_value.FrameNum);
        FieldToDive(data_map, decoded_value.PicOrderCnt);
        FieldToDive(data_map, decoded_value.long_term_pic_num);
        FieldToDive(data_map, decoded_value.long_term_frame_idx);
        FieldToDive(data_map, decoded_value.temporal_id);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH264SliceHeader* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264SliceHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264SliceHeader& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.first_mb_in_slice);
        FieldToDive(data_map, decoded_value.slice_type);
        FieldToDive(data_map, decoded_value.slice_alpha_c0_offset_div2);
        FieldToDive(data_map, decoded_value.slice_beta_offset_div2);
        FieldToDive(data_map, decoded_value.slice_qp_delta);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.cabac_init_idc);
        FieldToDive(data_map, decoded_value.disable_deblocking_filter_idc);
        FieldToDive(data_map, meta_struct.pWeightTable);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265ProfileTierLevelFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ProfileTierLevelFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ProfileTierLevelFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.general_tier_flag);
        FieldToDive(data_map, decoded_value.general_progressive_source_flag);
        FieldToDive(data_map, decoded_value.general_interlaced_source_flag);
        FieldToDive(data_map, decoded_value.general_non_packed_constraint_flag);
        FieldToDive(data_map, decoded_value.general_frame_only_constraint_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265ProfileTierLevel* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ProfileTierLevel& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ProfileTierLevel& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.general_profile_idc);
        FieldToDive(data_map, decoded_value.general_level_idc);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265DecPicBufMgr* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265DecPicBufMgr& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265DecPicBufMgr& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.max_latency_increase_plus1);
        FieldToDive(data_map, &meta_struct.max_dec_pic_buffering_minus1);
        FieldToDive(data_map, &meta_struct.max_num_reorder_pics);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265SubLayerHrdParameters* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SubLayerHrdParameters& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SubLayerHrdParameters& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.bit_rate_value_minus1);
        FieldToDive(data_map, &meta_struct.cpb_size_value_minus1);
        FieldToDive(data_map, &meta_struct.cpb_size_du_value_minus1);
        FieldToDive(data_map, &meta_struct.bit_rate_du_value_minus1);
        FieldToDive(data_map, decoded_value.cbr_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265HrdFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265HrdFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265HrdFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.nal_hrd_parameters_present_flag);
        FieldToDive(data_map, decoded_value.vcl_hrd_parameters_present_flag);
        FieldToDive(data_map, decoded_value.sub_pic_hrd_params_present_flag);
        FieldToDive(data_map, decoded_value.sub_pic_cpb_params_in_pic_timing_sei_flag);
        FieldToDive(data_map, decoded_value.fixed_pic_rate_general_flag);
        FieldToDive(data_map, decoded_value.fixed_pic_rate_within_cvs_flag);
        FieldToDive(data_map, decoded_value.low_delay_hrd_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265HrdParameters* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265HrdParameters& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265HrdParameters& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.tick_divisor_minus2);
        FieldToDive(data_map, decoded_value.du_cpb_removal_delay_increment_length_minus1);
        FieldToDive(data_map, decoded_value.dpb_output_delay_du_length_minus1);
        FieldToDive(data_map, decoded_value.bit_rate_scale);
        FieldToDive(data_map, decoded_value.cpb_size_scale);
        FieldToDive(data_map, decoded_value.cpb_size_du_scale);
        FieldToDive(data_map, decoded_value.initial_cpb_removal_delay_length_minus1);
        FieldToDive(data_map, decoded_value.au_cpb_removal_delay_length_minus1);
        FieldToDive(data_map, decoded_value.dpb_output_delay_length_minus1);
        FieldToDive(data_map, &meta_struct.cpb_cnt_minus1);
        FieldToDive(data_map, &meta_struct.elemental_duration_in_tc_minus1);
        FieldToDive(data_map, &meta_struct.reserved);
        FieldToDive(data_map, meta_struct.pSubLayerHrdParametersNal);
        FieldToDive(data_map, meta_struct.pSubLayerHrdParametersVcl);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265VpsFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265VpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265VpsFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.vps_temporal_id_nesting_flag);
        FieldToDive(data_map, decoded_value.vps_sub_layer_ordering_info_present_flag);
        FieldToDive(data_map, decoded_value.vps_timing_info_present_flag);
        FieldToDive(data_map, decoded_value.vps_poc_proportional_to_timing_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265VideoParameterSet* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265VideoParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265VideoParameterSet& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.vps_video_parameter_set_id);
        FieldToDive(data_map, decoded_value.vps_max_sub_layers_minus1);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, decoded_value.vps_num_units_in_tick);
        FieldToDive(data_map, decoded_value.vps_time_scale);
        FieldToDive(data_map, decoded_value.vps_num_ticks_poc_diff_one_minus1);
        FieldToDive(data_map, decoded_value.reserved3);
        FieldToDive(data_map, meta_struct.pDecPicBufMgr);
        FieldToDive(data_map, meta_struct.pHrdParameters);
        FieldToDive(data_map, meta_struct.pProfileTierLevel);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265ScalingLists* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ScalingLists& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ScalingLists& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.ScalingList4x4);
        FieldToDive(data_map, &meta_struct.ScalingList8x8);
        FieldToDive(data_map, &meta_struct.ScalingList16x16);
        FieldToDive(data_map, &meta_struct.ScalingList32x32);
        FieldToDive(data_map, &meta_struct.ScalingListDCCoef16x16);
        FieldToDive(data_map, &meta_struct.ScalingListDCCoef32x32);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265ShortTermRefPicSetFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ShortTermRefPicSetFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ShortTermRefPicSetFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.inter_ref_pic_set_prediction_flag);
        FieldToDive(data_map, decoded_value.delta_rps_sign);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265ShortTermRefPicSet* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ShortTermRefPicSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ShortTermRefPicSet& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.delta_idx_minus1);
        FieldToDive(data_map, decoded_value.use_delta_flag);
        FieldToDive(data_map, decoded_value.abs_delta_rps_minus1);
        FieldToDive(data_map, decoded_value.used_by_curr_pic_flag);
        FieldToDive(data_map, decoded_value.used_by_curr_pic_s0_flag);
        FieldToDive(data_map, decoded_value.used_by_curr_pic_s1_flag);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, decoded_value.reserved3);
        FieldToDive(data_map, decoded_value.num_negative_pics);
        FieldToDive(data_map, decoded_value.num_positive_pics);
        FieldToDive(data_map, &meta_struct.delta_poc_s0_minus1);
        FieldToDive(data_map, &meta_struct.delta_poc_s1_minus1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265LongTermRefPicsSps* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265LongTermRefPicsSps& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265LongTermRefPicsSps& meta_struct = *data;

        FieldToDive(data_map, decoded_value.used_by_curr_pic_lt_sps_flag);
        FieldToDive(data_map, &meta_struct.lt_ref_pic_poc_lsb_sps);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265SpsVuiFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SpsVuiFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SpsVuiFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.aspect_ratio_info_present_flag);
        FieldToDive(data_map, decoded_value.overscan_info_present_flag);
        FieldToDive(data_map, decoded_value.overscan_appropriate_flag);
        FieldToDive(data_map, decoded_value.video_signal_type_present_flag);
        FieldToDive(data_map, decoded_value.video_full_range_flag);
        FieldToDive(data_map, decoded_value.colour_description_present_flag);
        FieldToDive(data_map, decoded_value.chroma_loc_info_present_flag);
        FieldToDive(data_map, decoded_value.neutral_chroma_indication_flag);
        FieldToDive(data_map, decoded_value.field_seq_flag);
        FieldToDive(data_map, decoded_value.frame_field_info_present_flag);
        FieldToDive(data_map, decoded_value.default_display_window_flag);
        FieldToDive(data_map, decoded_value.vui_timing_info_present_flag);
        FieldToDive(data_map, decoded_value.vui_poc_proportional_to_timing_flag);
        FieldToDive(data_map, decoded_value.vui_hrd_parameters_present_flag);
        FieldToDive(data_map, decoded_value.bitstream_restriction_flag);
        FieldToDive(data_map, decoded_value.tiles_fixed_structure_flag);
        FieldToDive(data_map, decoded_value.motion_vectors_over_pic_boundaries_flag);
        FieldToDive(data_map, decoded_value.restricted_ref_pic_lists_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265SequenceParameterSetVui* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SequenceParameterSetVui& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SequenceParameterSetVui& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.aspect_ratio_idc);
        FieldToDive(data_map, decoded_value.sar_width);
        FieldToDive(data_map, decoded_value.sar_height);
        FieldToDive(data_map, decoded_value.video_format);
        FieldToDive(data_map, decoded_value.colour_primaries);
        FieldToDive(data_map, decoded_value.transfer_characteristics);
        FieldToDive(data_map, decoded_value.matrix_coeffs);
        FieldToDive(data_map, decoded_value.chroma_sample_loc_type_top_field);
        FieldToDive(data_map, decoded_value.chroma_sample_loc_type_bottom_field);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, decoded_value.def_disp_win_left_offset);
        FieldToDive(data_map, decoded_value.def_disp_win_right_offset);
        FieldToDive(data_map, decoded_value.def_disp_win_top_offset);
        FieldToDive(data_map, decoded_value.def_disp_win_bottom_offset);
        FieldToDive(data_map, decoded_value.vui_num_units_in_tick);
        FieldToDive(data_map, decoded_value.vui_time_scale);
        FieldToDive(data_map, decoded_value.vui_num_ticks_poc_diff_one_minus1);
        FieldToDive(data_map, decoded_value.min_spatial_segmentation_idc);
        FieldToDive(data_map, decoded_value.reserved3);
        FieldToDive(data_map, decoded_value.max_bytes_per_pic_denom);
        FieldToDive(data_map, decoded_value.max_bits_per_min_cu_denom);
        FieldToDive(data_map, decoded_value.log2_max_mv_length_horizontal);
        FieldToDive(data_map, decoded_value.log2_max_mv_length_vertical);
        FieldToDive(data_map, meta_struct.pHrdParameters);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265PredictorPaletteEntries* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265PredictorPaletteEntries& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265PredictorPaletteEntries& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.PredictorPaletteEntries);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265SpsFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SpsFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sps_temporal_id_nesting_flag);
        FieldToDive(data_map, decoded_value.separate_colour_plane_flag);
        FieldToDive(data_map, decoded_value.conformance_window_flag);
        FieldToDive(data_map, decoded_value.sps_sub_layer_ordering_info_present_flag);
        FieldToDive(data_map, decoded_value.scaling_list_enabled_flag);
        FieldToDive(data_map, decoded_value.sps_scaling_list_data_present_flag);
        FieldToDive(data_map, decoded_value.amp_enabled_flag);
        FieldToDive(data_map, decoded_value.sample_adaptive_offset_enabled_flag);
        FieldToDive(data_map, decoded_value.pcm_enabled_flag);
        FieldToDive(data_map, decoded_value.pcm_loop_filter_disabled_flag);
        FieldToDive(data_map, decoded_value.long_term_ref_pics_present_flag);
        FieldToDive(data_map, decoded_value.sps_temporal_mvp_enabled_flag);
        FieldToDive(data_map, decoded_value.strong_intra_smoothing_enabled_flag);
        FieldToDive(data_map, decoded_value.vui_parameters_present_flag);
        FieldToDive(data_map, decoded_value.sps_extension_present_flag);
        FieldToDive(data_map, decoded_value.sps_range_extension_flag);
        FieldToDive(data_map, decoded_value.transform_skip_rotation_enabled_flag);
        FieldToDive(data_map, decoded_value.transform_skip_context_enabled_flag);
        FieldToDive(data_map, decoded_value.implicit_rdpcm_enabled_flag);
        FieldToDive(data_map, decoded_value.explicit_rdpcm_enabled_flag);
        FieldToDive(data_map, decoded_value.extended_precision_processing_flag);
        FieldToDive(data_map, decoded_value.intra_smoothing_disabled_flag);
        FieldToDive(data_map, decoded_value.high_precision_offsets_enabled_flag);
        FieldToDive(data_map, decoded_value.persistent_rice_adaptation_enabled_flag);
        FieldToDive(data_map, decoded_value.cabac_bypass_alignment_enabled_flag);
        FieldToDive(data_map, decoded_value.sps_scc_extension_flag);
        FieldToDive(data_map, decoded_value.sps_curr_pic_ref_enabled_flag);
        FieldToDive(data_map, decoded_value.palette_mode_enabled_flag);
        FieldToDive(data_map, decoded_value.sps_palette_predictor_initializers_present_flag);
        FieldToDive(data_map, decoded_value.intra_boundary_filtering_disabled_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265SequenceParameterSet* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SequenceParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SequenceParameterSet& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.chroma_format_idc);
        FieldToDive(data_map, decoded_value.pic_width_in_luma_samples);
        FieldToDive(data_map, decoded_value.pic_height_in_luma_samples);
        FieldToDive(data_map, decoded_value.sps_video_parameter_set_id);
        FieldToDive(data_map, decoded_value.sps_max_sub_layers_minus1);
        FieldToDive(data_map, decoded_value.sps_seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.bit_depth_luma_minus8);
        FieldToDive(data_map, decoded_value.bit_depth_chroma_minus8);
        FieldToDive(data_map, decoded_value.log2_max_pic_order_cnt_lsb_minus4);
        FieldToDive(data_map, decoded_value.log2_min_luma_coding_block_size_minus3);
        FieldToDive(data_map, decoded_value.log2_diff_max_min_luma_coding_block_size);
        FieldToDive(data_map, decoded_value.log2_min_luma_transform_block_size_minus2);
        FieldToDive(data_map, decoded_value.log2_diff_max_min_luma_transform_block_size);
        FieldToDive(data_map, decoded_value.max_transform_hierarchy_depth_inter);
        FieldToDive(data_map, decoded_value.max_transform_hierarchy_depth_intra);
        FieldToDive(data_map, decoded_value.num_short_term_ref_pic_sets);
        FieldToDive(data_map, decoded_value.num_long_term_ref_pics_sps);
        FieldToDive(data_map, decoded_value.pcm_sample_bit_depth_luma_minus1);
        FieldToDive(data_map, decoded_value.pcm_sample_bit_depth_chroma_minus1);
        FieldToDive(data_map, decoded_value.log2_min_pcm_luma_coding_block_size_minus3);
        FieldToDive(data_map, decoded_value.log2_diff_max_min_pcm_luma_coding_block_size);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, decoded_value.palette_max_size);
        FieldToDive(data_map, decoded_value.delta_palette_max_predictor_size);
        FieldToDive(data_map, decoded_value.motion_vector_resolution_control_idc);
        FieldToDive(data_map, decoded_value.sps_num_palette_predictor_initializers_minus1);
        FieldToDive(data_map, decoded_value.conf_win_left_offset);
        FieldToDive(data_map, decoded_value.conf_win_right_offset);
        FieldToDive(data_map, decoded_value.conf_win_top_offset);
        FieldToDive(data_map, decoded_value.conf_win_bottom_offset);
        FieldToDive(data_map, meta_struct.pProfileTierLevel);
        FieldToDive(data_map, meta_struct.pDecPicBufMgr);
        FieldToDive(data_map, meta_struct.pScalingLists);
        FieldToDive(data_map, meta_struct.pShortTermRefPicSet);
        FieldToDive(data_map, meta_struct.pLongTermRefPicsSps);
        FieldToDive(data_map, meta_struct.pSequenceParameterSetVui);
        FieldToDive(data_map, meta_struct.pPredictorPaletteEntries);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265PpsFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265PpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265PpsFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.dependent_slice_segments_enabled_flag);
        FieldToDive(data_map, decoded_value.output_flag_present_flag);
        FieldToDive(data_map, decoded_value.sign_data_hiding_enabled_flag);
        FieldToDive(data_map, decoded_value.cabac_init_present_flag);
        FieldToDive(data_map, decoded_value.constrained_intra_pred_flag);
        FieldToDive(data_map, decoded_value.transform_skip_enabled_flag);
        FieldToDive(data_map, decoded_value.cu_qp_delta_enabled_flag);
        FieldToDive(data_map, decoded_value.pps_slice_chroma_qp_offsets_present_flag);
        FieldToDive(data_map, decoded_value.weighted_pred_flag);
        FieldToDive(data_map, decoded_value.weighted_bipred_flag);
        FieldToDive(data_map, decoded_value.transquant_bypass_enabled_flag);
        FieldToDive(data_map, decoded_value.tiles_enabled_flag);
        FieldToDive(data_map, decoded_value.entropy_coding_sync_enabled_flag);
        FieldToDive(data_map, decoded_value.uniform_spacing_flag);
        FieldToDive(data_map, decoded_value.loop_filter_across_tiles_enabled_flag);
        FieldToDive(data_map, decoded_value.pps_loop_filter_across_slices_enabled_flag);
        FieldToDive(data_map, decoded_value.deblocking_filter_control_present_flag);
        FieldToDive(data_map, decoded_value.deblocking_filter_override_enabled_flag);
        FieldToDive(data_map, decoded_value.pps_deblocking_filter_disabled_flag);
        FieldToDive(data_map, decoded_value.pps_scaling_list_data_present_flag);
        FieldToDive(data_map, decoded_value.lists_modification_present_flag);
        FieldToDive(data_map, decoded_value.slice_segment_header_extension_present_flag);
        FieldToDive(data_map, decoded_value.pps_extension_present_flag);
        FieldToDive(data_map, decoded_value.cross_component_prediction_enabled_flag);
        FieldToDive(data_map, decoded_value.chroma_qp_offset_list_enabled_flag);
        FieldToDive(data_map, decoded_value.pps_curr_pic_ref_enabled_flag);
        FieldToDive(data_map, decoded_value.residual_adaptive_colour_transform_enabled_flag);
        FieldToDive(data_map, decoded_value.pps_slice_act_qp_offsets_present_flag);
        FieldToDive(data_map, decoded_value.pps_palette_predictor_initializers_present_flag);
        FieldToDive(data_map, decoded_value.monochrome_palette_flag);
        FieldToDive(data_map, decoded_value.pps_range_extension_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoH265PictureParameterSet* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265PictureParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265PictureParameterSet& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.pps_pic_parameter_set_id);
        FieldToDive(data_map, decoded_value.pps_seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.sps_video_parameter_set_id);
        FieldToDive(data_map, decoded_value.num_extra_slice_header_bits);
        FieldToDive(data_map, decoded_value.num_ref_idx_l0_default_active_minus1);
        FieldToDive(data_map, decoded_value.num_ref_idx_l1_default_active_minus1);
        FieldToDive(data_map, decoded_value.init_qp_minus26);
        FieldToDive(data_map, decoded_value.diff_cu_qp_delta_depth);
        FieldToDive(data_map, decoded_value.pps_cb_qp_offset);
        FieldToDive(data_map, decoded_value.pps_cr_qp_offset);
        FieldToDive(data_map, decoded_value.pps_beta_offset_div2);
        FieldToDive(data_map, decoded_value.pps_tc_offset_div2);
        FieldToDive(data_map, decoded_value.log2_parallel_merge_level_minus2);
        FieldToDive(data_map, decoded_value.log2_max_transform_skip_block_size_minus2);
        FieldToDive(data_map, decoded_value.diff_cu_chroma_qp_offset_depth);
        FieldToDive(data_map, decoded_value.chroma_qp_offset_list_len_minus1);
        FieldToDive(data_map, &meta_struct.cb_qp_offset_list);
        FieldToDive(data_map, &meta_struct.cr_qp_offset_list);
        FieldToDive(data_map, decoded_value.log2_sao_offset_scale_luma);
        FieldToDive(data_map, decoded_value.log2_sao_offset_scale_chroma);
        FieldToDive(data_map, decoded_value.pps_act_y_qp_offset_plus5);
        FieldToDive(data_map, decoded_value.pps_act_cb_qp_offset_plus5);
        FieldToDive(data_map, decoded_value.pps_act_cr_qp_offset_plus3);
        FieldToDive(data_map, decoded_value.pps_num_palette_predictor_initializers);
        FieldToDive(data_map, decoded_value.luma_bit_depth_entry_minus8);
        FieldToDive(data_map, decoded_value.chroma_bit_depth_entry_minus8);
        FieldToDive(data_map, decoded_value.num_tile_columns_minus1);
        FieldToDive(data_map, decoded_value.num_tile_rows_minus1);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.reserved2);
        FieldToDive(data_map, &meta_struct.column_width_minus1);
        FieldToDive(data_map, &meta_struct.row_height_minus1);
        FieldToDive(data_map, decoded_value.reserved3);
        FieldToDive(data_map, meta_struct.pScalingLists);
        FieldToDive(data_map, meta_struct.pPredictorPaletteEntries);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH265PictureInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265PictureInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.IrapPicFlag);
        FieldToDive(data_map, decoded_value.IdrPicFlag);
        FieldToDive(data_map, decoded_value.IsReference);
        FieldToDive(data_map, decoded_value.short_term_ref_pic_set_sps_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH265PictureInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265PictureInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.sps_video_parameter_set_id);
        FieldToDive(data_map, decoded_value.pps_seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.pps_pic_parameter_set_id);
        FieldToDive(data_map, decoded_value.NumDeltaPocsOfRefRpsIdx);
        FieldToDive(data_map, decoded_value.PicOrderCntVal);
        FieldToDive(data_map, decoded_value.NumBitsForSTRefPicSetInSlice);
        FieldToDive(data_map, decoded_value.reserved);
        FieldToDive(data_map, &meta_struct.RefPicSetStCurrBefore);
        FieldToDive(data_map, &meta_struct.RefPicSetStCurrAfter);
        FieldToDive(data_map, &meta_struct.RefPicSetLtCurr);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH265ReferenceInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265ReferenceInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.used_for_long_term_reference);
        FieldToDive(data_map, decoded_value.unused_for_reference);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeH265ReferenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265ReferenceInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.PicOrderCntVal);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265WeightTableFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265WeightTableFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265WeightTableFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.luma_weight_l0_flag);
        FieldToDive(data_map, decoded_value.chroma_weight_l0_flag);
        FieldToDive(data_map, decoded_value.luma_weight_l1_flag);
        FieldToDive(data_map, decoded_value.chroma_weight_l1_flag);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265WeightTable* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265WeightTable& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265WeightTable& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.luma_log2_weight_denom);
        FieldToDive(data_map, decoded_value.delta_chroma_log2_weight_denom);
        FieldToDive(data_map, &meta_struct.delta_luma_weight_l0);
        FieldToDive(data_map, &meta_struct.luma_offset_l0);
        FieldToDive(data_map, &meta_struct.delta_chroma_weight_l0);
        FieldToDive(data_map, &meta_struct.delta_chroma_offset_l0);
        FieldToDive(data_map, &meta_struct.delta_luma_weight_l1);
        FieldToDive(data_map, &meta_struct.luma_offset_l1);
        FieldToDive(data_map, &meta_struct.delta_chroma_weight_l1);
        FieldToDive(data_map, &meta_struct.delta_chroma_offset_l1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265LongTermRefPics* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265LongTermRefPics& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265LongTermRefPics& meta_struct = *data;

        FieldToDive(data_map, decoded_value.num_long_term_sps);
        FieldToDive(data_map, decoded_value.num_long_term_pics);
        FieldToDive(data_map, &meta_struct.lt_idx_sps);
        FieldToDive(data_map, &meta_struct.poc_lsb_lt);
        FieldToDive(data_map, decoded_value.used_by_curr_pic_lt_flag);
        FieldToDive(data_map, &meta_struct.delta_poc_msb_present_flag);
        FieldToDive(data_map, &meta_struct.delta_poc_msb_cycle_lt);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265SliceSegmentHeaderFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.first_slice_segment_in_pic_flag);
        FieldToDive(data_map, decoded_value.dependent_slice_segment_flag);
        FieldToDive(data_map, decoded_value.slice_sao_luma_flag);
        FieldToDive(data_map, decoded_value.slice_sao_chroma_flag);
        FieldToDive(data_map, decoded_value.num_ref_idx_active_override_flag);
        FieldToDive(data_map, decoded_value.mvd_l1_zero_flag);
        FieldToDive(data_map, decoded_value.cabac_init_flag);
        FieldToDive(data_map, decoded_value.cu_chroma_qp_offset_enabled_flag);
        FieldToDive(data_map, decoded_value.deblocking_filter_override_flag);
        FieldToDive(data_map, decoded_value.slice_deblocking_filter_disabled_flag);
        FieldToDive(data_map, decoded_value.collocated_from_l0_flag);
        FieldToDive(data_map, decoded_value.slice_loop_filter_across_slices_enabled_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265SliceSegmentHeader* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265SliceSegmentHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265SliceSegmentHeader& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.slice_type);
        FieldToDive(data_map, decoded_value.slice_segment_address);
        FieldToDive(data_map, decoded_value.collocated_ref_idx);
        FieldToDive(data_map, decoded_value.MaxNumMergeCand);
        FieldToDive(data_map, decoded_value.slice_cb_qp_offset);
        FieldToDive(data_map, decoded_value.slice_cr_qp_offset);
        FieldToDive(data_map, decoded_value.slice_beta_offset_div2);
        FieldToDive(data_map, decoded_value.slice_tc_offset_div2);
        FieldToDive(data_map, decoded_value.slice_act_y_qp_offset);
        FieldToDive(data_map, decoded_value.slice_act_cb_qp_offset);
        FieldToDive(data_map, decoded_value.slice_act_cr_qp_offset);
        FieldToDive(data_map, decoded_value.slice_qp_delta);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, meta_struct.pWeightTable);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265ReferenceListsInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceListsInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceListsInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.ref_pic_list_modification_flag_l0);
        FieldToDive(data_map, decoded_value.ref_pic_list_modification_flag_l1);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265ReferenceListsInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceListsInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceListsInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.num_ref_idx_l0_active_minus1);
        FieldToDive(data_map, decoded_value.num_ref_idx_l1_active_minus1);
        FieldToDive(data_map, &meta_struct.RefPicList0);
        FieldToDive(data_map, &meta_struct.RefPicList1);
        FieldToDive(data_map, &meta_struct.list_entry_l0);
        FieldToDive(data_map, &meta_struct.list_entry_l1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265PictureInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265PictureInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.is_reference);
        FieldToDive(data_map, decoded_value.IrapPicFlag);
        FieldToDive(data_map, decoded_value.used_for_long_term_reference);
        FieldToDive(data_map, decoded_value.discardable_flag);
        FieldToDive(data_map, decoded_value.cross_layer_bla_flag);
        FieldToDive(data_map, decoded_value.pic_output_flag);
        FieldToDive(data_map, decoded_value.no_output_of_prior_pics_flag);
        FieldToDive(data_map, decoded_value.short_term_ref_pic_set_sps_flag);
        FieldToDive(data_map, decoded_value.slice_temporal_mvp_enabled_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265PictureInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265PictureInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.pic_type);
        FieldToDive(data_map, decoded_value.sps_video_parameter_set_id);
        FieldToDive(data_map, decoded_value.pps_seq_parameter_set_id);
        FieldToDive(data_map, decoded_value.pps_pic_parameter_set_id);
        FieldToDive(data_map, decoded_value.short_term_ref_pic_set_idx);
        FieldToDive(data_map, decoded_value.PicOrderCntVal);
        FieldToDive(data_map, decoded_value.TemporalId);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, meta_struct.pRefLists);
        FieldToDive(data_map, meta_struct.pShortTermRefPicSet);
        FieldToDive(data_map, meta_struct.pLongTermRefPics);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265ReferenceInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.used_for_long_term_reference);
        FieldToDive(data_map, decoded_value.unused_for_reference);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeH265ReferenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.pic_type);
        FieldToDive(data_map, decoded_value.PicOrderCntVal);
        FieldToDive(data_map, decoded_value.TemporalId);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1ColorConfigFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1ColorConfigFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1ColorConfigFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.mono_chrome);
        FieldToDive(data_map, decoded_value.color_range);
        FieldToDive(data_map, decoded_value.separate_uv_delta_q);
        FieldToDive(data_map, decoded_value.color_description_present_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1ColorConfig* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1ColorConfig& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1ColorConfig& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.BitDepth);
        FieldToDive(data_map, decoded_value.subsampling_x);
        FieldToDive(data_map, decoded_value.subsampling_y);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.color_primaries);
        FieldToDive(data_map, decoded_value.transfer_characteristics);
        FieldToDive(data_map, decoded_value.matrix_coefficients);
        FieldToDive(data_map, decoded_value.chroma_sample_position);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1TimingInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TimingInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TimingInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.equal_picture_interval);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1TimingInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TimingInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TimingInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.num_units_in_display_tick);
        FieldToDive(data_map, decoded_value.time_scale);
        FieldToDive(data_map, decoded_value.num_ticks_per_picture_minus_1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1SequenceHeaderFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1SequenceHeaderFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1SequenceHeaderFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.still_picture);
        FieldToDive(data_map, decoded_value.reduced_still_picture_header);
        FieldToDive(data_map, decoded_value.use_128x128_superblock);
        FieldToDive(data_map, decoded_value.enable_filter_intra);
        FieldToDive(data_map, decoded_value.enable_intra_edge_filter);
        FieldToDive(data_map, decoded_value.enable_interintra_compound);
        FieldToDive(data_map, decoded_value.enable_masked_compound);
        FieldToDive(data_map, decoded_value.enable_warped_motion);
        FieldToDive(data_map, decoded_value.enable_dual_filter);
        FieldToDive(data_map, decoded_value.enable_order_hint);
        FieldToDive(data_map, decoded_value.enable_jnt_comp);
        FieldToDive(data_map, decoded_value.enable_ref_frame_mvs);
        FieldToDive(data_map, decoded_value.frame_id_numbers_present_flag);
        FieldToDive(data_map, decoded_value.enable_superres);
        FieldToDive(data_map, decoded_value.enable_cdef);
        FieldToDive(data_map, decoded_value.enable_restoration);
        FieldToDive(data_map, decoded_value.film_grain_params_present);
        FieldToDive(data_map, decoded_value.timing_info_present_flag);
        FieldToDive(data_map, decoded_value.initial_display_delay_present_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1SequenceHeader* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1SequenceHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1SequenceHeader& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.seq_profile);
        FieldToDive(data_map, decoded_value.frame_width_bits_minus_1);
        FieldToDive(data_map, decoded_value.frame_height_bits_minus_1);
        FieldToDive(data_map, decoded_value.max_frame_width_minus_1);
        FieldToDive(data_map, decoded_value.max_frame_height_minus_1);
        FieldToDive(data_map, decoded_value.delta_frame_id_length_minus_2);
        FieldToDive(data_map, decoded_value.additional_frame_id_length_minus_1);
        FieldToDive(data_map, decoded_value.order_hint_bits_minus_1);
        FieldToDive(data_map, decoded_value.seq_force_integer_mv);
        FieldToDive(data_map, decoded_value.seq_force_screen_content_tools);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, meta_struct.pColorConfig);
        FieldToDive(data_map, meta_struct.pTimingInfo);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1LoopFilterFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1LoopFilterFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1LoopFilterFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.loop_filter_delta_enabled);
        FieldToDive(data_map, decoded_value.loop_filter_delta_update);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1LoopFilter* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1LoopFilter& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1LoopFilter& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, &meta_struct.loop_filter_level);
        FieldToDive(data_map, decoded_value.loop_filter_sharpness);
        FieldToDive(data_map, decoded_value.update_ref_delta);
        FieldToDive(data_map, &meta_struct.loop_filter_ref_deltas);
        FieldToDive(data_map, decoded_value.update_mode_delta);
        FieldToDive(data_map, &meta_struct.loop_filter_mode_deltas);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1QuantizationFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1QuantizationFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1QuantizationFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.using_qmatrix);
        FieldToDive(data_map, decoded_value.diff_uv_delta);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1Quantization* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1Quantization& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1Quantization& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.base_q_idx);
        FieldToDive(data_map, decoded_value.DeltaQYDc);
        FieldToDive(data_map, decoded_value.DeltaQUDc);
        FieldToDive(data_map, decoded_value.DeltaQUAc);
        FieldToDive(data_map, decoded_value.DeltaQVDc);
        FieldToDive(data_map, decoded_value.DeltaQVAc);
        FieldToDive(data_map, decoded_value.qm_y);
        FieldToDive(data_map, decoded_value.qm_u);
        FieldToDive(data_map, decoded_value.qm_v);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1Segmentation* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1Segmentation& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1Segmentation& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.FeatureEnabled);
        FieldToDive(data_map, &meta_struct.FeatureData);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1TileInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TileInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TileInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.uniform_tile_spacing_flag);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1TileInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TileInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TileInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.TileCols);
        FieldToDive(data_map, decoded_value.TileRows);
        FieldToDive(data_map, decoded_value.context_update_tile_id);
        FieldToDive(data_map, decoded_value.tile_size_bytes_minus_1);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, meta_struct.pMiColStarts);
        FieldToDive(data_map, meta_struct.pMiRowStarts);
        FieldToDive(data_map, meta_struct.pWidthInSbsMinus1);
        FieldToDive(data_map, meta_struct.pHeightInSbsMinus1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1CDEF* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1CDEF& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1CDEF& meta_struct = *data;

        FieldToDive(data_map, decoded_value.cdef_damping_minus_3);
        FieldToDive(data_map, decoded_value.cdef_bits);
        FieldToDive(data_map, &meta_struct.cdef_y_pri_strength);
        FieldToDive(data_map, &meta_struct.cdef_y_sec_strength);
        FieldToDive(data_map, &meta_struct.cdef_uv_pri_strength);
        FieldToDive(data_map, &meta_struct.cdef_uv_sec_strength);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1LoopRestoration* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1LoopRestoration& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1LoopRestoration& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.FrameRestorationType);
        FieldToDive(data_map, &meta_struct.LoopRestorationSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1GlobalMotion* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1GlobalMotion& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1GlobalMotion& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.GmType);
        FieldToDive(data_map, &meta_struct.gm_params);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1FilmGrainFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1FilmGrainFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1FilmGrainFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.chroma_scaling_from_luma);
        FieldToDive(data_map, decoded_value.overlap_flag);
        FieldToDive(data_map, decoded_value.clip_to_restricted_range);
        FieldToDive(data_map, decoded_value.update_grain);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoAV1FilmGrain* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1FilmGrain& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1FilmGrain& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.grain_scaling_minus_8);
        FieldToDive(data_map, decoded_value.ar_coeff_lag);
        FieldToDive(data_map, decoded_value.ar_coeff_shift_minus_6);
        FieldToDive(data_map, decoded_value.grain_scale_shift);
        FieldToDive(data_map, decoded_value.grain_seed);
        FieldToDive(data_map, decoded_value.film_grain_params_ref_idx);
        FieldToDive(data_map, decoded_value.num_y_points);
        FieldToDive(data_map, &meta_struct.point_y_value);
        FieldToDive(data_map, &meta_struct.point_y_scaling);
        FieldToDive(data_map, decoded_value.num_cb_points);
        FieldToDive(data_map, &meta_struct.point_cb_value);
        FieldToDive(data_map, &meta_struct.point_cb_scaling);
        FieldToDive(data_map, decoded_value.num_cr_points);
        FieldToDive(data_map, &meta_struct.point_cr_value);
        FieldToDive(data_map, &meta_struct.point_cr_scaling);
        FieldToDive(data_map, &meta_struct.ar_coeffs_y_plus_128);
        FieldToDive(data_map, &meta_struct.ar_coeffs_cb_plus_128);
        FieldToDive(data_map, &meta_struct.ar_coeffs_cr_plus_128);
        FieldToDive(data_map, decoded_value.cb_mult);
        FieldToDive(data_map, decoded_value.cb_luma_mult);
        FieldToDive(data_map, decoded_value.cb_offset);
        FieldToDive(data_map, decoded_value.cr_mult);
        FieldToDive(data_map, decoded_value.cr_luma_mult);
        FieldToDive(data_map, decoded_value.cr_offset);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeAV1PictureInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1PictureInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.error_resilient_mode);
        FieldToDive(data_map, decoded_value.disable_cdf_update);
        FieldToDive(data_map, decoded_value.use_superres);
        FieldToDive(data_map, decoded_value.render_and_frame_size_different);
        FieldToDive(data_map, decoded_value.allow_screen_content_tools);
        FieldToDive(data_map, decoded_value.is_filter_switchable);
        FieldToDive(data_map, decoded_value.force_integer_mv);
        FieldToDive(data_map, decoded_value.frame_size_override_flag);
        FieldToDive(data_map, decoded_value.buffer_removal_time_present_flag);
        FieldToDive(data_map, decoded_value.allow_intrabc);
        FieldToDive(data_map, decoded_value.frame_refs_short_signaling);
        FieldToDive(data_map, decoded_value.allow_high_precision_mv);
        FieldToDive(data_map, decoded_value.is_motion_mode_switchable);
        FieldToDive(data_map, decoded_value.use_ref_frame_mvs);
        FieldToDive(data_map, decoded_value.disable_frame_end_update_cdf);
        FieldToDive(data_map, decoded_value.allow_warped_motion);
        FieldToDive(data_map, decoded_value.reduced_tx_set);
        FieldToDive(data_map, decoded_value.reference_select);
        FieldToDive(data_map, decoded_value.skip_mode_present);
        FieldToDive(data_map, decoded_value.delta_q_present);
        FieldToDive(data_map, decoded_value.delta_lf_present);
        FieldToDive(data_map, decoded_value.delta_lf_multi);
        FieldToDive(data_map, decoded_value.segmentation_enabled);
        FieldToDive(data_map, decoded_value.segmentation_update_map);
        FieldToDive(data_map, decoded_value.segmentation_temporal_update);
        FieldToDive(data_map, decoded_value.segmentation_update_data);
        FieldToDive(data_map, decoded_value.UsesLr);
        FieldToDive(data_map, decoded_value.usesChromaLr);
        FieldToDive(data_map, decoded_value.apply_grain);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeAV1PictureInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1PictureInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.frame_type);
        FieldToDive(data_map, decoded_value.current_frame_id);
        FieldToDive(data_map, decoded_value.OrderHint);
        FieldToDive(data_map, decoded_value.primary_ref_frame);
        FieldToDive(data_map, decoded_value.refresh_frame_flags);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.interpolation_filter);
        FieldToDive(data_map, decoded_value.TxMode);
        FieldToDive(data_map, decoded_value.delta_q_res);
        FieldToDive(data_map, decoded_value.delta_lf_res);
        FieldToDive(data_map, &meta_struct.SkipModeFrame);
        FieldToDive(data_map, decoded_value.coded_denom);
        FieldToDive(data_map, &meta_struct.reserved2);
        FieldToDive(data_map, &meta_struct.OrderHints);
        FieldToDive(data_map, &meta_struct.expectedFrameId);
        FieldToDive(data_map, meta_struct.pTileInfo);
        FieldToDive(data_map, meta_struct.pQuantization);
        FieldToDive(data_map, meta_struct.pSegmentation);
        FieldToDive(data_map, meta_struct.pLoopFilter);
        FieldToDive(data_map, meta_struct.pCDEF);
        FieldToDive(data_map, meta_struct.pLoopRestoration);
        FieldToDive(data_map, meta_struct.pGlobalMotion);
        FieldToDive(data_map, meta_struct.pFilmGrain);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeAV1ReferenceInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1ReferenceInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.disable_frame_end_update_cdf);
        FieldToDive(data_map, decoded_value.segmentation_enabled);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoDecodeAV1ReferenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1ReferenceInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.frame_type);
        FieldToDive(data_map, decoded_value.RefFrameSignBias);
        FieldToDive(data_map, decoded_value.OrderHint);
        FieldToDive(data_map, &meta_struct.SavedOrderHints);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1ExtensionHeader* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1ExtensionHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1ExtensionHeader& meta_struct = *data;

        FieldToDive(data_map, decoded_value.temporal_id);
        FieldToDive(data_map, decoded_value.spatial_id);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1DecoderModelInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1DecoderModelInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1DecoderModelInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.buffer_delay_length_minus_1);
        FieldToDive(data_map, decoded_value.buffer_removal_time_length_minus_1);
        FieldToDive(data_map, decoded_value.frame_presentation_time_length_minus_1);
        FieldToDive(data_map, decoded_value.reserved1);
        FieldToDive(data_map, decoded_value.num_units_in_decoding_tick);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1OperatingPointInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1OperatingPointInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1OperatingPointInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.decoder_model_present_for_this_op);
        FieldToDive(data_map, decoded_value.low_delay_mode_flag);
        FieldToDive(data_map, decoded_value.initial_display_delay_present_for_this_op);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1OperatingPointInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1OperatingPointInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1OperatingPointInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.operating_point_idc);
        FieldToDive(data_map, decoded_value.seq_level_idx);
        FieldToDive(data_map, decoded_value.seq_tier);
        FieldToDive(data_map, decoded_value.decoder_buffer_delay);
        FieldToDive(data_map, decoded_value.encoder_buffer_delay);
        FieldToDive(data_map, decoded_value.initial_display_delay_minus_1);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1PictureInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1PictureInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.error_resilient_mode);
        FieldToDive(data_map, decoded_value.disable_cdf_update);
        FieldToDive(data_map, decoded_value.use_superres);
        FieldToDive(data_map, decoded_value.render_and_frame_size_different);
        FieldToDive(data_map, decoded_value.allow_screen_content_tools);
        FieldToDive(data_map, decoded_value.is_filter_switchable);
        FieldToDive(data_map, decoded_value.force_integer_mv);
        FieldToDive(data_map, decoded_value.frame_size_override_flag);
        FieldToDive(data_map, decoded_value.buffer_removal_time_present_flag);
        FieldToDive(data_map, decoded_value.allow_intrabc);
        FieldToDive(data_map, decoded_value.frame_refs_short_signaling);
        FieldToDive(data_map, decoded_value.allow_high_precision_mv);
        FieldToDive(data_map, decoded_value.is_motion_mode_switchable);
        FieldToDive(data_map, decoded_value.use_ref_frame_mvs);
        FieldToDive(data_map, decoded_value.disable_frame_end_update_cdf);
        FieldToDive(data_map, decoded_value.allow_warped_motion);
        FieldToDive(data_map, decoded_value.reduced_tx_set);
        FieldToDive(data_map, decoded_value.skip_mode_present);
        FieldToDive(data_map, decoded_value.delta_q_present);
        FieldToDive(data_map, decoded_value.delta_lf_present);
        FieldToDive(data_map, decoded_value.delta_lf_multi);
        FieldToDive(data_map, decoded_value.segmentation_enabled);
        FieldToDive(data_map, decoded_value.segmentation_update_map);
        FieldToDive(data_map, decoded_value.segmentation_temporal_update);
        FieldToDive(data_map, decoded_value.segmentation_update_data);
        FieldToDive(data_map, decoded_value.UsesLr);
        FieldToDive(data_map, decoded_value.usesChromaLr);
        FieldToDive(data_map, decoded_value.show_frame);
        FieldToDive(data_map, decoded_value.showable_frame);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1PictureInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1PictureInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.frame_type);
        FieldToDive(data_map, decoded_value.frame_presentation_time);
        FieldToDive(data_map, decoded_value.current_frame_id);
        FieldToDive(data_map, decoded_value.order_hint);
        FieldToDive(data_map, decoded_value.primary_ref_frame);
        FieldToDive(data_map, decoded_value.refresh_frame_flags);
        FieldToDive(data_map, decoded_value.coded_denom);
        FieldToDive(data_map, decoded_value.render_width_minus_1);
        FieldToDive(data_map, decoded_value.render_height_minus_1);
        FieldToDive(data_map, decoded_value.interpolation_filter);
        FieldToDive(data_map, decoded_value.TxMode);
        FieldToDive(data_map, decoded_value.delta_q_res);
        FieldToDive(data_map, decoded_value.delta_lf_res);
        FieldToDive(data_map, &meta_struct.ref_order_hint);
        FieldToDive(data_map, &meta_struct.ref_frame_idx);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, &meta_struct.delta_frame_id_minus_1);
        FieldToDive(data_map, meta_struct.pTileInfo);
        FieldToDive(data_map, meta_struct.pQuantization);
        FieldToDive(data_map, meta_struct.pSegmentation);
        FieldToDive(data_map, meta_struct.pLoopFilter);
        FieldToDive(data_map, meta_struct.pCDEF);
        FieldToDive(data_map, meta_struct.pLoopRestoration);
        FieldToDive(data_map, meta_struct.pGlobalMotion);
        FieldToDive(data_map, meta_struct.pExtensionHeader);
        FieldToDive(data_map, meta_struct.pBufferRemovalTimes);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1ReferenceInfoFlags* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1ReferenceInfoFlags& meta_struct = *data;

        FieldToDive(data_map, decoded_value.disable_frame_end_update_cdf);
        FieldToDive(data_map, decoded_value.segmentation_enabled);
        FieldToDive(data_map, decoded_value.reserved);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_StdVideoEncodeAV1ReferenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1ReferenceInfo& meta_struct = *data;

        FieldToDive(data_map, meta_struct.flags);
        FieldToDive(data_map, decoded_value.RefFrameId);
        FieldToDive(data_map, decoded_value.frame_type);
        FieldToDive(data_map, decoded_value.OrderHint);
        FieldToDive(data_map, &meta_struct.reserved1);
        FieldToDive(data_map, meta_struct.pExtensionHeader);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExtent2D* data)
{
    if (data && data->decoded_value)
    {
        const VkExtent2D& decoded_value = *data->decoded_value;
        const Decoded_VkExtent2D& meta_struct = *data;

        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExtent3D* data)
{
    if (data && data->decoded_value)
    {
        const VkExtent3D& decoded_value = *data->decoded_value;
        const Decoded_VkExtent3D& meta_struct = *data;

        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.depth);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOffset2D* data)
{
    if (data && data->decoded_value)
    {
        const VkOffset2D& decoded_value = *data->decoded_value;
        const Decoded_VkOffset2D& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOffset3D* data)
{
    if (data && data->decoded_value)
    {
        const VkOffset3D& decoded_value = *data->decoded_value;
        const Decoded_VkOffset3D& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
        FieldToDive(data_map, decoded_value.z);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRect2D* data)
{
    if (data && data->decoded_value)
    {
        const VkRect2D& decoded_value = *data->decoded_value;
        const Decoded_VkRect2D& meta_struct = *data;

        FieldToDive(data_map, meta_struct.offset);
        FieldToDive(data_map, meta_struct.extent);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferMemoryBarrier* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferMemoryBarrier& decoded_value = *data->decoded_value;
        const Decoded_VkBufferMemoryBarrier& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(data_map, decoded_value.srcQueueFamilyIndex);
        FieldToDive(data_map, decoded_value.dstQueueFamilyIndex);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDispatchIndirectCommand* data)
{
    if (data && data->decoded_value)
    {
        const VkDispatchIndirectCommand& decoded_value = *data->decoded_value;
        const Decoded_VkDispatchIndirectCommand& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
        FieldToDive(data_map, decoded_value.z);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrawIndexedIndirectCommand* data)
{
    if (data && data->decoded_value)
    {
        const VkDrawIndexedIndirectCommand& decoded_value = *data->decoded_value;
        const Decoded_VkDrawIndexedIndirectCommand& meta_struct = *data;

        FieldToDive(data_map, decoded_value.indexCount);
        FieldToDive(data_map, decoded_value.instanceCount);
        FieldToDive(data_map, decoded_value.firstIndex);
        FieldToDive(data_map, decoded_value.vertexOffset);
        FieldToDive(data_map, decoded_value.firstInstance);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrawIndirectCommand* data)
{
    if (data && data->decoded_value)
    {
        const VkDrawIndirectCommand& decoded_value = *data->decoded_value;
        const Decoded_VkDrawIndirectCommand& meta_struct = *data;

        FieldToDive(data_map, decoded_value.vertexCount);
        FieldToDive(data_map, decoded_value.instanceCount);
        FieldToDive(data_map, decoded_value.firstVertex);
        FieldToDive(data_map, decoded_value.firstInstance);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageSubresourceRange* data)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresourceRange& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresourceRange& meta_struct = *data;

        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
        FieldToDive(data_map, decoded_value.baseMipLevel);
        FieldToDive(data_map, decoded_value.levelCount);
        FieldToDive(data_map, decoded_value.baseArrayLayer);
        FieldToDive(data_map, decoded_value.layerCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageMemoryBarrier* data)
{
    if (data && data->decoded_value)
    {
        const VkImageMemoryBarrier& decoded_value = *data->decoded_value;
        const Decoded_VkImageMemoryBarrier& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(data_map, decoded_value.oldLayout);
        FieldToDive(data_map, decoded_value.newLayout);
        FieldToDive(data_map, decoded_value.srcQueueFamilyIndex);
        FieldToDive(data_map, decoded_value.dstQueueFamilyIndex);
        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, meta_struct.subresourceRange);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryBarrier* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryBarrier& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryBarrier& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCacheHeaderVersionOne* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCacheHeaderVersionOne& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCacheHeaderVersionOne& meta_struct = *data;

        FieldToDive(data_map, decoded_value.headerSize);
        FieldToDive(data_map, decoded_value.headerVersion);
        FieldToDive(data_map, decoded_value.vendorID);
        FieldToDive(data_map, decoded_value.deviceID);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.pipelineCacheUUID), decoded_value.pipelineCacheUUID));
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAllocationCallbacks* data)
{
    if (data && data->decoded_value)
    {
        const VkAllocationCallbacks& decoded_value = *data->decoded_value;
        const Decoded_VkAllocationCallbacks& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(meta_struct.pUserData));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnAllocation));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnReallocation));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnFree));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnInternalAllocation));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnInternalFree));
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkApplicationInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkApplicationInfo& decoded_value = *data->decoded_value;
        const Decoded_VkApplicationInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.pApplicationName);
        FieldToDive(data_map, decoded_value.applicationVersion);
        FieldToDive(data_map, &meta_struct.pEngineName);
        FieldToDive(data_map, decoded_value.engineVersion);
        FieldToDive(data_map, decoded_value.apiVersion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFormatProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkFormatProperties& meta_struct = *data;

        FieldToDive(VkFormatFeatureFlags_t(),data_map, decoded_value.linearTilingFeatures);
        FieldToDive(VkFormatFeatureFlags_t(),data_map, decoded_value.optimalTilingFeatures);
        FieldToDive(VkFormatFeatureFlags_t(),data_map, decoded_value.bufferFeatures);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageFormatProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkImageFormatProperties& meta_struct = *data;

        FieldToDive(data_map, meta_struct.maxExtent);
        FieldToDive(data_map, decoded_value.maxMipLevels);
        FieldToDive(data_map, decoded_value.maxArrayLayers);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampleCounts);
        FieldToDive(data_map, decoded_value.maxResourceSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkInstanceCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkInstanceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkInstanceCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkInstanceCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pApplicationInfo);
        FieldToDive(data_map, decoded_value.enabledLayerCount);
        FieldToDive(data_map, &meta_struct.ppEnabledLayerNames);
        FieldToDive(data_map, decoded_value.enabledExtensionCount);
        FieldToDive(data_map, &meta_struct.ppEnabledExtensionNames);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryHeap* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryHeap& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryHeap& meta_struct = *data;

        FieldToDive(data_map, decoded_value.size);
        FieldToDive(VkMemoryHeapFlags_t(),data_map, decoded_value.flags);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryType* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryType& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryType& meta_struct = *data;

        FieldToDive(VkMemoryPropertyFlags_t(),data_map, decoded_value.propertyFlags);
        FieldToDive(data_map, decoded_value.heapIndex);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.robustBufferAccess);
        FieldToDive(data_map, decoded_value.fullDrawIndexUint32);
        FieldToDive(data_map, decoded_value.imageCubeArray);
        FieldToDive(data_map, decoded_value.independentBlend);
        FieldToDive(data_map, decoded_value.geometryShader);
        FieldToDive(data_map, decoded_value.tessellationShader);
        FieldToDive(data_map, decoded_value.sampleRateShading);
        FieldToDive(data_map, decoded_value.dualSrcBlend);
        FieldToDive(data_map, decoded_value.logicOp);
        FieldToDive(data_map, decoded_value.multiDrawIndirect);
        FieldToDive(data_map, decoded_value.drawIndirectFirstInstance);
        FieldToDive(data_map, decoded_value.depthClamp);
        FieldToDive(data_map, decoded_value.depthBiasClamp);
        FieldToDive(data_map, decoded_value.fillModeNonSolid);
        FieldToDive(data_map, decoded_value.depthBounds);
        FieldToDive(data_map, decoded_value.wideLines);
        FieldToDive(data_map, decoded_value.largePoints);
        FieldToDive(data_map, decoded_value.alphaToOne);
        FieldToDive(data_map, decoded_value.multiViewport);
        FieldToDive(data_map, decoded_value.samplerAnisotropy);
        FieldToDive(data_map, decoded_value.textureCompressionETC2);
        FieldToDive(data_map, decoded_value.textureCompressionASTC_LDR);
        FieldToDive(data_map, decoded_value.textureCompressionBC);
        FieldToDive(data_map, decoded_value.occlusionQueryPrecise);
        FieldToDive(data_map, decoded_value.pipelineStatisticsQuery);
        FieldToDive(data_map, decoded_value.vertexPipelineStoresAndAtomics);
        FieldToDive(data_map, decoded_value.fragmentStoresAndAtomics);
        FieldToDive(data_map, decoded_value.shaderTessellationAndGeometryPointSize);
        FieldToDive(data_map, decoded_value.shaderImageGatherExtended);
        FieldToDive(data_map, decoded_value.shaderStorageImageExtendedFormats);
        FieldToDive(data_map, decoded_value.shaderStorageImageMultisample);
        FieldToDive(data_map, decoded_value.shaderStorageImageReadWithoutFormat);
        FieldToDive(data_map, decoded_value.shaderStorageImageWriteWithoutFormat);
        FieldToDive(data_map, decoded_value.shaderUniformBufferArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderSampledImageArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageBufferArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageImageArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderClipDistance);
        FieldToDive(data_map, decoded_value.shaderCullDistance);
        FieldToDive(data_map, decoded_value.shaderFloat64);
        FieldToDive(data_map, decoded_value.shaderInt64);
        FieldToDive(data_map, decoded_value.shaderInt16);
        FieldToDive(data_map, decoded_value.shaderResourceResidency);
        FieldToDive(data_map, decoded_value.shaderResourceMinLod);
        FieldToDive(data_map, decoded_value.sparseBinding);
        FieldToDive(data_map, decoded_value.sparseResidencyBuffer);
        FieldToDive(data_map, decoded_value.sparseResidencyImage2D);
        FieldToDive(data_map, decoded_value.sparseResidencyImage3D);
        FieldToDive(data_map, decoded_value.sparseResidency2Samples);
        FieldToDive(data_map, decoded_value.sparseResidency4Samples);
        FieldToDive(data_map, decoded_value.sparseResidency8Samples);
        FieldToDive(data_map, decoded_value.sparseResidency16Samples);
        FieldToDive(data_map, decoded_value.sparseResidencyAliased);
        FieldToDive(data_map, decoded_value.variableMultisampleRate);
        FieldToDive(data_map, decoded_value.inheritedQueries);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLimits* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLimits& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLimits& meta_struct = *data;

        FieldToDive(data_map, decoded_value.maxImageDimension1D);
        FieldToDive(data_map, decoded_value.maxImageDimension2D);
        FieldToDive(data_map, decoded_value.maxImageDimension3D);
        FieldToDive(data_map, decoded_value.maxImageDimensionCube);
        FieldToDive(data_map, decoded_value.maxImageArrayLayers);
        FieldToDive(data_map, decoded_value.maxTexelBufferElements);
        FieldToDive(data_map, decoded_value.maxUniformBufferRange);
        FieldToDive(data_map, decoded_value.maxStorageBufferRange);
        FieldToDive(data_map, decoded_value.maxPushConstantsSize);
        FieldToDive(data_map, decoded_value.maxMemoryAllocationCount);
        FieldToDive(data_map, decoded_value.maxSamplerAllocationCount);
        FieldToDive(data_map, decoded_value.bufferImageGranularity);
        FieldToDive(data_map, decoded_value.sparseAddressSpaceSize);
        FieldToDive(data_map, decoded_value.maxBoundDescriptorSets);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorSamplers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUniformBuffers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorStorageBuffers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorSampledImages);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorStorageImages);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorInputAttachments);
        FieldToDive(data_map, decoded_value.maxPerStageResources);
        FieldToDive(data_map, decoded_value.maxDescriptorSetSamplers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUniformBuffers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUniformBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetStorageBuffers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetStorageBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetSampledImages);
        FieldToDive(data_map, decoded_value.maxDescriptorSetStorageImages);
        FieldToDive(data_map, decoded_value.maxDescriptorSetInputAttachments);
        FieldToDive(data_map, decoded_value.maxVertexInputAttributes);
        FieldToDive(data_map, decoded_value.maxVertexInputBindings);
        FieldToDive(data_map, decoded_value.maxVertexInputAttributeOffset);
        FieldToDive(data_map, decoded_value.maxVertexInputBindingStride);
        FieldToDive(data_map, decoded_value.maxVertexOutputComponents);
        FieldToDive(data_map, decoded_value.maxTessellationGenerationLevel);
        FieldToDive(data_map, decoded_value.maxTessellationPatchSize);
        FieldToDive(data_map, decoded_value.maxTessellationControlPerVertexInputComponents);
        FieldToDive(data_map, decoded_value.maxTessellationControlPerVertexOutputComponents);
        FieldToDive(data_map, decoded_value.maxTessellationControlPerPatchOutputComponents);
        FieldToDive(data_map, decoded_value.maxTessellationControlTotalOutputComponents);
        FieldToDive(data_map, decoded_value.maxTessellationEvaluationInputComponents);
        FieldToDive(data_map, decoded_value.maxTessellationEvaluationOutputComponents);
        FieldToDive(data_map, decoded_value.maxGeometryShaderInvocations);
        FieldToDive(data_map, decoded_value.maxGeometryInputComponents);
        FieldToDive(data_map, decoded_value.maxGeometryOutputComponents);
        FieldToDive(data_map, decoded_value.maxGeometryOutputVertices);
        FieldToDive(data_map, decoded_value.maxGeometryTotalOutputComponents);
        FieldToDive(data_map, decoded_value.maxFragmentInputComponents);
        FieldToDive(data_map, decoded_value.maxFragmentOutputAttachments);
        FieldToDive(data_map, decoded_value.maxFragmentDualSrcAttachments);
        FieldToDive(data_map, decoded_value.maxFragmentCombinedOutputResources);
        FieldToDive(data_map, decoded_value.maxComputeSharedMemorySize);
        FieldToDive(data_map, &meta_struct.maxComputeWorkGroupCount);
        FieldToDive(data_map, decoded_value.maxComputeWorkGroupInvocations);
        FieldToDive(data_map, &meta_struct.maxComputeWorkGroupSize);
        FieldToDive(data_map, decoded_value.subPixelPrecisionBits);
        FieldToDive(data_map, decoded_value.subTexelPrecisionBits);
        FieldToDive(data_map, decoded_value.mipmapPrecisionBits);
        FieldToDive(data_map, decoded_value.maxDrawIndexedIndexValue);
        FieldToDive(data_map, decoded_value.maxDrawIndirectCount);
        FieldToDive(data_map, decoded_value.maxSamplerLodBias);
        FieldToDive(data_map, decoded_value.maxSamplerAnisotropy);
        FieldToDive(data_map, decoded_value.maxViewports);
        FieldToDive(data_map, &meta_struct.maxViewportDimensions);
        FieldToDive(data_map, &meta_struct.viewportBoundsRange);
        FieldToDive(data_map, decoded_value.viewportSubPixelBits);
        FieldToDive(data_map, decoded_value.minMemoryMapAlignment);
        FieldToDive(data_map, decoded_value.minTexelBufferOffsetAlignment);
        FieldToDive(data_map, decoded_value.minUniformBufferOffsetAlignment);
        FieldToDive(data_map, decoded_value.minStorageBufferOffsetAlignment);
        FieldToDive(data_map, decoded_value.minTexelOffset);
        FieldToDive(data_map, decoded_value.maxTexelOffset);
        FieldToDive(data_map, decoded_value.minTexelGatherOffset);
        FieldToDive(data_map, decoded_value.maxTexelGatherOffset);
        FieldToDive(data_map, decoded_value.minInterpolationOffset);
        FieldToDive(data_map, decoded_value.maxInterpolationOffset);
        FieldToDive(data_map, decoded_value.subPixelInterpolationOffsetBits);
        FieldToDive(data_map, decoded_value.maxFramebufferWidth);
        FieldToDive(data_map, decoded_value.maxFramebufferHeight);
        FieldToDive(data_map, decoded_value.maxFramebufferLayers);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.framebufferColorSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.framebufferDepthSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.framebufferStencilSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.framebufferNoAttachmentsSampleCounts);
        FieldToDive(data_map, decoded_value.maxColorAttachments);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampledImageColorSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampledImageIntegerSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampledImageDepthSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampledImageStencilSampleCounts);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.storageImageSampleCounts);
        FieldToDive(data_map, decoded_value.maxSampleMaskWords);
        FieldToDive(data_map, decoded_value.timestampComputeAndGraphics);
        FieldToDive(data_map, decoded_value.timestampPeriod);
        FieldToDive(data_map, decoded_value.maxClipDistances);
        FieldToDive(data_map, decoded_value.maxCullDistances);
        FieldToDive(data_map, decoded_value.maxCombinedClipAndCullDistances);
        FieldToDive(data_map, decoded_value.discreteQueuePriorities);
        FieldToDive(data_map, &meta_struct.pointSizeRange);
        FieldToDive(data_map, &meta_struct.lineWidthRange);
        FieldToDive(data_map, decoded_value.pointSizeGranularity);
        FieldToDive(data_map, decoded_value.lineWidthGranularity);
        FieldToDive(data_map, decoded_value.strictLines);
        FieldToDive(data_map, decoded_value.standardSampleLocations);
        FieldToDive(data_map, decoded_value.optimalBufferCopyOffsetAlignment);
        FieldToDive(data_map, decoded_value.optimalBufferCopyRowPitchAlignment);
        FieldToDive(data_map, decoded_value.nonCoherentAtomSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMemoryProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.memoryTypeCount);
        FieldToDive(data_map, meta_struct.memoryTypes);
        FieldToDive(data_map, decoded_value.memoryHeapCount);
        FieldToDive(data_map, meta_struct.memoryHeaps);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSparseProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSparseProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSparseProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.residencyStandard2DBlockShape);
        FieldToDive(data_map, decoded_value.residencyStandard2DMultisampleBlockShape);
        FieldToDive(data_map, decoded_value.residencyStandard3DBlockShape);
        FieldToDive(data_map, decoded_value.residencyAlignedMipSize);
        FieldToDive(data_map, decoded_value.residencyNonResidentStrict);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.apiVersion);
        FieldToDive(data_map, decoded_value.driverVersion);
        FieldToDive(data_map, decoded_value.vendorID);
        FieldToDive(data_map, decoded_value.deviceID);
        FieldToDive(data_map, decoded_value.deviceType);
        FieldToDive(data_map, &meta_struct.deviceName);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.pipelineCacheUUID), decoded_value.pipelineCacheUUID));
        FieldToDive(data_map, meta_struct.limits);
        FieldToDive(data_map, meta_struct.sparseProperties);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyProperties& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyProperties& meta_struct = *data;

        FieldToDive(VkQueueFlags_t(),data_map, decoded_value.queueFlags);
        FieldToDive(data_map, decoded_value.queueCount);
        FieldToDive(data_map, decoded_value.timestampValidBits);
        FieldToDive(data_map, meta_struct.minImageTransferGranularity);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceQueueCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceQueueCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.queueFamilyIndex);
        FieldToDive(data_map, decoded_value.queueCount);
        FieldToDive(data_map, meta_struct.pQueuePriorities);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.queueCreateInfoCount);
        FieldToDive(data_map, meta_struct.pQueueCreateInfos);
        FieldToDive(data_map, decoded_value.enabledLayerCount);
        FieldToDive(data_map, &meta_struct.ppEnabledLayerNames);
        FieldToDive(data_map, decoded_value.enabledExtensionCount);
        FieldToDive(data_map, &meta_struct.ppEnabledExtensionNames);
        FieldToDive(data_map, meta_struct.pEnabledFeatures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExtensionProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkExtensionProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExtensionProperties& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.extensionName);
        FieldToDive(data_map, decoded_value.specVersion);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLayerProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkLayerProperties& decoded_value = *data->decoded_value;
        const Decoded_VkLayerProperties& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.layerName);
        FieldToDive(data_map, decoded_value.specVersion);
        FieldToDive(data_map, decoded_value.implementationVersion);
        FieldToDive(data_map, &meta_struct.description);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubmitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSubmitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.waitSemaphoreCount);
        HandleToDive(data_map, &meta_struct.pWaitSemaphores);
        FieldToDive(data_map, meta_struct.pWaitDstStageMask);
        FieldToDive(data_map, decoded_value.commandBufferCount);
        HandleToDive(data_map, &meta_struct.pCommandBuffers);
        FieldToDive(data_map, decoded_value.signalSemaphoreCount);
        HandleToDive(data_map, &meta_struct.pSignalSemaphores);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMappedMemoryRange* data)
{
    if (data && data->decoded_value)
    {
        const VkMappedMemoryRange& decoded_value = *data->decoded_value;
        const Decoded_VkMappedMemoryRange& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.allocationSize);
        FieldToDive(data_map, decoded_value.memoryTypeIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryRequirements* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryRequirements& meta_struct = *data;

        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.alignment);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseMemoryBind* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseMemoryBind& decoded_value = *data->decoded_value;
        const Decoded_VkSparseMemoryBind& meta_struct = *data;

        FieldToDive(data_map, decoded_value.resourceOffset);
        FieldToDive(data_map, decoded_value.size);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.memoryOffset);
        FieldToDive(VkSparseMemoryBindFlags_t(),data_map, decoded_value.flags);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseBufferMemoryBindInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseBufferMemoryBindInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSparseBufferMemoryBindInfo& meta_struct = *data;

        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.bindCount);
        FieldToDive(data_map, meta_struct.pBinds);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageOpaqueMemoryBindInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageOpaqueMemoryBindInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageOpaqueMemoryBindInfo& meta_struct = *data;

        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, decoded_value.bindCount);
        FieldToDive(data_map, meta_struct.pBinds);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageSubresource* data)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresource& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresource& meta_struct = *data;

        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
        FieldToDive(data_map, decoded_value.mipLevel);
        FieldToDive(data_map, decoded_value.arrayLayer);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageMemoryBind* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryBind& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryBind& meta_struct = *data;

        FieldToDive(data_map, meta_struct.subresource);
        FieldToDive(data_map, meta_struct.offset);
        FieldToDive(data_map, meta_struct.extent);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.memoryOffset);
        FieldToDive(VkSparseMemoryBindFlags_t(),data_map, decoded_value.flags);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageMemoryBindInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryBindInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryBindInfo& meta_struct = *data;

        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, decoded_value.bindCount);
        FieldToDive(data_map, meta_struct.pBinds);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindSparseInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindSparseInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindSparseInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.waitSemaphoreCount);
        HandleToDive(data_map, &meta_struct.pWaitSemaphores);
        FieldToDive(data_map, decoded_value.bufferBindCount);
        FieldToDive(data_map, meta_struct.pBufferBinds);
        FieldToDive(data_map, decoded_value.imageOpaqueBindCount);
        FieldToDive(data_map, meta_struct.pImageOpaqueBinds);
        FieldToDive(data_map, decoded_value.imageBindCount);
        FieldToDive(data_map, meta_struct.pImageBinds);
        FieldToDive(data_map, decoded_value.signalSemaphoreCount);
        HandleToDive(data_map, &meta_struct.pSignalSemaphores);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageFormatProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageFormatProperties& meta_struct = *data;

        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
        FieldToDive(data_map, meta_struct.imageGranularity);
        FieldToDive(VkSparseImageFormatFlags_t(),data_map, decoded_value.flags);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageMemoryRequirements* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryRequirements& meta_struct = *data;

        FieldToDive(data_map, meta_struct.formatProperties);
        FieldToDive(data_map, decoded_value.imageMipTailFirstLod);
        FieldToDive(data_map, decoded_value.imageMipTailSize);
        FieldToDive(data_map, decoded_value.imageMipTailOffset);
        FieldToDive(data_map, decoded_value.imageMipTailStride);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFenceCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkFenceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFenceCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkFenceCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSemaphoreCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkEventCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkEventCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkEventCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkEventCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueryPoolCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkQueryPoolCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.queryType);
        FieldToDive(data_map, decoded_value.queryCount);
        FieldToDive(VkQueryPipelineStatisticFlags_t(),data_map, decoded_value.pipelineStatistics);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkBufferCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(VkBufferUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, decoded_value.sharingMode);
        FieldToDive(data_map, decoded_value.queueFamilyIndexCount);
        FieldToDive(data_map, meta_struct.pQueueFamilyIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferViewCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferViewCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferViewCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkBufferViewCreateFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.range);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkImageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.imageType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, meta_struct.extent);
        FieldToDive(data_map, decoded_value.mipLevels);
        FieldToDive(data_map, decoded_value.arrayLayers);
        FieldToDive(data_map, decoded_value.samples);
        FieldToDive(data_map, decoded_value.tiling);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, decoded_value.sharingMode);
        FieldToDive(data_map, decoded_value.queueFamilyIndexCount);
        FieldToDive(data_map, meta_struct.pQueueFamilyIndices);
        FieldToDive(data_map, decoded_value.initialLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubresourceLayout* data)
{
    if (data && data->decoded_value)
    {
        const VkSubresourceLayout& decoded_value = *data->decoded_value;
        const Decoded_VkSubresourceLayout& meta_struct = *data;

        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.rowPitch);
        FieldToDive(data_map, decoded_value.arrayPitch);
        FieldToDive(data_map, decoded_value.depthPitch);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkComponentMapping* data)
{
    if (data && data->decoded_value)
    {
        const VkComponentMapping& decoded_value = *data->decoded_value;
        const Decoded_VkComponentMapping& meta_struct = *data;

        FieldToDive(data_map, decoded_value.r);
        FieldToDive(data_map, decoded_value.g);
        FieldToDive(data_map, decoded_value.b);
        FieldToDive(data_map, decoded_value.a);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageViewCreateFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, decoded_value.viewType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, meta_struct.components);
        FieldToDive(data_map, meta_struct.subresourceRange);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSpecializationMapEntry* data)
{
    if (data && data->decoded_value)
    {
        const VkSpecializationMapEntry& decoded_value = *data->decoded_value;
        const Decoded_VkSpecializationMapEntry& meta_struct = *data;

        FieldToDive(data_map, decoded_value.constantID);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSpecializationInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSpecializationInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSpecializationInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.mapEntryCount);
        FieldToDive(data_map, meta_struct.pMapEntries);
        FieldToDive(data_map, decoded_value.dataSize);
        FieldToDive(data_map, meta_struct.pData);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineShaderStageCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineShaderStageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineShaderStageCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineShaderStageCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.stage);
        HandleToDive(data_map, meta_struct.module);
        FieldToDive(data_map, &meta_struct.pName);
        FieldToDive(data_map, meta_struct.pSpecializationInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkComputePipelineCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkComputePipelineCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkComputePipelineCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.stage);
        HandleToDive(data_map, meta_struct.layout);
        HandleToDive(data_map, meta_struct.basePipelineHandle);
        FieldToDive(data_map, decoded_value.basePipelineIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVertexInputBindingDescription* data)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputBindingDescription& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputBindingDescription& meta_struct = *data;

        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, decoded_value.stride);
        FieldToDive(data_map, decoded_value.inputRate);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVertexInputAttributeDescription* data)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputAttributeDescription& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputAttributeDescription& meta_struct = *data;

        FieldToDive(data_map, decoded_value.location);
        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.offset);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineVertexInputStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineVertexInputStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineVertexInputStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineVertexInputStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.vertexBindingDescriptionCount);
        FieldToDive(data_map, meta_struct.pVertexBindingDescriptions);
        FieldToDive(data_map, decoded_value.vertexAttributeDescriptionCount);
        FieldToDive(data_map, meta_struct.pVertexAttributeDescriptions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineInputAssemblyStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineInputAssemblyStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineInputAssemblyStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineInputAssemblyStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.topology);
        FieldToDive(data_map, decoded_value.primitiveRestartEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineTessellationStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineTessellationStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineTessellationStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineTessellationStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.patchControlPoints);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkViewport* data)
{
    if (data && data->decoded_value)
    {
        const VkViewport& decoded_value = *data->decoded_value;
        const Decoded_VkViewport& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.minDepth);
        FieldToDive(data_map, decoded_value.maxDepth);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineViewportStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.viewportCount);
        FieldToDive(data_map, meta_struct.pViewports);
        FieldToDive(data_map, decoded_value.scissorCount);
        FieldToDive(data_map, meta_struct.pScissors);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineRasterizationStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.depthClampEnable);
        FieldToDive(data_map, decoded_value.rasterizerDiscardEnable);
        FieldToDive(data_map, decoded_value.polygonMode);
        FieldToDive(VkCullModeFlags_t(),data_map, decoded_value.cullMode);
        FieldToDive(data_map, decoded_value.frontFace);
        FieldToDive(data_map, decoded_value.depthBiasEnable);
        FieldToDive(data_map, decoded_value.depthBiasConstantFactor);
        FieldToDive(data_map, decoded_value.depthBiasClamp);
        FieldToDive(data_map, decoded_value.depthBiasSlopeFactor);
        FieldToDive(data_map, decoded_value.lineWidth);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineMultisampleStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineMultisampleStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineMultisampleStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineMultisampleStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.rasterizationSamples);
        FieldToDive(data_map, decoded_value.sampleShadingEnable);
        FieldToDive(data_map, decoded_value.minSampleShading);
        FieldToDive(data_map, meta_struct.pSampleMask);
        FieldToDive(data_map, decoded_value.alphaToCoverageEnable);
        FieldToDive(data_map, decoded_value.alphaToOneEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkStencilOpState* data)
{
    if (data && data->decoded_value)
    {
        const VkStencilOpState& decoded_value = *data->decoded_value;
        const Decoded_VkStencilOpState& meta_struct = *data;

        FieldToDive(data_map, decoded_value.failOp);
        FieldToDive(data_map, decoded_value.passOp);
        FieldToDive(data_map, decoded_value.depthFailOp);
        FieldToDive(data_map, decoded_value.compareOp);
        FieldToDive(data_map, decoded_value.compareMask);
        FieldToDive(data_map, decoded_value.writeMask);
        FieldToDive(data_map, decoded_value.reference);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineDepthStencilStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineDepthStencilStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineDepthStencilStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineDepthStencilStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.depthTestEnable);
        FieldToDive(data_map, decoded_value.depthWriteEnable);
        FieldToDive(data_map, decoded_value.depthCompareOp);
        FieldToDive(data_map, decoded_value.depthBoundsTestEnable);
        FieldToDive(data_map, decoded_value.stencilTestEnable);
        FieldToDive(data_map, meta_struct.front);
        FieldToDive(data_map, meta_struct.back);
        FieldToDive(data_map, decoded_value.minDepthBounds);
        FieldToDive(data_map, decoded_value.maxDepthBounds);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineColorBlendAttachmentState* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorBlendAttachmentState& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorBlendAttachmentState& meta_struct = *data;

        FieldToDive(data_map, decoded_value.blendEnable);
        FieldToDive(data_map, decoded_value.srcColorBlendFactor);
        FieldToDive(data_map, decoded_value.dstColorBlendFactor);
        FieldToDive(data_map, decoded_value.colorBlendOp);
        FieldToDive(data_map, decoded_value.srcAlphaBlendFactor);
        FieldToDive(data_map, decoded_value.dstAlphaBlendFactor);
        FieldToDive(data_map, decoded_value.alphaBlendOp);
        FieldToDive(VkColorComponentFlags_t(),data_map, decoded_value.colorWriteMask);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineColorBlendStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorBlendStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorBlendStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineColorBlendStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.logicOpEnable);
        FieldToDive(data_map, decoded_value.logicOp);
        FieldToDive(data_map, decoded_value.attachmentCount);
        FieldToDive(data_map, meta_struct.pAttachments);
        FieldToDive(data_map, &meta_struct.blendConstants);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineDynamicStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineDynamicStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineDynamicStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineDynamicStateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.dynamicStateCount);
        FieldToDive(data_map, meta_struct.pDynamicStates);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGraphicsPipelineCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsPipelineCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsPipelineCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.stageCount);
        FieldToDive(data_map, meta_struct.pStages);
        FieldToDive(data_map, meta_struct.pVertexInputState);
        FieldToDive(data_map, meta_struct.pInputAssemblyState);
        FieldToDive(data_map, meta_struct.pTessellationState);
        FieldToDive(data_map, meta_struct.pViewportState);
        FieldToDive(data_map, meta_struct.pRasterizationState);
        FieldToDive(data_map, meta_struct.pMultisampleState);
        FieldToDive(data_map, meta_struct.pDepthStencilState);
        FieldToDive(data_map, meta_struct.pColorBlendState);
        FieldToDive(data_map, meta_struct.pDynamicState);
        HandleToDive(data_map, meta_struct.layout);
        HandleToDive(data_map, meta_struct.renderPass);
        FieldToDive(data_map, decoded_value.subpass);
        HandleToDive(data_map, meta_struct.basePipelineHandle);
        FieldToDive(data_map, decoded_value.basePipelineIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPushConstantRange* data)
{
    if (data && data->decoded_value)
    {
        const VkPushConstantRange& decoded_value = *data->decoded_value;
        const Decoded_VkPushConstantRange& meta_struct = *data;

        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineLayoutCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineLayoutCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineLayoutCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineLayoutCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.setLayoutCount);
        HandleToDive(data_map, &meta_struct.pSetLayouts);
        FieldToDive(data_map, decoded_value.pushConstantRangeCount);
        FieldToDive(data_map, meta_struct.pPushConstantRanges);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSamplerCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.magFilter);
        FieldToDive(data_map, decoded_value.minFilter);
        FieldToDive(data_map, decoded_value.mipmapMode);
        FieldToDive(data_map, decoded_value.addressModeU);
        FieldToDive(data_map, decoded_value.addressModeV);
        FieldToDive(data_map, decoded_value.addressModeW);
        FieldToDive(data_map, decoded_value.mipLodBias);
        FieldToDive(data_map, decoded_value.anisotropyEnable);
        FieldToDive(data_map, decoded_value.maxAnisotropy);
        FieldToDive(data_map, decoded_value.compareEnable);
        FieldToDive(data_map, decoded_value.compareOp);
        FieldToDive(data_map, decoded_value.minLod);
        FieldToDive(data_map, decoded_value.maxLod);
        FieldToDive(data_map, decoded_value.borderColor);
        FieldToDive(data_map, decoded_value.unnormalizedCoordinates);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyDescriptorSet* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyDescriptorSet& decoded_value = *data->decoded_value;
        const Decoded_VkCopyDescriptorSet& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcSet);
        FieldToDive(data_map, decoded_value.srcBinding);
        FieldToDive(data_map, decoded_value.srcArrayElement);
        HandleToDive(data_map, meta_struct.dstSet);
        FieldToDive(data_map, decoded_value.dstBinding);
        FieldToDive(data_map, decoded_value.dstArrayElement);
        FieldToDive(data_map, decoded_value.descriptorCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorBufferInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorBufferInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorBufferInfo& meta_struct = *data;

        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.range);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorPoolSize* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorPoolSize& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorPoolSize& meta_struct = *data;

        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.descriptorCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorPoolCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorPoolCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorPoolCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDescriptorPoolCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.maxSets);
        FieldToDive(data_map, decoded_value.poolSizeCount);
        FieldToDive(data_map, meta_struct.pPoolSizes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.descriptorPool);
        FieldToDive(data_map, decoded_value.descriptorSetCount);
        HandleToDive(data_map, &meta_struct.pSetLayouts);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetLayoutBinding* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutBinding& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutBinding& meta_struct = *data;

        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, decoded_value.descriptorType);
        FieldToDive(data_map, decoded_value.descriptorCount);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        HandleToDive(data_map, &meta_struct.pImmutableSamplers);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetLayoutCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDescriptorSetLayoutCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.bindingCount);
        FieldToDive(data_map, meta_struct.pBindings);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentDescription* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentDescription& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentDescription& meta_struct = *data;

        FieldToDive(VkAttachmentDescriptionFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.samples);
        FieldToDive(data_map, decoded_value.loadOp);
        FieldToDive(data_map, decoded_value.storeOp);
        FieldToDive(data_map, decoded_value.stencilLoadOp);
        FieldToDive(data_map, decoded_value.stencilStoreOp);
        FieldToDive(data_map, decoded_value.initialLayout);
        FieldToDive(data_map, decoded_value.finalLayout);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentReference* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentReference& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentReference& meta_struct = *data;

        FieldToDive(data_map, decoded_value.attachment);
        FieldToDive(data_map, decoded_value.layout);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFramebufferCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkFramebufferCreateFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.renderPass);
        FieldToDive(data_map, decoded_value.attachmentCount);
        HandleToDive(data_map, &meta_struct.pAttachments);
        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.layers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassDescription* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDescription& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDescription& meta_struct = *data;

        FieldToDive(VkSubpassDescriptionFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        FieldToDive(data_map, decoded_value.inputAttachmentCount);
        FieldToDive(data_map, meta_struct.pInputAttachments);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachments);
        FieldToDive(data_map, meta_struct.pResolveAttachments);
        FieldToDive(data_map, meta_struct.pDepthStencilAttachment);
        FieldToDive(data_map, decoded_value.preserveAttachmentCount);
        FieldToDive(data_map, meta_struct.pPreserveAttachments);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassDependency* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDependency& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDependency& meta_struct = *data;

        FieldToDive(data_map, decoded_value.srcSubpass);
        FieldToDive(data_map, decoded_value.dstSubpass);
        FieldToDive(VkPipelineStageFlags_t(),data_map, decoded_value.srcStageMask);
        FieldToDive(VkPipelineStageFlags_t(),data_map, decoded_value.dstStageMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(VkDependencyFlags_t(),data_map, decoded_value.dependencyFlags);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkRenderPassCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.attachmentCount);
        FieldToDive(data_map, meta_struct.pAttachments);
        FieldToDive(data_map, decoded_value.subpassCount);
        FieldToDive(data_map, meta_struct.pSubpasses);
        FieldToDive(data_map, decoded_value.dependencyCount);
        FieldToDive(data_map, meta_struct.pDependencies);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandPoolCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandPoolCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandPoolCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkCommandPoolCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.queueFamilyIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.commandPool);
        FieldToDive(data_map, decoded_value.level);
        FieldToDive(data_map, decoded_value.commandBufferCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferInheritanceInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.renderPass);
        FieldToDive(data_map, decoded_value.subpass);
        HandleToDive(data_map, meta_struct.framebuffer);
        FieldToDive(data_map, decoded_value.occlusionQueryEnable);
        FieldToDive(VkQueryControlFlags_t(),data_map, decoded_value.queryFlags);
        FieldToDive(VkQueryPipelineStatisticFlags_t(),data_map, decoded_value.pipelineStatistics);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferBeginInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferBeginInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkCommandBufferUsageFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pInheritanceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferCopy* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferCopy& decoded_value = *data->decoded_value;
        const Decoded_VkBufferCopy& meta_struct = *data;

        FieldToDive(data_map, decoded_value.srcOffset);
        FieldToDive(data_map, decoded_value.dstOffset);
        FieldToDive(data_map, decoded_value.size);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageSubresourceLayers* data)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresourceLayers& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresourceLayers& meta_struct = *data;

        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
        FieldToDive(data_map, decoded_value.mipLevel);
        FieldToDive(data_map, decoded_value.baseArrayLayer);
        FieldToDive(data_map, decoded_value.layerCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferImageCopy* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferImageCopy& decoded_value = *data->decoded_value;
        const Decoded_VkBufferImageCopy& meta_struct = *data;

        FieldToDive(data_map, decoded_value.bufferOffset);
        FieldToDive(data_map, decoded_value.bufferRowLength);
        FieldToDive(data_map, decoded_value.bufferImageHeight);
        FieldToDive(data_map, meta_struct.imageSubresource);
        FieldToDive(data_map, meta_struct.imageOffset);
        FieldToDive(data_map, meta_struct.imageExtent);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkClearDepthStencilValue* data)
{
    if (data && data->decoded_value)
    {
        const VkClearDepthStencilValue& decoded_value = *data->decoded_value;
        const Decoded_VkClearDepthStencilValue& meta_struct = *data;

        FieldToDive(data_map, decoded_value.depth);
        FieldToDive(data_map, decoded_value.stencil);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkClearAttachment* data)
{
    if (data && data->decoded_value)
    {
        const VkClearAttachment& decoded_value = *data->decoded_value;
        const Decoded_VkClearAttachment& meta_struct = *data;

        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
        FieldToDive(data_map, decoded_value.colorAttachment);
        FieldToDive(data_map, meta_struct.clearValue);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkClearRect* data)
{
    if (data && data->decoded_value)
    {
        const VkClearRect& decoded_value = *data->decoded_value;
        const Decoded_VkClearRect& meta_struct = *data;

        FieldToDive(data_map, meta_struct.rect);
        FieldToDive(data_map, decoded_value.baseArrayLayer);
        FieldToDive(data_map, decoded_value.layerCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageBlit* data)
{
    if (data && data->decoded_value)
    {
        const VkImageBlit& decoded_value = *data->decoded_value;
        const Decoded_VkImageBlit& meta_struct = *data;

        FieldToDive(data_map, meta_struct.srcSubresource);
        FieldToDive(data_map, meta_struct.srcOffsets);
        FieldToDive(data_map, meta_struct.dstSubresource);
        FieldToDive(data_map, meta_struct.dstOffsets);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageCopy* data)
{
    if (data && data->decoded_value)
    {
        const VkImageCopy& decoded_value = *data->decoded_value;
        const Decoded_VkImageCopy& meta_struct = *data;

        FieldToDive(data_map, meta_struct.srcSubresource);
        FieldToDive(data_map, meta_struct.srcOffset);
        FieldToDive(data_map, meta_struct.dstSubresource);
        FieldToDive(data_map, meta_struct.dstOffset);
        FieldToDive(data_map, meta_struct.extent);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageResolve* data)
{
    if (data && data->decoded_value)
    {
        const VkImageResolve& decoded_value = *data->decoded_value;
        const Decoded_VkImageResolve& meta_struct = *data;

        FieldToDive(data_map, meta_struct.srcSubresource);
        FieldToDive(data_map, meta_struct.srcOffset);
        FieldToDive(data_map, meta_struct.dstSubresource);
        FieldToDive(data_map, meta_struct.dstOffset);
        FieldToDive(data_map, meta_struct.extent);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassBeginInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassBeginInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.renderPass);
        HandleToDive(data_map, meta_struct.framebuffer);
        FieldToDive(data_map, meta_struct.renderArea);
        FieldToDive(data_map, decoded_value.clearValueCount);
        FieldToDive(data_map, meta_struct.pClearValues);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSubgroupProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubgroupProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubgroupProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.subgroupSize);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.supportedStages);
        FieldToDive(VkSubgroupFeatureFlags_t(),data_map, decoded_value.supportedOperations);
        FieldToDive(data_map, decoded_value.quadOperationsInAllStages);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindBufferMemoryInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindBufferMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindBufferMemoryInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.buffer);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.memoryOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindImageMemoryInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindImageMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindImageMemoryInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.image);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.memoryOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevice16BitStorageFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevice16BitStorageFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevice16BitStorageFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.storageBuffer16BitAccess);
        FieldToDive(data_map, decoded_value.uniformAndStorageBuffer16BitAccess);
        FieldToDive(data_map, decoded_value.storagePushConstant16);
        FieldToDive(data_map, decoded_value.storageInputOutput16);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryDedicatedRequirements* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryDedicatedRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryDedicatedRequirements& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.prefersDedicatedAllocation);
        FieldToDive(data_map, decoded_value.requiresDedicatedAllocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryDedicatedAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryDedicatedAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryDedicatedAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.image);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryAllocateFlagsInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryAllocateFlagsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryAllocateFlagsInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkMemoryAllocateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.deviceMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupRenderPassBeginInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupRenderPassBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupRenderPassBeginInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceMask);
        FieldToDive(data_map, decoded_value.deviceRenderAreaCount);
        FieldToDive(data_map, meta_struct.pDeviceRenderAreas);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupCommandBufferBeginInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupCommandBufferBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupCommandBufferBeginInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupSubmitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupSubmitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.waitSemaphoreCount);
        FieldToDive(data_map, meta_struct.pWaitSemaphoreDeviceIndices);
        FieldToDive(data_map, decoded_value.commandBufferCount);
        FieldToDive(data_map, meta_struct.pCommandBufferDeviceMasks);
        FieldToDive(data_map, decoded_value.signalSemaphoreCount);
        FieldToDive(data_map, meta_struct.pSignalSemaphoreDeviceIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupBindSparseInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupBindSparseInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupBindSparseInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.resourceDeviceIndex);
        FieldToDive(data_map, decoded_value.memoryDeviceIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindBufferMemoryDeviceGroupInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindBufferMemoryDeviceGroupInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindBufferMemoryDeviceGroupInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceIndexCount);
        FieldToDive(data_map, meta_struct.pDeviceIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindImageMemoryDeviceGroupInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindImageMemoryDeviceGroupInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindImageMemoryDeviceGroupInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceIndexCount);
        FieldToDive(data_map, meta_struct.pDeviceIndices);
        FieldToDive(data_map, decoded_value.splitInstanceBindRegionCount);
        FieldToDive(data_map, meta_struct.pSplitInstanceBindRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceGroupProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGroupProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGroupProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.physicalDeviceCount);
        HandleToDive(data_map, &meta_struct.physicalDevices);
        FieldToDive(data_map, decoded_value.subsetAllocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupDeviceCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupDeviceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupDeviceCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.physicalDeviceCount);
        HandleToDive(data_map, &meta_struct.pPhysicalDevices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferMemoryRequirementsInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferMemoryRequirementsInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferMemoryRequirementsInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageMemoryRequirementsInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageMemoryRequirementsInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkImageMemoryRequirementsInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageSparseMemoryRequirementsInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageSparseMemoryRequirementsInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkImageSparseMemoryRequirementsInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryRequirements2* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryRequirements2& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryRequirements2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.memoryRequirements);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageMemoryRequirements2* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryRequirements2& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryRequirements2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.memoryRequirements);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFeatures2* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFeatures2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFeatures2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.features);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceProperties2* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProperties2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.properties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFormatProperties2* data)
{
    if (data && data->decoded_value)
    {
        const VkFormatProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkFormatProperties2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.formatProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageFormatProperties2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageFormatProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkImageFormatProperties2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.imageFormatProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageFormatInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageFormatInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageFormatInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.tiling);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(VkImageCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyProperties2* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyProperties2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.queueFamilyProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMemoryProperties2* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryProperties2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.memoryProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSparseImageFormatProperties2* data)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageFormatProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageFormatProperties2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.properties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSparseImageFormatInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSparseImageFormatInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.samples);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, decoded_value.tiling);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePointClippingProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePointClippingProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePointClippingProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pointClippingBehavior);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkInputAttachmentAspectReference* data)
{
    if (data && data->decoded_value)
    {
        const VkInputAttachmentAspectReference& decoded_value = *data->decoded_value;
        const Decoded_VkInputAttachmentAspectReference& meta_struct = *data;

        FieldToDive(data_map, decoded_value.subpass);
        FieldToDive(data_map, decoded_value.inputAttachmentIndex);
        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassInputAttachmentAspectCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassInputAttachmentAspectCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.aspectReferenceCount);
        FieldToDive(data_map, meta_struct.pAspectReferences);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewUsageCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewUsageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewUsageCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineTessellationDomainOriginStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.domainOrigin);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassMultiviewCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassMultiviewCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassMultiviewCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.subpassCount);
        FieldToDive(data_map, meta_struct.pViewMasks);
        FieldToDive(data_map, decoded_value.dependencyCount);
        FieldToDive(data_map, meta_struct.pViewOffsets);
        FieldToDive(data_map, decoded_value.correlationMaskCount);
        FieldToDive(data_map, meta_struct.pCorrelationMasks);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiviewFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.multiview);
        FieldToDive(data_map, decoded_value.multiviewGeometryShader);
        FieldToDive(data_map, decoded_value.multiviewTessellationShader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiviewProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxMultiviewViewCount);
        FieldToDive(data_map, decoded_value.maxMultiviewInstanceIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVariablePointersFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVariablePointersFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVariablePointersFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.variablePointersStorageBuffer);
        FieldToDive(data_map, decoded_value.variablePointers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProtectedMemoryFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProtectedMemoryFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.protectedMemory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceProtectedMemoryProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProtectedMemoryProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProtectedMemoryProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.protectedNoFault);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceQueueInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceQueueCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.queueFamilyIndex);
        FieldToDive(data_map, decoded_value.queueIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkProtectedSubmitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkProtectedSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkProtectedSubmitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.protectedSubmit);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerYcbcrConversionCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.ycbcrModel);
        FieldToDive(data_map, decoded_value.ycbcrRange);
        FieldToDive(data_map, meta_struct.components);
        FieldToDive(data_map, decoded_value.xChromaOffset);
        FieldToDive(data_map, decoded_value.yChromaOffset);
        FieldToDive(data_map, decoded_value.chromaFilter);
        FieldToDive(data_map, decoded_value.forceExplicitReconstruction);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerYcbcrConversionInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.conversion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindImagePlaneMemoryInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindImagePlaneMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindImagePlaneMemoryInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.planeAspect);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImagePlaneMemoryRequirementsInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkImagePlaneMemoryRequirementsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImagePlaneMemoryRequirementsInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.planeAspect);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSamplerYcbcrConversionFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.samplerYcbcrConversion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerYcbcrConversionImageFormatProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionImageFormatProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.combinedImageSamplerDescriptorCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorUpdateTemplateEntry* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorUpdateTemplateEntry& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorUpdateTemplateEntry& meta_struct = *data;

        FieldToDive(data_map, decoded_value.dstBinding);
        FieldToDive(data_map, decoded_value.dstArrayElement);
        FieldToDive(data_map, decoded_value.descriptorCount);
        FieldToDive(data_map, decoded_value.descriptorType);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.stride);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorUpdateTemplateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorUpdateTemplateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorUpdateTemplateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDescriptorUpdateTemplateCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.descriptorUpdateEntryCount);
        FieldToDive(data_map, meta_struct.pDescriptorUpdateEntries);
        FieldToDive(data_map, decoded_value.templateType);
        HandleToDive(data_map, meta_struct.descriptorSetLayout);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        HandleToDive(data_map, meta_struct.pipelineLayout);
        FieldToDive(data_map, decoded_value.set);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalMemoryProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryProperties& meta_struct = *data;

        FieldToDive(VkExternalMemoryFeatureFlags_t(),data_map, decoded_value.externalMemoryFeatures);
        FieldToDive(VkExternalMemoryHandleTypeFlags_t(),data_map, decoded_value.exportFromImportedHandleTypes);
        FieldToDive(VkExternalMemoryHandleTypeFlags_t(),data_map, decoded_value.compatibleHandleTypes);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalImageFormatInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalImageFormatInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalImageFormatInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalImageFormatProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalImageFormatProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.externalMemoryProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalBufferInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalBufferInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalBufferInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkBufferCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(VkBufferUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalBufferProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalBufferProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalBufferProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.externalMemoryProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceIDProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceIDProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceIDProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.deviceUUID), decoded_value.deviceUUID));
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.driverUUID), decoded_value.driverUUID));
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.deviceLUID), decoded_value.deviceLUID));
        FieldToDive(data_map, decoded_value.deviceNodeMask);
        FieldToDive(data_map, decoded_value.deviceLUIDValid);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalMemoryImageCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryImageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryImageCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalMemoryHandleTypeFlags_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalMemoryBufferCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryBufferCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryBufferCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalMemoryHandleTypeFlags_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportMemoryAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalMemoryHandleTypeFlags_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalFenceInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalFenceInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalFenceInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalFenceProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalFenceProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalFenceProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalFenceHandleTypeFlags_t(),data_map, decoded_value.exportFromImportedHandleTypes);
        FieldToDive(VkExternalFenceHandleTypeFlags_t(),data_map, decoded_value.compatibleHandleTypes);
        FieldToDive(VkExternalFenceFeatureFlags_t(),data_map, decoded_value.externalFenceFeatures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportFenceCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkExportFenceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExportFenceCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalFenceHandleTypeFlags_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportSemaphoreCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkExportSemaphoreCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExportSemaphoreCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalSemaphoreHandleTypeFlags_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalSemaphoreInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalSemaphoreInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalSemaphoreProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalSemaphoreProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalSemaphoreProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalSemaphoreHandleTypeFlags_t(),data_map, decoded_value.exportFromImportedHandleTypes);
        FieldToDive(VkExternalSemaphoreHandleTypeFlags_t(),data_map, decoded_value.compatibleHandleTypes);
        FieldToDive(VkExternalSemaphoreFeatureFlags_t(),data_map, decoded_value.externalSemaphoreFeatures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance3Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance3Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance3Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxPerSetDescriptors);
        FieldToDive(data_map, decoded_value.maxMemoryAllocationSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetLayoutSupport* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutSupport& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutSupport& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.supported);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderDrawParametersFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderDrawParameters);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan11Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan11Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan11Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.storageBuffer16BitAccess);
        FieldToDive(data_map, decoded_value.uniformAndStorageBuffer16BitAccess);
        FieldToDive(data_map, decoded_value.storagePushConstant16);
        FieldToDive(data_map, decoded_value.storageInputOutput16);
        FieldToDive(data_map, decoded_value.multiview);
        FieldToDive(data_map, decoded_value.multiviewGeometryShader);
        FieldToDive(data_map, decoded_value.multiviewTessellationShader);
        FieldToDive(data_map, decoded_value.variablePointersStorageBuffer);
        FieldToDive(data_map, decoded_value.variablePointers);
        FieldToDive(data_map, decoded_value.protectedMemory);
        FieldToDive(data_map, decoded_value.samplerYcbcrConversion);
        FieldToDive(data_map, decoded_value.shaderDrawParameters);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan11Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan11Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan11Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.deviceUUID), decoded_value.deviceUUID));
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.driverUUID), decoded_value.driverUUID));
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.deviceLUID), decoded_value.deviceLUID));
        FieldToDive(data_map, decoded_value.deviceNodeMask);
        FieldToDive(data_map, decoded_value.deviceLUIDValid);
        FieldToDive(data_map, decoded_value.subgroupSize);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.subgroupSupportedStages);
        FieldToDive(VkSubgroupFeatureFlags_t(),data_map, decoded_value.subgroupSupportedOperations);
        FieldToDive(data_map, decoded_value.subgroupQuadOperationsInAllStages);
        FieldToDive(data_map, decoded_value.pointClippingBehavior);
        FieldToDive(data_map, decoded_value.maxMultiviewViewCount);
        FieldToDive(data_map, decoded_value.maxMultiviewInstanceIndex);
        FieldToDive(data_map, decoded_value.protectedNoFault);
        FieldToDive(data_map, decoded_value.maxPerSetDescriptors);
        FieldToDive(data_map, decoded_value.maxMemoryAllocationSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan12Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan12Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan12Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.samplerMirrorClampToEdge);
        FieldToDive(data_map, decoded_value.drawIndirectCount);
        FieldToDive(data_map, decoded_value.storageBuffer8BitAccess);
        FieldToDive(data_map, decoded_value.uniformAndStorageBuffer8BitAccess);
        FieldToDive(data_map, decoded_value.storagePushConstant8);
        FieldToDive(data_map, decoded_value.shaderBufferInt64Atomics);
        FieldToDive(data_map, decoded_value.shaderSharedInt64Atomics);
        FieldToDive(data_map, decoded_value.shaderFloat16);
        FieldToDive(data_map, decoded_value.shaderInt8);
        FieldToDive(data_map, decoded_value.descriptorIndexing);
        FieldToDive(data_map, decoded_value.shaderInputAttachmentArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderUniformTexelBufferArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageTexelBufferArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderUniformBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderSampledImageArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageImageArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderInputAttachmentArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderUniformTexelBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageTexelBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.descriptorBindingUniformBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingSampledImageUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingStorageImageUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingStorageBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingUniformTexelBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingStorageTexelBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingUpdateUnusedWhilePending);
        FieldToDive(data_map, decoded_value.descriptorBindingPartiallyBound);
        FieldToDive(data_map, decoded_value.descriptorBindingVariableDescriptorCount);
        FieldToDive(data_map, decoded_value.runtimeDescriptorArray);
        FieldToDive(data_map, decoded_value.samplerFilterMinmax);
        FieldToDive(data_map, decoded_value.scalarBlockLayout);
        FieldToDive(data_map, decoded_value.imagelessFramebuffer);
        FieldToDive(data_map, decoded_value.uniformBufferStandardLayout);
        FieldToDive(data_map, decoded_value.shaderSubgroupExtendedTypes);
        FieldToDive(data_map, decoded_value.separateDepthStencilLayouts);
        FieldToDive(data_map, decoded_value.hostQueryReset);
        FieldToDive(data_map, decoded_value.timelineSemaphore);
        FieldToDive(data_map, decoded_value.bufferDeviceAddress);
        FieldToDive(data_map, decoded_value.bufferDeviceAddressCaptureReplay);
        FieldToDive(data_map, decoded_value.bufferDeviceAddressMultiDevice);
        FieldToDive(data_map, decoded_value.vulkanMemoryModel);
        FieldToDive(data_map, decoded_value.vulkanMemoryModelDeviceScope);
        FieldToDive(data_map, decoded_value.vulkanMemoryModelAvailabilityVisibilityChains);
        FieldToDive(data_map, decoded_value.shaderOutputViewportIndex);
        FieldToDive(data_map, decoded_value.shaderOutputLayer);
        FieldToDive(data_map, decoded_value.subgroupBroadcastDynamicId);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkConformanceVersion* data)
{
    if (data && data->decoded_value)
    {
        const VkConformanceVersion& decoded_value = *data->decoded_value;
        const Decoded_VkConformanceVersion& meta_struct = *data;

        FieldToDive(data_map, decoded_value.major);
        FieldToDive(data_map, decoded_value.minor);
        FieldToDive(data_map, decoded_value.subminor);
        FieldToDive(data_map, decoded_value.patch);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan12Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan12Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan12Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.driverID);
        FieldToDive(data_map, &meta_struct.driverName);
        FieldToDive(data_map, &meta_struct.driverInfo);
        FieldToDive(data_map, meta_struct.conformanceVersion);
        FieldToDive(data_map, decoded_value.denormBehaviorIndependence);
        FieldToDive(data_map, decoded_value.roundingModeIndependence);
        FieldToDive(data_map, decoded_value.shaderSignedZeroInfNanPreserveFloat16);
        FieldToDive(data_map, decoded_value.shaderSignedZeroInfNanPreserveFloat32);
        FieldToDive(data_map, decoded_value.shaderSignedZeroInfNanPreserveFloat64);
        FieldToDive(data_map, decoded_value.shaderDenormPreserveFloat16);
        FieldToDive(data_map, decoded_value.shaderDenormPreserveFloat32);
        FieldToDive(data_map, decoded_value.shaderDenormPreserveFloat64);
        FieldToDive(data_map, decoded_value.shaderDenormFlushToZeroFloat16);
        FieldToDive(data_map, decoded_value.shaderDenormFlushToZeroFloat32);
        FieldToDive(data_map, decoded_value.shaderDenormFlushToZeroFloat64);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTEFloat16);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTEFloat32);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTEFloat64);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTZFloat16);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTZFloat32);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTZFloat64);
        FieldToDive(data_map, decoded_value.maxUpdateAfterBindDescriptorsInAllPools);
        FieldToDive(data_map, decoded_value.shaderUniformBufferArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderSampledImageArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderStorageBufferArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderStorageImageArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderInputAttachmentArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.robustBufferAccessUpdateAfterBind);
        FieldToDive(data_map, decoded_value.quadDivergentImplicitLod);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindSamplers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindUniformBuffers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindStorageBuffers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindSampledImages);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindStorageImages);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindInputAttachments);
        FieldToDive(data_map, decoded_value.maxPerStageUpdateAfterBindResources);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindSamplers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindSampledImages);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindStorageImages);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindInputAttachments);
        FieldToDive(VkResolveModeFlags_t(),data_map, decoded_value.supportedDepthResolveModes);
        FieldToDive(VkResolveModeFlags_t(),data_map, decoded_value.supportedStencilResolveModes);
        FieldToDive(data_map, decoded_value.independentResolveNone);
        FieldToDive(data_map, decoded_value.independentResolve);
        FieldToDive(data_map, decoded_value.filterMinmaxSingleComponentFormats);
        FieldToDive(data_map, decoded_value.filterMinmaxImageComponentMapping);
        FieldToDive(data_map, decoded_value.maxTimelineSemaphoreValueDifference);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.framebufferIntegerColorSampleCounts);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageFormatListCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkImageFormatListCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageFormatListCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.viewFormatCount);
        FieldToDive(data_map, meta_struct.pViewFormats);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentDescription2* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentDescription2& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentDescription2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAttachmentDescriptionFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.samples);
        FieldToDive(data_map, decoded_value.loadOp);
        FieldToDive(data_map, decoded_value.storeOp);
        FieldToDive(data_map, decoded_value.stencilLoadOp);
        FieldToDive(data_map, decoded_value.stencilStoreOp);
        FieldToDive(data_map, decoded_value.initialLayout);
        FieldToDive(data_map, decoded_value.finalLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentReference2* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentReference2& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentReference2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachment);
        FieldToDive(data_map, decoded_value.layout);
        FieldToDive(VkImageAspectFlags_t(),data_map, decoded_value.aspectMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassDescription2* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDescription2& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDescription2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSubpassDescriptionFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        FieldToDive(data_map, decoded_value.viewMask);
        FieldToDive(data_map, decoded_value.inputAttachmentCount);
        FieldToDive(data_map, meta_struct.pInputAttachments);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachments);
        FieldToDive(data_map, meta_struct.pResolveAttachments);
        FieldToDive(data_map, meta_struct.pDepthStencilAttachment);
        FieldToDive(data_map, decoded_value.preserveAttachmentCount);
        FieldToDive(data_map, meta_struct.pPreserveAttachments);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassDependency2* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDependency2& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDependency2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.srcSubpass);
        FieldToDive(data_map, decoded_value.dstSubpass);
        FieldToDive(VkPipelineStageFlags_t(),data_map, decoded_value.srcStageMask);
        FieldToDive(VkPipelineStageFlags_t(),data_map, decoded_value.dstStageMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkAccessFlags_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(VkDependencyFlags_t(),data_map, decoded_value.dependencyFlags);
        FieldToDive(data_map, decoded_value.viewOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassCreateInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreateInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreateInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkRenderPassCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.attachmentCount);
        FieldToDive(data_map, meta_struct.pAttachments);
        FieldToDive(data_map, decoded_value.subpassCount);
        FieldToDive(data_map, meta_struct.pSubpasses);
        FieldToDive(data_map, decoded_value.dependencyCount);
        FieldToDive(data_map, meta_struct.pDependencies);
        FieldToDive(data_map, decoded_value.correlatedViewMaskCount);
        FieldToDive(data_map, meta_struct.pCorrelatedViewMasks);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassBeginInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassBeginInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.contents);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassEndInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassEndInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassEndInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevice8BitStorageFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevice8BitStorageFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevice8BitStorageFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.storageBuffer8BitAccess);
        FieldToDive(data_map, decoded_value.uniformAndStorageBuffer8BitAccess);
        FieldToDive(data_map, decoded_value.storagePushConstant8);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDriverProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDriverProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDriverProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.driverID);
        FieldToDive(data_map, &meta_struct.driverName);
        FieldToDive(data_map, &meta_struct.driverInfo);
        FieldToDive(data_map, meta_struct.conformanceVersion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderAtomicInt64Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicInt64Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicInt64Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderBufferInt64Atomics);
        FieldToDive(data_map, decoded_value.shaderSharedInt64Atomics);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderFloat16Int8Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderFloat16Int8Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderFloat16Int8Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderFloat16);
        FieldToDive(data_map, decoded_value.shaderInt8);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFloatControlsProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFloatControlsProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFloatControlsProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.denormBehaviorIndependence);
        FieldToDive(data_map, decoded_value.roundingModeIndependence);
        FieldToDive(data_map, decoded_value.shaderSignedZeroInfNanPreserveFloat16);
        FieldToDive(data_map, decoded_value.shaderSignedZeroInfNanPreserveFloat32);
        FieldToDive(data_map, decoded_value.shaderSignedZeroInfNanPreserveFloat64);
        FieldToDive(data_map, decoded_value.shaderDenormPreserveFloat16);
        FieldToDive(data_map, decoded_value.shaderDenormPreserveFloat32);
        FieldToDive(data_map, decoded_value.shaderDenormPreserveFloat64);
        FieldToDive(data_map, decoded_value.shaderDenormFlushToZeroFloat16);
        FieldToDive(data_map, decoded_value.shaderDenormFlushToZeroFloat32);
        FieldToDive(data_map, decoded_value.shaderDenormFlushToZeroFloat64);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTEFloat16);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTEFloat32);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTEFloat64);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTZFloat16);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTZFloat32);
        FieldToDive(data_map, decoded_value.shaderRoundingModeRTZFloat64);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutBindingFlagsCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.bindingCount);
        FieldToDive(data_map, meta_struct.pBindingFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorIndexingFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderInputAttachmentArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderUniformTexelBufferArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageTexelBufferArrayDynamicIndexing);
        FieldToDive(data_map, decoded_value.shaderUniformBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderSampledImageArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageImageArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderInputAttachmentArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderUniformTexelBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.shaderStorageTexelBufferArrayNonUniformIndexing);
        FieldToDive(data_map, decoded_value.descriptorBindingUniformBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingSampledImageUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingStorageImageUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingStorageBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingUniformTexelBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingStorageTexelBufferUpdateAfterBind);
        FieldToDive(data_map, decoded_value.descriptorBindingUpdateUnusedWhilePending);
        FieldToDive(data_map, decoded_value.descriptorBindingPartiallyBound);
        FieldToDive(data_map, decoded_value.descriptorBindingVariableDescriptorCount);
        FieldToDive(data_map, decoded_value.runtimeDescriptorArray);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDescriptorIndexingProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorIndexingProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorIndexingProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxUpdateAfterBindDescriptorsInAllPools);
        FieldToDive(data_map, decoded_value.shaderUniformBufferArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderSampledImageArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderStorageBufferArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderStorageImageArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.shaderInputAttachmentArrayNonUniformIndexingNative);
        FieldToDive(data_map, decoded_value.robustBufferAccessUpdateAfterBind);
        FieldToDive(data_map, decoded_value.quadDivergentImplicitLod);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindSamplers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindUniformBuffers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindStorageBuffers);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindSampledImages);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindStorageImages);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindInputAttachments);
        FieldToDive(data_map, decoded_value.maxPerStageUpdateAfterBindResources);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindSamplers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindSampledImages);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindStorageImages);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindInputAttachments);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetVariableDescriptorCountAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.descriptorSetCount);
        FieldToDive(data_map, meta_struct.pDescriptorCounts);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetVariableDescriptorCountLayoutSupport& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxVariableDescriptorCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassDescriptionDepthStencilResolve* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDescriptionDepthStencilResolve& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDescriptionDepthStencilResolve& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthResolveMode);
        FieldToDive(data_map, decoded_value.stencilResolveMode);
        FieldToDive(data_map, meta_struct.pDepthStencilResolveAttachment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDepthStencilResolveProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthStencilResolveProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthStencilResolveProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkResolveModeFlags_t(),data_map, decoded_value.supportedDepthResolveModes);
        FieldToDive(VkResolveModeFlags_t(),data_map, decoded_value.supportedStencilResolveModes);
        FieldToDive(data_map, decoded_value.independentResolveNone);
        FieldToDive(data_map, decoded_value.independentResolve);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceScalarBlockLayoutFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.scalarBlockLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageStencilUsageCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkImageStencilUsageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageStencilUsageCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.stencilUsage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerReductionModeCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerReductionModeCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerReductionModeCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.reductionMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSamplerFilterMinmaxProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.filterMinmaxSingleComponentFormats);
        FieldToDive(data_map, decoded_value.filterMinmaxImageComponentMapping);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkanMemoryModelFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vulkanMemoryModel);
        FieldToDive(data_map, decoded_value.vulkanMemoryModelDeviceScope);
        FieldToDive(data_map, decoded_value.vulkanMemoryModelAvailabilityVisibilityChains);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImagelessFramebufferFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imagelessFramebuffer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFramebufferAttachmentImageInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferAttachmentImageInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferAttachmentImageInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.layerCount);
        FieldToDive(data_map, decoded_value.viewFormatCount);
        FieldToDive(data_map, meta_struct.pViewFormats);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFramebufferAttachmentsCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferAttachmentsCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferAttachmentsCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachmentImageInfoCount);
        FieldToDive(data_map, meta_struct.pAttachmentImageInfos);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassAttachmentBeginInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassAttachmentBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassAttachmentBeginInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachmentCount);
        HandleToDive(data_map, &meta_struct.pAttachments);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceUniformBufferStandardLayoutFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.uniformBufferStandardLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderSubgroupExtendedTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.separateDepthStencilLayouts);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentReferenceStencilLayout* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentReferenceStencilLayout& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentReferenceStencilLayout& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stencilLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentDescriptionStencilLayout* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentDescriptionStencilLayout& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentDescriptionStencilLayout& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stencilInitialLayout);
        FieldToDive(data_map, decoded_value.stencilFinalLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceHostQueryResetFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHostQueryResetFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHostQueryResetFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hostQueryReset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTimelineSemaphoreFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.timelineSemaphore);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTimelineSemaphoreProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxTimelineSemaphoreValueDifference);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreTypeCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreTypeCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreTypeCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.semaphoreType);
        FieldToDive(data_map, decoded_value.initialValue);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkTimelineSemaphoreSubmitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkTimelineSemaphoreSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkTimelineSemaphoreSubmitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.waitSemaphoreValueCount);
        FieldToDive(data_map, meta_struct.pWaitSemaphoreValues);
        FieldToDive(data_map, decoded_value.signalSemaphoreValueCount);
        FieldToDive(data_map, meta_struct.pSignalSemaphoreValues);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreWaitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreWaitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreWaitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSemaphoreWaitFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.semaphoreCount);
        HandleToDive(data_map, &meta_struct.pSemaphores);
        FieldToDive(data_map, meta_struct.pValues);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreSignalInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreSignalInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreSignalInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(data_map, decoded_value.value);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBufferDeviceAddressFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.bufferDeviceAddress);
        FieldToDive(data_map, decoded_value.bufferDeviceAddressCaptureReplay);
        FieldToDive(data_map, decoded_value.bufferDeviceAddressMultiDevice);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferDeviceAddressInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferDeviceAddressInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferDeviceAddressInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferOpaqueCaptureAddressCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferOpaqueCaptureAddressCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferOpaqueCaptureAddressCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.opaqueCaptureAddress);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryOpaqueCaptureAddressAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.opaqueCaptureAddress);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceMemoryOpaqueCaptureAddressInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan13Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan13Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan13Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.robustImageAccess);
        FieldToDive(data_map, decoded_value.inlineUniformBlock);
        FieldToDive(data_map, decoded_value.descriptorBindingInlineUniformBlockUpdateAfterBind);
        FieldToDive(data_map, decoded_value.pipelineCreationCacheControl);
        FieldToDive(data_map, decoded_value.privateData);
        FieldToDive(data_map, decoded_value.shaderDemoteToHelperInvocation);
        FieldToDive(data_map, decoded_value.shaderTerminateInvocation);
        FieldToDive(data_map, decoded_value.subgroupSizeControl);
        FieldToDive(data_map, decoded_value.computeFullSubgroups);
        FieldToDive(data_map, decoded_value.synchronization2);
        FieldToDive(data_map, decoded_value.textureCompressionASTC_HDR);
        FieldToDive(data_map, decoded_value.shaderZeroInitializeWorkgroupMemory);
        FieldToDive(data_map, decoded_value.dynamicRendering);
        FieldToDive(data_map, decoded_value.shaderIntegerDotProduct);
        FieldToDive(data_map, decoded_value.maintenance4);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan13Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan13Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan13Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minSubgroupSize);
        FieldToDive(data_map, decoded_value.maxSubgroupSize);
        FieldToDive(data_map, decoded_value.maxComputeWorkgroupSubgroups);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.requiredSubgroupSizeStages);
        FieldToDive(data_map, decoded_value.maxInlineUniformBlockSize);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxDescriptorSetInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxInlineUniformTotalSize);
        FieldToDive(data_map, decoded_value.integerDotProduct8BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct8BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct8BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct4x8BitPackedUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct4x8BitPackedSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct4x8BitPackedMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct16BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct16BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct16BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct32BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct32BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct32BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct64BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct64BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct64BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating8BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating16BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating32BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating64BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.storageTexelBufferOffsetAlignmentBytes);
        FieldToDive(data_map, decoded_value.storageTexelBufferOffsetSingleTexelAlignment);
        FieldToDive(data_map, decoded_value.uniformTexelBufferOffsetAlignmentBytes);
        FieldToDive(data_map, decoded_value.uniformTexelBufferOffsetSingleTexelAlignment);
        FieldToDive(data_map, decoded_value.maxBufferSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCreationFeedback* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreationFeedback& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreationFeedback& meta_struct = *data;

        FieldToDive(VkPipelineCreationFeedbackFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.duration);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCreationFeedbackCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreationFeedbackCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreationFeedbackCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pPipelineCreationFeedback);
        FieldToDive(data_map, decoded_value.pipelineStageCreationFeedbackCount);
        FieldToDive(data_map, meta_struct.pPipelineStageCreationFeedbacks);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderTerminateInvocationFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderTerminateInvocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceToolProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceToolProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceToolProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, &meta_struct.version);
        FieldToDive(VkToolPurposeFlags_t(),data_map, decoded_value.purposes);
        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, &meta_struct.layer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderDemoteToHelperInvocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePrivateDataFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePrivateDataFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePrivateDataFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.privateData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDevicePrivateDataCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDevicePrivateDataCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDevicePrivateDataCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.privateDataSlotRequestCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPrivateDataSlotCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPrivateDataSlotCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPrivateDataSlotCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPrivateDataSlotCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineCreationCacheControlFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineCreationCacheControl);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryBarrier2* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryBarrier2& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryBarrier2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.srcStageMask);
        FieldToDive(VkAccessFlags2_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.dstStageMask);
        FieldToDive(VkAccessFlags2_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferMemoryBarrier2* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferMemoryBarrier2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferMemoryBarrier2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.srcStageMask);
        FieldToDive(VkAccessFlags2_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.dstStageMask);
        FieldToDive(VkAccessFlags2_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(data_map, decoded_value.srcQueueFamilyIndex);
        FieldToDive(data_map, decoded_value.dstQueueFamilyIndex);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageMemoryBarrier2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageMemoryBarrier2& decoded_value = *data->decoded_value;
        const Decoded_VkImageMemoryBarrier2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.srcStageMask);
        FieldToDive(VkAccessFlags2_t(),data_map, decoded_value.srcAccessMask);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.dstStageMask);
        FieldToDive(VkAccessFlags2_t(),data_map, decoded_value.dstAccessMask);
        FieldToDive(data_map, decoded_value.oldLayout);
        FieldToDive(data_map, decoded_value.newLayout);
        FieldToDive(data_map, decoded_value.srcQueueFamilyIndex);
        FieldToDive(data_map, decoded_value.dstQueueFamilyIndex);
        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, meta_struct.subresourceRange);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDependencyInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDependencyInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDependencyInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDependencyFlags_t(),data_map, decoded_value.dependencyFlags);
        FieldToDive(data_map, decoded_value.memoryBarrierCount);
        FieldToDive(data_map, meta_struct.pMemoryBarriers);
        FieldToDive(data_map, decoded_value.bufferMemoryBarrierCount);
        FieldToDive(data_map, meta_struct.pBufferMemoryBarriers);
        FieldToDive(data_map, decoded_value.imageMemoryBarrierCount);
        FieldToDive(data_map, meta_struct.pImageMemoryBarriers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreSubmitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreSubmitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(data_map, decoded_value.value);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.stageMask);
        FieldToDive(data_map, decoded_value.deviceIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferSubmitInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferSubmitInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.commandBuffer);
        FieldToDive(data_map, decoded_value.deviceMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubmitInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkSubmitInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkSubmitInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSubmitFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.waitSemaphoreInfoCount);
        FieldToDive(data_map, meta_struct.pWaitSemaphoreInfos);
        FieldToDive(data_map, decoded_value.commandBufferInfoCount);
        FieldToDive(data_map, meta_struct.pCommandBufferInfos);
        FieldToDive(data_map, decoded_value.signalSemaphoreInfoCount);
        FieldToDive(data_map, meta_struct.pSignalSemaphoreInfos);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSynchronization2Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSynchronization2Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSynchronization2Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.synchronization2);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderZeroInitializeWorkgroupMemory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageRobustnessFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageRobustnessFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageRobustnessFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.robustImageAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferCopy2* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferCopy2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferCopy2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.srcOffset);
        FieldToDive(data_map, decoded_value.dstOffset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyBufferInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyBufferInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyBufferInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcBuffer);
        HandleToDive(data_map, meta_struct.dstBuffer);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageCopy2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageCopy2& decoded_value = *data->decoded_value;
        const Decoded_VkImageCopy2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.srcSubresource);
        FieldToDive(data_map, meta_struct.srcOffset);
        FieldToDive(data_map, meta_struct.dstSubresource);
        FieldToDive(data_map, meta_struct.dstOffset);
        FieldToDive(data_map, meta_struct.extent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyImageInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcImage);
        FieldToDive(data_map, decoded_value.srcImageLayout);
        HandleToDive(data_map, meta_struct.dstImage);
        FieldToDive(data_map, decoded_value.dstImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferImageCopy2* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferImageCopy2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferImageCopy2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.bufferOffset);
        FieldToDive(data_map, decoded_value.bufferRowLength);
        FieldToDive(data_map, decoded_value.bufferImageHeight);
        FieldToDive(data_map, meta_struct.imageSubresource);
        FieldToDive(data_map, meta_struct.imageOffset);
        FieldToDive(data_map, meta_struct.imageExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyBufferToImageInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyBufferToImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyBufferToImageInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcBuffer);
        HandleToDive(data_map, meta_struct.dstImage);
        FieldToDive(data_map, decoded_value.dstImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyImageToBufferInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageToBufferInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageToBufferInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcImage);
        FieldToDive(data_map, decoded_value.srcImageLayout);
        HandleToDive(data_map, meta_struct.dstBuffer);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageBlit2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageBlit2& decoded_value = *data->decoded_value;
        const Decoded_VkImageBlit2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.srcSubresource);
        FieldToDive(data_map, meta_struct.srcOffsets);
        FieldToDive(data_map, meta_struct.dstSubresource);
        FieldToDive(data_map, meta_struct.dstOffsets);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBlitImageInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkBlitImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkBlitImageInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcImage);
        FieldToDive(data_map, decoded_value.srcImageLayout);
        HandleToDive(data_map, meta_struct.dstImage);
        FieldToDive(data_map, decoded_value.dstImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, decoded_value.filter);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageResolve2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageResolve2& decoded_value = *data->decoded_value;
        const Decoded_VkImageResolve2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.srcSubresource);
        FieldToDive(data_map, meta_struct.srcOffset);
        FieldToDive(data_map, meta_struct.dstSubresource);
        FieldToDive(data_map, meta_struct.dstOffset);
        FieldToDive(data_map, meta_struct.extent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkResolveImageInfo2* data)
{
    if (data && data->decoded_value)
    {
        const VkResolveImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkResolveImageInfo2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.srcImage);
        FieldToDive(data_map, decoded_value.srcImageLayout);
        HandleToDive(data_map, meta_struct.dstImage);
        FieldToDive(data_map, decoded_value.dstImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubgroupSizeControlFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.subgroupSizeControl);
        FieldToDive(data_map, decoded_value.computeFullSubgroups);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubgroupSizeControlProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minSubgroupSize);
        FieldToDive(data_map, decoded_value.maxSubgroupSize);
        FieldToDive(data_map, decoded_value.maxComputeWorkgroupSubgroups);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.requiredSubgroupSizeStages);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.requiredSubgroupSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInlineUniformBlockFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.inlineUniformBlock);
        FieldToDive(data_map, decoded_value.descriptorBindingInlineUniformBlockUpdateAfterBind);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceInlineUniformBlockProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInlineUniformBlockProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInlineUniformBlockProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxInlineUniformBlockSize);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxDescriptorSetInlineUniformBlocks);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindInlineUniformBlocks);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWriteDescriptorSetInlineUniformBlock* data)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetInlineUniformBlock& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetInlineUniformBlock& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dataSize);
        FieldToDive(data_map, meta_struct.pData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorPoolInlineUniformBlockCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxInlineUniformBlockBindings);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTextureCompressionASTCHDRFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.textureCompressionASTC_HDR);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingAttachmentInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingAttachmentInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingAttachmentInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.imageView);
        FieldToDive(data_map, decoded_value.imageLayout);
        FieldToDive(data_map, decoded_value.resolveMode);
        HandleToDive(data_map, meta_struct.resolveImageView);
        FieldToDive(data_map, decoded_value.resolveImageLayout);
        FieldToDive(data_map, decoded_value.loadOp);
        FieldToDive(data_map, decoded_value.storeOp);
        FieldToDive(data_map, meta_struct.clearValue);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkRenderingFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.renderArea);
        FieldToDive(data_map, decoded_value.layerCount);
        FieldToDive(data_map, decoded_value.viewMask);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachments);
        FieldToDive(data_map, meta_struct.pDepthAttachment);
        FieldToDive(data_map, meta_struct.pStencilAttachment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRenderingCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRenderingCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRenderingCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.viewMask);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachmentFormats);
        FieldToDive(data_map, decoded_value.depthAttachmentFormat);
        FieldToDive(data_map, decoded_value.stencilAttachmentFormat);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDynamicRenderingFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDynamicRenderingFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDynamicRenderingFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dynamicRendering);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferInheritanceRenderingInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceRenderingInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceRenderingInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkRenderingFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.viewMask);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachmentFormats);
        FieldToDive(data_map, decoded_value.depthAttachmentFormat);
        FieldToDive(data_map, decoded_value.stencilAttachmentFormat);
        FieldToDive(data_map, decoded_value.rasterizationSamples);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderIntegerDotProductFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderIntegerDotProduct);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderIntegerDotProductProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.integerDotProduct8BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct8BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct8BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct4x8BitPackedUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct4x8BitPackedSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct4x8BitPackedMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct16BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct16BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct16BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct32BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct32BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct32BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct64BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct64BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProduct64BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating8BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating16BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating32BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating64BitSignedAccelerated);
        FieldToDive(data_map, decoded_value.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTexelBufferAlignmentProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.storageTexelBufferOffsetAlignmentBytes);
        FieldToDive(data_map, decoded_value.storageTexelBufferOffsetSingleTexelAlignment);
        FieldToDive(data_map, decoded_value.uniformTexelBufferOffsetAlignmentBytes);
        FieldToDive(data_map, decoded_value.uniformTexelBufferOffsetSingleTexelAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFormatProperties3* data)
{
    if (data && data->decoded_value)
    {
        const VkFormatProperties3& decoded_value = *data->decoded_value;
        const Decoded_VkFormatProperties3& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkFormatFeatureFlags2_t(),data_map, decoded_value.linearTilingFeatures);
        FieldToDive(VkFormatFeatureFlags2_t(),data_map, decoded_value.optimalTilingFeatures);
        FieldToDive(VkFormatFeatureFlags2_t(),data_map, decoded_value.bufferFeatures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance4Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance4Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance4Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maintenance4);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance4Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance4Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance4Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxBufferSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceBufferMemoryRequirements* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceBufferMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceBufferMemoryRequirements& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pCreateInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceImageMemoryRequirements* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceImageMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceImageMemoryRequirements& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pCreateInfo);
        FieldToDive(data_map, decoded_value.planeAspect);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan14Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan14Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan14Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.globalPriorityQuery);
        FieldToDive(data_map, decoded_value.shaderSubgroupRotate);
        FieldToDive(data_map, decoded_value.shaderSubgroupRotateClustered);
        FieldToDive(data_map, decoded_value.shaderFloatControls2);
        FieldToDive(data_map, decoded_value.shaderExpectAssume);
        FieldToDive(data_map, decoded_value.rectangularLines);
        FieldToDive(data_map, decoded_value.bresenhamLines);
        FieldToDive(data_map, decoded_value.smoothLines);
        FieldToDive(data_map, decoded_value.stippledRectangularLines);
        FieldToDive(data_map, decoded_value.stippledBresenhamLines);
        FieldToDive(data_map, decoded_value.stippledSmoothLines);
        FieldToDive(data_map, decoded_value.vertexAttributeInstanceRateDivisor);
        FieldToDive(data_map, decoded_value.vertexAttributeInstanceRateZeroDivisor);
        FieldToDive(data_map, decoded_value.indexTypeUint8);
        FieldToDive(data_map, decoded_value.dynamicRenderingLocalRead);
        FieldToDive(data_map, decoded_value.maintenance5);
        FieldToDive(data_map, decoded_value.maintenance6);
        FieldToDive(data_map, decoded_value.pipelineProtectedAccess);
        FieldToDive(data_map, decoded_value.pipelineRobustness);
        FieldToDive(data_map, decoded_value.hostImageCopy);
        FieldToDive(data_map, decoded_value.pushDescriptor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVulkan14Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan14Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan14Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.lineSubPixelPrecisionBits);
        FieldToDive(data_map, decoded_value.maxVertexAttribDivisor);
        FieldToDive(data_map, decoded_value.supportsNonZeroFirstInstance);
        FieldToDive(data_map, decoded_value.maxPushDescriptors);
        FieldToDive(data_map, decoded_value.dynamicRenderingLocalReadDepthStencilAttachments);
        FieldToDive(data_map, decoded_value.dynamicRenderingLocalReadMultisampledAttachments);
        FieldToDive(data_map, decoded_value.earlyFragmentMultisampleCoverageAfterSampleCounting);
        FieldToDive(data_map, decoded_value.earlyFragmentSampleMaskTestBeforeSampleCounting);
        FieldToDive(data_map, decoded_value.depthStencilSwizzleOneSupport);
        FieldToDive(data_map, decoded_value.polygonModePointSize);
        FieldToDive(data_map, decoded_value.nonStrictSinglePixelWideLinesUseParallelogram);
        FieldToDive(data_map, decoded_value.nonStrictWideLinesUseParallelogram);
        FieldToDive(data_map, decoded_value.blockTexelViewCompatibleMultipleLayers);
        FieldToDive(data_map, decoded_value.maxCombinedImageSamplerDescriptorCount);
        FieldToDive(data_map, decoded_value.fragmentShadingRateClampCombinerInputs);
        FieldToDive(data_map, decoded_value.defaultRobustnessStorageBuffers);
        FieldToDive(data_map, decoded_value.defaultRobustnessUniformBuffers);
        FieldToDive(data_map, decoded_value.defaultRobustnessVertexInputs);
        FieldToDive(data_map, decoded_value.defaultRobustnessImages);
        FieldToDive(data_map, decoded_value.copySrcLayoutCount);
        FieldToDive(data_map, meta_struct.pCopySrcLayouts);
        FieldToDive(data_map, decoded_value.copyDstLayoutCount);
        FieldToDive(data_map, meta_struct.pCopyDstLayouts);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.optimalTilingLayoutUUID), decoded_value.optimalTilingLayoutUUID));
        FieldToDive(data_map, decoded_value.identicalMemoryTypeRequirements);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceQueueGlobalPriorityCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueGlobalPriorityCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueGlobalPriorityCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.globalPriority);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGlobalPriorityQueryFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.globalPriorityQuery);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyGlobalPriorityProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyGlobalPriorityProperties& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyGlobalPriorityProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.priorityCount);
        FieldToDive(data_map, &meta_struct.priorities);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSubgroupRotateFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderSubgroupRotate);
        FieldToDive(data_map, decoded_value.shaderSubgroupRotateClustered);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderFloatControls2Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderFloatControls2Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderFloatControls2Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderFloatControls2);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderExpectAssumeFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderExpectAssume);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLineRasterizationFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLineRasterizationFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLineRasterizationFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rectangularLines);
        FieldToDive(data_map, decoded_value.bresenhamLines);
        FieldToDive(data_map, decoded_value.smoothLines);
        FieldToDive(data_map, decoded_value.stippledRectangularLines);
        FieldToDive(data_map, decoded_value.stippledBresenhamLines);
        FieldToDive(data_map, decoded_value.stippledSmoothLines);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLineRasterizationProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLineRasterizationProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLineRasterizationProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.lineSubPixelPrecisionBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationLineStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationLineStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationLineStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.lineRasterizationMode);
        FieldToDive(data_map, decoded_value.stippledLineEnable);
        FieldToDive(data_map, decoded_value.lineStippleFactor);
        FieldToDive(data_map, decoded_value.lineStipplePattern);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeDivisorProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxVertexAttribDivisor);
        FieldToDive(data_map, decoded_value.supportsNonZeroFirstInstance);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVertexInputBindingDivisorDescription* data)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputBindingDivisorDescription& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputBindingDivisorDescription& meta_struct = *data;

        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, decoded_value.divisor);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineVertexInputDivisorStateCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineVertexInputDivisorStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineVertexInputDivisorStateCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexBindingDivisorCount);
        FieldToDive(data_map, meta_struct.pVertexBindingDivisors);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeDivisorFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexAttributeInstanceRateDivisor);
        FieldToDive(data_map, decoded_value.vertexAttributeInstanceRateZeroDivisor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceIndexTypeUint8Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceIndexTypeUint8Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceIndexTypeUint8Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.indexTypeUint8);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryMapInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryMapInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryMapInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkMemoryMapFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryUnmapInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryUnmapInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryUnmapInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkMemoryUnmapFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance5Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance5Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance5Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maintenance5);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance5Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance5Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance5Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.earlyFragmentMultisampleCoverageAfterSampleCounting);
        FieldToDive(data_map, decoded_value.earlyFragmentSampleMaskTestBeforeSampleCounting);
        FieldToDive(data_map, decoded_value.depthStencilSwizzleOneSupport);
        FieldToDive(data_map, decoded_value.polygonModePointSize);
        FieldToDive(data_map, decoded_value.nonStrictSinglePixelWideLinesUseParallelogram);
        FieldToDive(data_map, decoded_value.nonStrictWideLinesUseParallelogram);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingAreaInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingAreaInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingAreaInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.viewMask);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachmentFormats);
        FieldToDive(data_map, decoded_value.depthAttachmentFormat);
        FieldToDive(data_map, decoded_value.stencilAttachmentFormat);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageSubresource2* data)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresource2& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresource2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.imageSubresource);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceImageSubresourceInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceImageSubresourceInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceImageSubresourceInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pCreateInfo);
        FieldToDive(data_map, meta_struct.pSubresource);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubresourceLayout2* data)
{
    if (data && data->decoded_value)
    {
        const VkSubresourceLayout2& decoded_value = *data->decoded_value;
        const Decoded_VkSubresourceLayout2& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.subresourceLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCreateFlags2CreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreateFlags2CreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreateFlags2CreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCreateFlags2_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferUsageFlags2CreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferUsageFlags2CreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferUsageFlags2CreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkBufferUsageFlags2_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePushDescriptorProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePushDescriptorProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePushDescriptorProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxPushDescriptors);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDynamicRenderingLocalReadFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dynamicRenderingLocalRead);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingAttachmentLocationInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingAttachmentLocationInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingAttachmentLocationInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachmentLocations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingInputAttachmentIndexInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingInputAttachmentIndexInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingInputAttachmentIndexInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachmentInputIndices);
        FieldToDive(data_map, meta_struct.pDepthInputAttachmentIndex);
        FieldToDive(data_map, meta_struct.pStencilInputAttachmentIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance6Features* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance6Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance6Features& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maintenance6);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance6Properties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance6Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance6Properties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.blockTexelViewCompatibleMultipleLayers);
        FieldToDive(data_map, decoded_value.maxCombinedImageSamplerDescriptorCount);
        FieldToDive(data_map, decoded_value.fragmentShadingRateClampCombinerInputs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindMemoryStatus* data)
{
    if (data && data->decoded_value)
    {
        const VkBindMemoryStatus& decoded_value = *data->decoded_value;
        const Decoded_VkBindMemoryStatus& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pResult);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindDescriptorSetsInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkBindDescriptorSetsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindDescriptorSetsInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        HandleToDive(data_map, meta_struct.layout);
        FieldToDive(data_map, decoded_value.firstSet);
        FieldToDive(data_map, decoded_value.descriptorSetCount);
        HandleToDive(data_map, &meta_struct.pDescriptorSets);
        FieldToDive(data_map, decoded_value.dynamicOffsetCount);
        FieldToDive(data_map, meta_struct.pDynamicOffsets);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPushConstantsInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPushConstantsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPushConstantsInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.layout);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pValues);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPushDescriptorSetInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPushDescriptorSetInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPushDescriptorSetInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        HandleToDive(data_map, meta_struct.layout);
        FieldToDive(data_map, decoded_value.set);
        FieldToDive(data_map, decoded_value.descriptorWriteCount);
        FieldToDive(data_map, meta_struct.pDescriptorWrites);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineProtectedAccessFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineProtectedAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineRobustnessFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineRobustnessFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineRobustnessFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineRobustness);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineRobustnessProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineRobustnessProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineRobustnessProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.defaultRobustnessStorageBuffers);
        FieldToDive(data_map, decoded_value.defaultRobustnessUniformBuffers);
        FieldToDive(data_map, decoded_value.defaultRobustnessVertexInputs);
        FieldToDive(data_map, decoded_value.defaultRobustnessImages);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRobustnessCreateInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRobustnessCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRobustnessCreateInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.storageBuffers);
        FieldToDive(data_map, decoded_value.uniformBuffers);
        FieldToDive(data_map, decoded_value.vertexInputs);
        FieldToDive(data_map, decoded_value.images);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceHostImageCopyFeatures* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHostImageCopyFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHostImageCopyFeatures& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hostImageCopy);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceHostImageCopyProperties* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHostImageCopyProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHostImageCopyProperties& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.copySrcLayoutCount);
        FieldToDive(data_map, meta_struct.pCopySrcLayouts);
        FieldToDive(data_map, decoded_value.copyDstLayoutCount);
        FieldToDive(data_map, meta_struct.pCopyDstLayouts);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.optimalTilingLayoutUUID), decoded_value.optimalTilingLayoutUUID));
        FieldToDive(data_map, decoded_value.identicalMemoryTypeRequirements);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryToImageCopy* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryToImageCopy& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryToImageCopy& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pHostPointer);
        FieldToDive(data_map, decoded_value.memoryRowLength);
        FieldToDive(data_map, decoded_value.memoryImageHeight);
        FieldToDive(data_map, meta_struct.imageSubresource);
        FieldToDive(data_map, meta_struct.imageOffset);
        FieldToDive(data_map, meta_struct.imageExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageToMemoryCopy* data)
{
    if (data && data->decoded_value)
    {
        const VkImageToMemoryCopy& decoded_value = *data->decoded_value;
        const Decoded_VkImageToMemoryCopy& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pHostPointer);
        FieldToDive(data_map, decoded_value.memoryRowLength);
        FieldToDive(data_map, decoded_value.memoryImageHeight);
        FieldToDive(data_map, meta_struct.imageSubresource);
        FieldToDive(data_map, meta_struct.imageOffset);
        FieldToDive(data_map, meta_struct.imageExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyMemoryToImageInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyMemoryToImageInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMemoryToImageInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkHostImageCopyFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.dstImage);
        FieldToDive(data_map, decoded_value.dstImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyImageToMemoryInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageToMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageToMemoryInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkHostImageCopyFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.srcImage);
        FieldToDive(data_map, decoded_value.srcImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyImageToImageInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageToImageInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageToImageInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkHostImageCopyFlags_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.srcImage);
        FieldToDive(data_map, decoded_value.srcImageLayout);
        HandleToDive(data_map, meta_struct.dstImage);
        FieldToDive(data_map, decoded_value.dstImageLayout);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkHostImageLayoutTransitionInfo* data)
{
    if (data && data->decoded_value)
    {
        const VkHostImageLayoutTransitionInfo& decoded_value = *data->decoded_value;
        const Decoded_VkHostImageLayoutTransitionInfo& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.image);
        FieldToDive(data_map, decoded_value.oldLayout);
        FieldToDive(data_map, decoded_value.newLayout);
        FieldToDive(data_map, meta_struct.subresourceRange);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubresourceHostMemcpySize* data)
{
    if (data && data->decoded_value)
    {
        const VkSubresourceHostMemcpySize& decoded_value = *data->decoded_value;
        const Decoded_VkSubresourceHostMemcpySize& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkHostImageCopyDevicePerformanceQuery* data)
{
    if (data && data->decoded_value)
    {
        const VkHostImageCopyDevicePerformanceQuery& decoded_value = *data->decoded_value;
        const Decoded_VkHostImageCopyDevicePerformanceQuery& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.optimalDeviceAccess);
        FieldToDive(data_map, decoded_value.identicalMemoryLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.minImageCount);
        FieldToDive(data_map, decoded_value.maxImageCount);
        FieldToDive(data_map, meta_struct.currentExtent);
        FieldToDive(data_map, meta_struct.minImageExtent);
        FieldToDive(data_map, meta_struct.maxImageExtent);
        FieldToDive(data_map, decoded_value.maxImageArrayLayers);
        FieldToDive(VkSurfaceTransformFlagsKHR_t(),data_map, decoded_value.supportedTransforms);
        FieldToDive(data_map, decoded_value.currentTransform);
        FieldToDive(VkCompositeAlphaFlagsKHR_t(),data_map, decoded_value.supportedCompositeAlpha);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.supportedUsageFlags);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceFormatKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFormatKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFormatKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.colorSpace);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSwapchainCreateFlagsKHR_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.surface);
        FieldToDive(data_map, decoded_value.minImageCount);
        FieldToDive(data_map, decoded_value.imageFormat);
        FieldToDive(data_map, decoded_value.imageColorSpace);
        FieldToDive(data_map, meta_struct.imageExtent);
        FieldToDive(data_map, decoded_value.imageArrayLayers);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.imageUsage);
        FieldToDive(data_map, decoded_value.imageSharingMode);
        FieldToDive(data_map, decoded_value.queueFamilyIndexCount);
        FieldToDive(data_map, meta_struct.pQueueFamilyIndices);
        FieldToDive(data_map, decoded_value.preTransform);
        FieldToDive(data_map, decoded_value.compositeAlpha);
        FieldToDive(data_map, decoded_value.presentMode);
        FieldToDive(data_map, decoded_value.clipped);
        HandleToDive(data_map, meta_struct.oldSwapchain);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.waitSemaphoreCount);
        HandleToDive(data_map, &meta_struct.pWaitSemaphores);
        FieldToDive(data_map, decoded_value.swapchainCount);
        HandleToDive(data_map, &meta_struct.pSwapchains);
        FieldToDive(data_map, meta_struct.pImageIndices);
        FieldToDive(data_map, meta_struct.pResults);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageSwapchainCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImageSwapchainCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImageSwapchainCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.swapchain);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindImageMemorySwapchainInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkBindImageMemorySwapchainInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkBindImageMemorySwapchainInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.swapchain);
        FieldToDive(data_map, decoded_value.imageIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAcquireNextImageInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAcquireNextImageInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAcquireNextImageInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.swapchain);
        FieldToDive(data_map, decoded_value.timeout);
        HandleToDive(data_map, meta_struct.semaphore);
        HandleToDive(data_map, meta_struct.fence);
        FieldToDive(data_map, decoded_value.deviceMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupPresentCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupPresentCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupPresentCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.presentMask);
        FieldToDive(VkDeviceGroupPresentModeFlagsKHR_t(),data_map, decoded_value.modes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupPresentInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupPresentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupPresentInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainCount);
        FieldToDive(data_map, meta_struct.pDeviceMasks);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupSwapchainCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupSwapchainCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceGroupPresentModeFlagsKHR_t(),data_map, decoded_value.modes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayModeParametersKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeParametersKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeParametersKHR& meta_struct = *data;

        FieldToDive(data_map, meta_struct.visibleRegion);
        FieldToDive(data_map, decoded_value.refreshRate);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayModeCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDisplayModeCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.parameters);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayModePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModePropertiesKHR& meta_struct = *data;

        HandleToDive(data_map, meta_struct.displayMode);
        FieldToDive(data_map, meta_struct.parameters);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPlaneCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneCapabilitiesKHR& meta_struct = *data;

        FieldToDive(VkDisplayPlaneAlphaFlagsKHR_t(),data_map, decoded_value.supportedAlpha);
        FieldToDive(data_map, meta_struct.minSrcPosition);
        FieldToDive(data_map, meta_struct.maxSrcPosition);
        FieldToDive(data_map, meta_struct.minSrcExtent);
        FieldToDive(data_map, meta_struct.maxSrcExtent);
        FieldToDive(data_map, meta_struct.minDstPosition);
        FieldToDive(data_map, meta_struct.maxDstPosition);
        FieldToDive(data_map, meta_struct.minDstExtent);
        FieldToDive(data_map, meta_struct.maxDstExtent);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPlanePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlanePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlanePropertiesKHR& meta_struct = *data;

        HandleToDive(data_map, meta_struct.currentDisplay);
        FieldToDive(data_map, decoded_value.currentStackIndex);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPropertiesKHR& meta_struct = *data;

        HandleToDive(data_map, meta_struct.display);
        FieldToDive(data_map, &meta_struct.displayName);
        FieldToDive(data_map, meta_struct.physicalDimensions);
        FieldToDive(data_map, meta_struct.physicalResolution);
        FieldToDive(VkSurfaceTransformFlagsKHR_t(),data_map, decoded_value.supportedTransforms);
        FieldToDive(data_map, decoded_value.planeReorderPossible);
        FieldToDive(data_map, decoded_value.persistentContent);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplaySurfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplaySurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplaySurfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDisplaySurfaceCreateFlagsKHR_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.displayMode);
        FieldToDive(data_map, decoded_value.planeIndex);
        FieldToDive(data_map, decoded_value.planeStackIndex);
        FieldToDive(data_map, decoded_value.transform);
        FieldToDive(data_map, decoded_value.globalAlpha);
        FieldToDive(data_map, decoded_value.alphaMode);
        FieldToDive(data_map, meta_struct.imageExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPresentInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPresentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPresentInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.srcRect);
        FieldToDive(data_map, meta_struct.dstRect);
        FieldToDive(data_map, decoded_value.persistent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkXlibSurfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkXlibSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkXlibSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkXlibSurfaceCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.dpy);
        FieldToDive(data_map, decoded_value.window);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkXcbSurfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkXcbSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkXcbSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkXcbSurfaceCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.connection);
        FieldToDive(data_map, decoded_value.window);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWaylandSurfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkWaylandSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWaylandSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkWaylandSurfaceCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.display);
        FieldToDive(data_map, meta_struct.surface);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAndroidSurfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAndroidSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAndroidSurfaceCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.window);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWin32SurfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkWin32SurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWin32SurfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkWin32SurfaceCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.hinstance);
        FieldToDive(data_map, meta_struct.hwnd);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyQueryResultStatusPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.queryResultStatusSupport);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyVideoPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyVideoPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyVideoPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoCodecOperationFlagsKHR_t(),data_map, decoded_value.videoCodecOperations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.videoCodecOperation);
        FieldToDive(VkVideoChromaSubsamplingFlagsKHR_t(),data_map, decoded_value.chromaSubsampling);
        FieldToDive(VkVideoComponentBitDepthFlagsKHR_t(),data_map, decoded_value.lumaBitDepth);
        FieldToDive(VkVideoComponentBitDepthFlagsKHR_t(),data_map, decoded_value.chromaBitDepth);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoProfileListInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoProfileListInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoProfileListInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.profileCount);
        FieldToDive(data_map, meta_struct.pProfiles);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoCapabilityFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.minBitstreamBufferOffsetAlignment);
        FieldToDive(data_map, decoded_value.minBitstreamBufferSizeAlignment);
        FieldToDive(data_map, meta_struct.pictureAccessGranularity);
        FieldToDive(data_map, meta_struct.minCodedExtent);
        FieldToDive(data_map, meta_struct.maxCodedExtent);
        FieldToDive(data_map, decoded_value.maxDpbSlots);
        FieldToDive(data_map, decoded_value.maxActiveReferencePictures);
        FieldToDive(data_map, meta_struct.stdHeaderVersion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVideoFormatInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoFormatInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoFormatInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.imageUsage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoFormatPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, meta_struct.componentMapping);
        FieldToDive(VkImageCreateFlags_t(),data_map, decoded_value.imageCreateFlags);
        FieldToDive(data_map, decoded_value.imageType);
        FieldToDive(data_map, decoded_value.imageTiling);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.imageUsageFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoPictureResourceInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoPictureResourceInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoPictureResourceInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.codedOffset);
        FieldToDive(data_map, meta_struct.codedExtent);
        FieldToDive(data_map, decoded_value.baseArrayLayer);
        HandleToDive(data_map, meta_struct.imageViewBinding);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoReferenceSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoReferenceSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoReferenceSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.slotIndex);
        FieldToDive(data_map, meta_struct.pPictureResource);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoSessionMemoryRequirementsKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionMemoryRequirementsKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionMemoryRequirementsKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryBindIndex);
        FieldToDive(data_map, meta_struct.memoryRequirements);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindVideoSessionMemoryInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkBindVideoSessionMemoryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkBindVideoSessionMemoryInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryBindIndex);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.memoryOffset);
        FieldToDive(data_map, decoded_value.memorySize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoSessionCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.queueFamilyIndex);
        FieldToDive(VkVideoSessionCreateFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pVideoProfile);
        FieldToDive(data_map, decoded_value.pictureFormat);
        FieldToDive(data_map, meta_struct.maxCodedExtent);
        FieldToDive(data_map, decoded_value.referencePictureFormat);
        FieldToDive(data_map, decoded_value.maxDpbSlots);
        FieldToDive(data_map, decoded_value.maxActiveReferencePictures);
        FieldToDive(data_map, meta_struct.pStdHeaderVersion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoSessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoSessionParametersCreateFlagsKHR_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.videoSessionParametersTemplate);
        HandleToDive(data_map, meta_struct.videoSession);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoSessionParametersUpdateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionParametersUpdateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionParametersUpdateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.updateSequenceCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoBeginCodingInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoBeginCodingInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoBeginCodingInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoBeginCodingFlagsKHR_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.videoSession);
        HandleToDive(data_map, meta_struct.videoSessionParameters);
        FieldToDive(data_map, decoded_value.referenceSlotCount);
        FieldToDive(data_map, meta_struct.pReferenceSlots);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEndCodingInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEndCodingInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEndCodingInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEndCodingFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoCodingControlInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoCodingControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoCodingControlInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoCodingControlFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoDecodeCapabilityFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeUsageInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeUsageInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeUsageInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoDecodeUsageFlagsKHR_t(),data_map, decoded_value.videoUsageHints);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoDecodeFlagsKHR_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.srcBuffer);
        FieldToDive(data_map, decoded_value.srcBufferOffset);
        FieldToDive(data_map, decoded_value.srcBufferRange);
        FieldToDive(data_map, meta_struct.dstPictureResource);
        FieldToDive(data_map, meta_struct.pSetupReferenceSlot);
        FieldToDive(data_map, decoded_value.referenceSlotCount);
        FieldToDive(data_map, meta_struct.pReferenceSlots);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264CapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264CapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH264CapabilityFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.maxLevelIdc);
        FieldToDive(data_map, decoded_value.maxSliceCount);
        FieldToDive(data_map, decoded_value.maxPPictureL0ReferenceCount);
        FieldToDive(data_map, decoded_value.maxBPictureL0ReferenceCount);
        FieldToDive(data_map, decoded_value.maxL1ReferenceCount);
        FieldToDive(data_map, decoded_value.maxTemporalLayerCount);
        FieldToDive(data_map, decoded_value.expectDyadicTemporalLayerPattern);
        FieldToDive(data_map, decoded_value.minQp);
        FieldToDive(data_map, decoded_value.maxQp);
        FieldToDive(data_map, decoded_value.prefersGopRemainingFrames);
        FieldToDive(data_map, decoded_value.requiresGopRemainingFrames);
        FieldToDive(VkVideoEncodeH264StdFlagsKHR_t(),data_map, decoded_value.stdSyntaxFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264QpKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264QpKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264QpKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.qpI);
        FieldToDive(data_map, decoded_value.qpP);
        FieldToDive(data_map, decoded_value.qpB);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264QualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH264RateControlFlagsKHR_t(),data_map, decoded_value.preferredRateControlFlags);
        FieldToDive(data_map, decoded_value.preferredGopFrameCount);
        FieldToDive(data_map, decoded_value.preferredIdrPeriod);
        FieldToDive(data_map, decoded_value.preferredConsecutiveBFrameCount);
        FieldToDive(data_map, decoded_value.preferredTemporalLayerCount);
        FieldToDive(data_map, meta_struct.preferredConstantQp);
        FieldToDive(data_map, decoded_value.preferredMaxL0ReferenceCount);
        FieldToDive(data_map, decoded_value.preferredMaxL1ReferenceCount);
        FieldToDive(data_map, decoded_value.preferredStdEntropyCodingModeFlag);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264SessionCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useMaxLevelIdc);
        FieldToDive(data_map, decoded_value.maxLevelIdc);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdSPSCount);
        FieldToDive(data_map, meta_struct.pStdSPSs);
        FieldToDive(data_map, decoded_value.stdPPSCount);
        FieldToDive(data_map, meta_struct.pStdPPSs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxStdSPSCount);
        FieldToDive(data_map, decoded_value.maxStdPPSCount);
        FieldToDive(data_map, meta_struct.pParametersAddInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersGetInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.writeStdSPS);
        FieldToDive(data_map, decoded_value.writeStdPPS);
        FieldToDive(data_map, decoded_value.stdSPSId);
        FieldToDive(data_map, decoded_value.stdPPSId);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersFeedbackInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hasStdSPSOverrides);
        FieldToDive(data_map, decoded_value.hasStdPPSOverrides);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264NaluSliceInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264NaluSliceInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264NaluSliceInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.constantQp);
        FieldToDive(data_map, meta_struct.pStdSliceHeader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264PictureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264PictureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.naluSliceEntryCount);
        FieldToDive(data_map, meta_struct.pNaluSliceEntries);
        FieldToDive(data_map, meta_struct.pStdPictureInfo);
        FieldToDive(data_map, decoded_value.generatePrefixNalu);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264DpbSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264DpbSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdReferenceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264ProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264ProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdProfileIdc);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264RateControlInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264RateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264RateControlInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH264RateControlFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.gopFrameCount);
        FieldToDive(data_map, decoded_value.idrPeriod);
        FieldToDive(data_map, decoded_value.consecutiveBFrameCount);
        FieldToDive(data_map, decoded_value.temporalLayerCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264FrameSizeKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264FrameSizeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264FrameSizeKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.frameISize);
        FieldToDive(data_map, decoded_value.framePSize);
        FieldToDive(data_map, decoded_value.frameBSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264RateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useMinQp);
        FieldToDive(data_map, meta_struct.minQp);
        FieldToDive(data_map, decoded_value.useMaxQp);
        FieldToDive(data_map, meta_struct.maxQp);
        FieldToDive(data_map, decoded_value.useMaxFrameSize);
        FieldToDive(data_map, meta_struct.maxFrameSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264GopRemainingFrameInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useGopRemainingFrames);
        FieldToDive(data_map, decoded_value.gopRemainingI);
        FieldToDive(data_map, decoded_value.gopRemainingP);
        FieldToDive(data_map, decoded_value.gopRemainingB);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265CapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265CapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH265CapabilityFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.maxLevelIdc);
        FieldToDive(data_map, decoded_value.maxSliceSegmentCount);
        FieldToDive(data_map, meta_struct.maxTiles);
        FieldToDive(VkVideoEncodeH265CtbSizeFlagsKHR_t(),data_map, decoded_value.ctbSizes);
        FieldToDive(VkVideoEncodeH265TransformBlockSizeFlagsKHR_t(),data_map, decoded_value.transformBlockSizes);
        FieldToDive(data_map, decoded_value.maxPPictureL0ReferenceCount);
        FieldToDive(data_map, decoded_value.maxBPictureL0ReferenceCount);
        FieldToDive(data_map, decoded_value.maxL1ReferenceCount);
        FieldToDive(data_map, decoded_value.maxSubLayerCount);
        FieldToDive(data_map, decoded_value.expectDyadicTemporalSubLayerPattern);
        FieldToDive(data_map, decoded_value.minQp);
        FieldToDive(data_map, decoded_value.maxQp);
        FieldToDive(data_map, decoded_value.prefersGopRemainingFrames);
        FieldToDive(data_map, decoded_value.requiresGopRemainingFrames);
        FieldToDive(VkVideoEncodeH265StdFlagsKHR_t(),data_map, decoded_value.stdSyntaxFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265SessionCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useMaxLevelIdc);
        FieldToDive(data_map, decoded_value.maxLevelIdc);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265QpKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265QpKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265QpKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.qpI);
        FieldToDive(data_map, decoded_value.qpP);
        FieldToDive(data_map, decoded_value.qpB);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265QualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH265RateControlFlagsKHR_t(),data_map, decoded_value.preferredRateControlFlags);
        FieldToDive(data_map, decoded_value.preferredGopFrameCount);
        FieldToDive(data_map, decoded_value.preferredIdrPeriod);
        FieldToDive(data_map, decoded_value.preferredConsecutiveBFrameCount);
        FieldToDive(data_map, decoded_value.preferredSubLayerCount);
        FieldToDive(data_map, meta_struct.preferredConstantQp);
        FieldToDive(data_map, decoded_value.preferredMaxL0ReferenceCount);
        FieldToDive(data_map, decoded_value.preferredMaxL1ReferenceCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdVPSCount);
        FieldToDive(data_map, meta_struct.pStdVPSs);
        FieldToDive(data_map, decoded_value.stdSPSCount);
        FieldToDive(data_map, meta_struct.pStdSPSs);
        FieldToDive(data_map, decoded_value.stdPPSCount);
        FieldToDive(data_map, meta_struct.pStdPPSs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxStdVPSCount);
        FieldToDive(data_map, decoded_value.maxStdSPSCount);
        FieldToDive(data_map, decoded_value.maxStdPPSCount);
        FieldToDive(data_map, meta_struct.pParametersAddInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersGetInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.writeStdVPS);
        FieldToDive(data_map, decoded_value.writeStdSPS);
        FieldToDive(data_map, decoded_value.writeStdPPS);
        FieldToDive(data_map, decoded_value.stdVPSId);
        FieldToDive(data_map, decoded_value.stdSPSId);
        FieldToDive(data_map, decoded_value.stdPPSId);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersFeedbackInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hasStdVPSOverrides);
        FieldToDive(data_map, decoded_value.hasStdSPSOverrides);
        FieldToDive(data_map, decoded_value.hasStdPPSOverrides);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265NaluSliceSegmentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.constantQp);
        FieldToDive(data_map, meta_struct.pStdSliceSegmentHeader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265PictureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265PictureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.naluSliceSegmentEntryCount);
        FieldToDive(data_map, meta_struct.pNaluSliceSegmentEntries);
        FieldToDive(data_map, meta_struct.pStdPictureInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265DpbSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265DpbSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdReferenceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265ProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265ProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdProfileIdc);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265RateControlInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265RateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265RateControlInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH265RateControlFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.gopFrameCount);
        FieldToDive(data_map, decoded_value.idrPeriod);
        FieldToDive(data_map, decoded_value.consecutiveBFrameCount);
        FieldToDive(data_map, decoded_value.subLayerCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265FrameSizeKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265FrameSizeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265FrameSizeKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.frameISize);
        FieldToDive(data_map, decoded_value.framePSize);
        FieldToDive(data_map, decoded_value.frameBSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265RateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useMinQp);
        FieldToDive(data_map, meta_struct.minQp);
        FieldToDive(data_map, decoded_value.useMaxQp);
        FieldToDive(data_map, meta_struct.maxQp);
        FieldToDive(data_map, decoded_value.useMaxFrameSize);
        FieldToDive(data_map, meta_struct.maxFrameSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265GopRemainingFrameInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useGopRemainingFrames);
        FieldToDive(data_map, decoded_value.gopRemainingI);
        FieldToDive(data_map, decoded_value.gopRemainingP);
        FieldToDive(data_map, decoded_value.gopRemainingB);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264ProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264ProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdProfileIdc);
        FieldToDive(data_map, decoded_value.pictureLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264CapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264CapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxLevelIdc);
        FieldToDive(data_map, meta_struct.fieldOffsetGranularity);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdSPSCount);
        FieldToDive(data_map, meta_struct.pStdSPSs);
        FieldToDive(data_map, decoded_value.stdPPSCount);
        FieldToDive(data_map, meta_struct.pStdPPSs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxStdSPSCount);
        FieldToDive(data_map, decoded_value.maxStdPPSCount);
        FieldToDive(data_map, meta_struct.pParametersAddInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264PictureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264PictureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdPictureInfo);
        FieldToDive(data_map, decoded_value.sliceCount);
        FieldToDive(data_map, meta_struct.pSliceOffsets);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264DpbSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264DpbSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdReferenceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportMemoryWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.handle);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportMemoryWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pAttributes);
        FieldToDive(data_map, decoded_value.dwAccess);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryWin32HandlePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryWin32HandlePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryWin32HandlePropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryGetWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportMemoryFdInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryFdInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, decoded_value.fd);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryFdPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryFdPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryFdPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryGetFdInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetFdInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkWin32KeyedMutexAcquireReleaseInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.acquireCount);
        HandleToDive(data_map, &meta_struct.pAcquireSyncs);
        FieldToDive(data_map, meta_struct.pAcquireKeys);
        FieldToDive(data_map, meta_struct.pAcquireTimeouts);
        FieldToDive(data_map, decoded_value.releaseCount);
        HandleToDive(data_map, &meta_struct.pReleaseSyncs);
        FieldToDive(data_map, meta_struct.pReleaseKeys);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportSemaphoreWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImportSemaphoreWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportSemaphoreWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(VkSemaphoreImportFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.handle);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportSemaphoreWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkExportSemaphoreWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkExportSemaphoreWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pAttributes);
        FieldToDive(data_map, decoded_value.dwAccess);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkD3D12FenceSubmitInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkD3D12FenceSubmitInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkD3D12FenceSubmitInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.waitSemaphoreValuesCount);
        FieldToDive(data_map, meta_struct.pWaitSemaphoreValues);
        FieldToDive(data_map, decoded_value.signalSemaphoreValuesCount);
        FieldToDive(data_map, meta_struct.pSignalSemaphoreValues);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreGetWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreGetWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreGetWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportSemaphoreFdInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImportSemaphoreFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportSemaphoreFdInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(VkSemaphoreImportFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, decoded_value.fd);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreGetFdInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreGetFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreGetFdInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRectLayerKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkRectLayerKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRectLayerKHR& meta_struct = *data;

        FieldToDive(data_map, meta_struct.offset);
        FieldToDive(data_map, meta_struct.extent);
        FieldToDive(data_map, decoded_value.layer);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentRegionKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentRegionKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentRegionKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.rectangleCount);
        FieldToDive(data_map, meta_struct.pRectangles);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentRegionsKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentRegionsKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentRegionsKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSharedPresentSurfaceCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSharedPresentSurfaceCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.sharedPresentSupportedUsageFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportFenceWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImportFenceWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportFenceWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.fence);
        FieldToDive(VkFenceImportFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.handle);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportFenceWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkExportFenceWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkExportFenceWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pAttributes);
        FieldToDive(data_map, decoded_value.dwAccess);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFenceGetWin32HandleInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkFenceGetWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkFenceGetWin32HandleInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.fence);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportFenceFdInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkImportFenceFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportFenceFdInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.fence);
        FieldToDive(VkFenceImportFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, decoded_value.fd);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFenceGetFdInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkFenceGetFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkFenceGetFdInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.fence);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePerformanceQueryFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.performanceCounterQueryPools);
        FieldToDive(data_map, decoded_value.performanceCounterMultipleQueryPools);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePerformanceQueryPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.allowCommandBufferQueryCopies);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceCounterKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceCounterKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceCounterKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.unit);
        FieldToDive(data_map, decoded_value.scope);
        FieldToDive(data_map, decoded_value.storage);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.uuid), decoded_value.uuid));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceCounterDescriptionKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceCounterDescriptionKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceCounterDescriptionKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPerformanceCounterDescriptionFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, &meta_struct.category);
        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueryPoolPerformanceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolPerformanceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolPerformanceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.queueFamilyIndex);
        FieldToDive(data_map, decoded_value.counterIndexCount);
        FieldToDive(data_map, meta_struct.pCounterIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAcquireProfilingLockInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAcquireProfilingLockInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAcquireProfilingLockInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAcquireProfilingLockFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.timeout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceQuerySubmitInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceQuerySubmitInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceQuerySubmitInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.counterPassIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSurfaceInfo2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSurfaceInfo2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.surface);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceCapabilities2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilities2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilities2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.surfaceCapabilities);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceFormat2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFormat2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFormat2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.surfaceFormat);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayProperties2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayProperties2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayProperties2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.displayProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPlaneProperties2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneProperties2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneProperties2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.displayPlaneProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayModeProperties2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeProperties2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeProperties2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.displayModeProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPlaneInfo2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneInfo2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneInfo2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.mode);
        FieldToDive(data_map, decoded_value.planeIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPlaneCapabilities2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneCapabilities2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneCapabilities2KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.capabilities);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePortabilitySubsetFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.constantAlphaColorBlendFactors);
        FieldToDive(data_map, decoded_value.events);
        FieldToDive(data_map, decoded_value.imageViewFormatReinterpretation);
        FieldToDive(data_map, decoded_value.imageViewFormatSwizzle);
        FieldToDive(data_map, decoded_value.imageView2DOn3DImage);
        FieldToDive(data_map, decoded_value.multisampleArrayImage);
        FieldToDive(data_map, decoded_value.mutableComparisonSamplers);
        FieldToDive(data_map, decoded_value.pointPolygons);
        FieldToDive(data_map, decoded_value.samplerMipLodBias);
        FieldToDive(data_map, decoded_value.separateStencilMaskRef);
        FieldToDive(data_map, decoded_value.shaderSampleRateInterpolationFunctions);
        FieldToDive(data_map, decoded_value.tessellationIsolines);
        FieldToDive(data_map, decoded_value.tessellationPointMode);
        FieldToDive(data_map, decoded_value.triangleFans);
        FieldToDive(data_map, decoded_value.vertexAttributeAccessBeyondStride);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePortabilitySubsetPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minVertexInputBindingStrideAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderClockFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderSubgroupClock);
        FieldToDive(data_map, decoded_value.shaderDeviceClock);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265ProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265ProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdProfileIdc);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265CapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265CapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxLevelIdc);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdVPSCount);
        FieldToDive(data_map, meta_struct.pStdVPSs);
        FieldToDive(data_map, decoded_value.stdSPSCount);
        FieldToDive(data_map, meta_struct.pStdSPSs);
        FieldToDive(data_map, decoded_value.stdPPSCount);
        FieldToDive(data_map, meta_struct.pStdPPSs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxStdVPSCount);
        FieldToDive(data_map, decoded_value.maxStdSPSCount);
        FieldToDive(data_map, decoded_value.maxStdPPSCount);
        FieldToDive(data_map, meta_struct.pParametersAddInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265PictureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265PictureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdPictureInfo);
        FieldToDive(data_map, decoded_value.sliceSegmentCount);
        FieldToDive(data_map, meta_struct.pSliceSegmentOffsets);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265DpbSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265DpbSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdReferenceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFragmentShadingRateAttachmentInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkFragmentShadingRateAttachmentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkFragmentShadingRateAttachmentInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pFragmentShadingRateAttachment);
        FieldToDive(data_map, meta_struct.shadingRateAttachmentTexelSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineFragmentShadingRateStateCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.fragmentSize);
        FieldToDive(data_map, &meta_struct.combinerOps);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineFragmentShadingRate);
        FieldToDive(data_map, decoded_value.primitiveFragmentShadingRate);
        FieldToDive(data_map, decoded_value.attachmentFragmentShadingRate);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRatePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.minFragmentShadingRateAttachmentTexelSize);
        FieldToDive(data_map, meta_struct.maxFragmentShadingRateAttachmentTexelSize);
        FieldToDive(data_map, decoded_value.maxFragmentShadingRateAttachmentTexelSizeAspectRatio);
        FieldToDive(data_map, decoded_value.primitiveFragmentShadingRateWithMultipleViewports);
        FieldToDive(data_map, decoded_value.layeredShadingRateAttachments);
        FieldToDive(data_map, decoded_value.fragmentShadingRateNonTrivialCombinerOps);
        FieldToDive(data_map, meta_struct.maxFragmentSize);
        FieldToDive(data_map, decoded_value.maxFragmentSizeAspectRatio);
        FieldToDive(data_map, decoded_value.maxFragmentShadingRateCoverageSamples);
        FieldToDive(data_map, decoded_value.maxFragmentShadingRateRasterizationSamples);
        FieldToDive(data_map, decoded_value.fragmentShadingRateWithShaderDepthStencilWrites);
        FieldToDive(data_map, decoded_value.fragmentShadingRateWithSampleMask);
        FieldToDive(data_map, decoded_value.fragmentShadingRateWithShaderSampleMask);
        FieldToDive(data_map, decoded_value.fragmentShadingRateWithConservativeRasterization);
        FieldToDive(data_map, decoded_value.fragmentShadingRateWithFragmentShaderInterlock);
        FieldToDive(data_map, decoded_value.fragmentShadingRateWithCustomSampleLocations);
        FieldToDive(data_map, decoded_value.fragmentShadingRateStrictMultiplyCombiner);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShadingRateKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampleCounts);
        FieldToDive(data_map, meta_struct.fragmentSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingFragmentShadingRateAttachmentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.imageView);
        FieldToDive(data_map, decoded_value.imageLayout);
        FieldToDive(data_map, meta_struct.shadingRateAttachmentTexelSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderQuadControlFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderQuadControl);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceProtectedCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceProtectedCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceProtectedCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.supportsProtected);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentWaitFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentWait);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineExecutableInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineExecutablePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineExecutablePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineExecutablePropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stages);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, decoded_value.subgroupSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineExecutableInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineExecutableInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineExecutableInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, decoded_value.executableIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineExecutableInternalRepresentationKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineExecutableInternalRepresentationKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineExecutableInternalRepresentationKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.name);
        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, decoded_value.isText);
        FieldToDive(data_map, decoded_value.dataSize);
        FieldToDive(data_map, meta_struct.pData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineLibraryCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineLibraryCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineLibraryCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.libraryCount);
        HandleToDive(data_map, &meta_struct.pLibraries);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentIdKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentIdKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentIdKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainCount);
        FieldToDive(data_map, meta_struct.pPresentIds);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePresentIdFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentIdFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentIdFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentId);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeFlagsKHR_t(),data_map, decoded_value.flags);
        HandleToDive(data_map, meta_struct.dstBuffer);
        FieldToDive(data_map, decoded_value.dstBufferOffset);
        FieldToDive(data_map, decoded_value.dstBufferRange);
        FieldToDive(data_map, meta_struct.srcPictureResource);
        FieldToDive(data_map, meta_struct.pSetupReferenceSlot);
        FieldToDive(data_map, decoded_value.referenceSlotCount);
        FieldToDive(data_map, meta_struct.pReferenceSlots);
        FieldToDive(data_map, decoded_value.precedingExternallyEncodedBytes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeCapabilityFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(VkVideoEncodeRateControlModeFlagsKHR_t(),data_map, decoded_value.rateControlModes);
        FieldToDive(data_map, decoded_value.maxRateControlLayers);
        FieldToDive(data_map, decoded_value.maxBitrate);
        FieldToDive(data_map, decoded_value.maxQualityLevels);
        FieldToDive(data_map, meta_struct.encodeInputPictureGranularity);
        FieldToDive(VkVideoEncodeFeedbackFlagsKHR_t(),data_map, decoded_value.supportedEncodeFeedbackFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeFeedbackFlagsKHR_t(),data_map, decoded_value.encodeFeedbackFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeUsageInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeUsageInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeUsageInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeUsageFlagsKHR_t(),data_map, decoded_value.videoUsageHints);
        FieldToDive(VkVideoEncodeContentFlagsKHR_t(),data_map, decoded_value.videoContentHints);
        FieldToDive(data_map, decoded_value.tuningMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeRateControlLayerInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeRateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeRateControlLayerInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.averageBitrate);
        FieldToDive(data_map, decoded_value.maxBitrate);
        FieldToDive(data_map, decoded_value.frameRateNumerator);
        FieldToDive(data_map, decoded_value.frameRateDenominator);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeRateControlInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeRateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeRateControlInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeRateControlFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.rateControlMode);
        FieldToDive(data_map, decoded_value.layerCount);
        FieldToDive(data_map, meta_struct.pLayers);
        FieldToDive(data_map, decoded_value.virtualBufferSizeInMs);
        FieldToDive(data_map, decoded_value.initialVirtualBufferSizeInMs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pVideoProfile);
        FieldToDive(data_map, decoded_value.qualityLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeQualityLevelPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQualityLevelPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.preferredRateControlMode);
        FieldToDive(data_map, decoded_value.preferredRateControlLayerCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeQualityLevelInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQualityLevelInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQualityLevelInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.qualityLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeSessionParametersGetInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeSessionParametersGetInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeSessionParametersGetInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.videoSessionParameters);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeSessionParametersFeedbackInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hasOverrides);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentShaderBarycentric);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.triStripVertexOrderIndependentOfProvokingVertex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderSubgroupUniformControlFlow);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.workgroupMemoryExplicitLayout);
        FieldToDive(data_map, decoded_value.workgroupMemoryExplicitLayoutScalarBlockLayout);
        FieldToDive(data_map, decoded_value.workgroupMemoryExplicitLayout8BitAccess);
        FieldToDive(data_map, decoded_value.workgroupMemoryExplicitLayout16BitAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingMaintenance1);
        FieldToDive(data_map, decoded_value.rayTracingPipelineTraceRaysIndirect2);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkTraceRaysIndirectCommand2KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkTraceRaysIndirectCommand2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkTraceRaysIndirectCommand2KHR& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.raygenShaderRecordAddress));
        FieldToDive(data_map, decoded_value.raygenShaderRecordSize);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.missShaderBindingTableAddress));
        FieldToDive(data_map, decoded_value.missShaderBindingTableSize);
        FieldToDive(data_map, decoded_value.missShaderBindingTableStride);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.hitShaderBindingTableAddress));
        FieldToDive(data_map, decoded_value.hitShaderBindingTableSize);
        FieldToDive(data_map, decoded_value.hitShaderBindingTableStride);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.callableShaderBindingTableAddress));
        FieldToDive(data_map, decoded_value.callableShaderBindingTableSize);
        FieldToDive(data_map, decoded_value.callableShaderBindingTableStride);
        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.depth);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderMaximalReconvergence);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingPositionFetch);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineBinaryFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineBinaries);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineBinaryPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineBinaryInternalCache);
        FieldToDive(data_map, decoded_value.pipelineBinaryInternalCacheControl);
        FieldToDive(data_map, decoded_value.pipelineBinaryPrefersInternalCache);
        FieldToDive(data_map, decoded_value.pipelineBinaryPrecompiledInternalCache);
        FieldToDive(data_map, decoded_value.pipelineBinaryCompressedData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkDevicePipelineBinaryInternalCacheControlKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.disableInternalCache);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryKeyKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryKeyKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryKeyKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.keySize);
        FieldToDive(data_map, &meta_struct.key);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryDataKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryDataKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.dataSize);
        FieldToDive(data_map, meta_struct.pData);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryKeysAndDataKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryKeysAndDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryKeysAndDataKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.binaryCount);
        FieldToDive(data_map, meta_struct.pPipelineBinaryKeys);
        FieldToDive(data_map, meta_struct.pPipelineBinaryData);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pKeysAndDataInfo);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, meta_struct.pPipelineCreateInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.binaryCount);
        HandleToDive(data_map, &meta_struct.pPipelineBinaries);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkReleaseCapturedPipelineDataInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkReleaseCapturedPipelineDataInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkReleaseCapturedPipelineDataInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryDataInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryDataInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryDataInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.pipelineBinary);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineBinaryHandlesInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryHandlesInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryHandlesInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineBinaryCount);
        HandleToDive(data_map, &meta_struct.pPipelineBinaries);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCooperativeMatrixPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeMatrixPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeMatrixPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.MSize);
        FieldToDive(data_map, decoded_value.NSize);
        FieldToDive(data_map, decoded_value.KSize);
        FieldToDive(data_map, decoded_value.AType);
        FieldToDive(data_map, decoded_value.BType);
        FieldToDive(data_map, decoded_value.CType);
        FieldToDive(data_map, decoded_value.ResultType);
        FieldToDive(data_map, decoded_value.saturatingAccumulation);
        FieldToDive(data_map, decoded_value.scope);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cooperativeMatrix);
        FieldToDive(data_map, decoded_value.cooperativeMatrixRobustBufferAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.cooperativeMatrixSupportedStages);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.computeDerivativeGroupQuads);
        FieldToDive(data_map, decoded_value.computeDerivativeGroupLinear);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.meshAndTaskShaderDerivatives);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeAV1ProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1ProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdProfile);
        FieldToDive(data_map, decoded_value.filmGrainSupport);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeAV1CapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1CapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdSequenceHeader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeAV1PictureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1PictureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdPictureInfo);
        FieldToDive(data_map, &meta_struct.referenceNameSlotIndices);
        FieldToDive(data_map, decoded_value.frameHeaderOffset);
        FieldToDive(data_map, decoded_value.tileCount);
        FieldToDive(data_map, meta_struct.pTileOffsets);
        FieldToDive(data_map, meta_struct.pTileSizes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdReferenceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.videoEncodeAV1);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1CapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1CapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeAV1CapabilityFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.maxLevel);
        FieldToDive(data_map, meta_struct.codedPictureAlignment);
        FieldToDive(data_map, meta_struct.maxTiles);
        FieldToDive(data_map, meta_struct.minTileSize);
        FieldToDive(data_map, meta_struct.maxTileSize);
        FieldToDive(VkVideoEncodeAV1SuperblockSizeFlagsKHR_t(),data_map, decoded_value.superblockSizes);
        FieldToDive(data_map, decoded_value.maxSingleReferenceCount);
        FieldToDive(data_map, decoded_value.singleReferenceNameMask);
        FieldToDive(data_map, decoded_value.maxUnidirectionalCompoundReferenceCount);
        FieldToDive(data_map, decoded_value.maxUnidirectionalCompoundGroup1ReferenceCount);
        FieldToDive(data_map, decoded_value.unidirectionalCompoundReferenceNameMask);
        FieldToDive(data_map, decoded_value.maxBidirectionalCompoundReferenceCount);
        FieldToDive(data_map, decoded_value.maxBidirectionalCompoundGroup1ReferenceCount);
        FieldToDive(data_map, decoded_value.maxBidirectionalCompoundGroup2ReferenceCount);
        FieldToDive(data_map, decoded_value.bidirectionalCompoundReferenceNameMask);
        FieldToDive(data_map, decoded_value.maxTemporalLayerCount);
        FieldToDive(data_map, decoded_value.maxSpatialLayerCount);
        FieldToDive(data_map, decoded_value.maxOperatingPoints);
        FieldToDive(data_map, decoded_value.minQIndex);
        FieldToDive(data_map, decoded_value.maxQIndex);
        FieldToDive(data_map, decoded_value.prefersGopRemainingFrames);
        FieldToDive(data_map, decoded_value.requiresGopRemainingFrames);
        FieldToDive(VkVideoEncodeAV1StdFlagsKHR_t(),data_map, decoded_value.stdSyntaxFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1QIndexKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1QIndexKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1QIndexKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.intraQIndex);
        FieldToDive(data_map, decoded_value.predictiveQIndex);
        FieldToDive(data_map, decoded_value.bipredictiveQIndex);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1QualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeAV1RateControlFlagsKHR_t(),data_map, decoded_value.preferredRateControlFlags);
        FieldToDive(data_map, decoded_value.preferredGopFrameCount);
        FieldToDive(data_map, decoded_value.preferredKeyFramePeriod);
        FieldToDive(data_map, decoded_value.preferredConsecutiveBipredictiveFrameCount);
        FieldToDive(data_map, decoded_value.preferredTemporalLayerCount);
        FieldToDive(data_map, meta_struct.preferredConstantQIndex);
        FieldToDive(data_map, decoded_value.preferredMaxSingleReferenceCount);
        FieldToDive(data_map, decoded_value.preferredSingleReferenceNameMask);
        FieldToDive(data_map, decoded_value.preferredMaxUnidirectionalCompoundReferenceCount);
        FieldToDive(data_map, decoded_value.preferredMaxUnidirectionalCompoundGroup1ReferenceCount);
        FieldToDive(data_map, decoded_value.preferredUnidirectionalCompoundReferenceNameMask);
        FieldToDive(data_map, decoded_value.preferredMaxBidirectionalCompoundReferenceCount);
        FieldToDive(data_map, decoded_value.preferredMaxBidirectionalCompoundGroup1ReferenceCount);
        FieldToDive(data_map, decoded_value.preferredMaxBidirectionalCompoundGroup2ReferenceCount);
        FieldToDive(data_map, decoded_value.preferredBidirectionalCompoundReferenceNameMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1SessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useMaxLevel);
        FieldToDive(data_map, decoded_value.maxLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdSequenceHeader);
        FieldToDive(data_map, meta_struct.pStdDecoderModelInfo);
        FieldToDive(data_map, decoded_value.stdOperatingPointCount);
        FieldToDive(data_map, meta_struct.pStdOperatingPoints);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1PictureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1PictureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.predictionMode);
        FieldToDive(data_map, decoded_value.rateControlGroup);
        FieldToDive(data_map, decoded_value.constantQIndex);
        FieldToDive(data_map, meta_struct.pStdPictureInfo);
        FieldToDive(data_map, &meta_struct.referenceNameSlotIndices);
        FieldToDive(data_map, decoded_value.primaryReferenceCdfOnly);
        FieldToDive(data_map, decoded_value.generateObuExtensionHeader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdReferenceInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1ProfileInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1ProfileInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stdProfile);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1FrameSizeKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1FrameSizeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1FrameSizeKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.intraFrameSize);
        FieldToDive(data_map, decoded_value.predictiveFrameSize);
        FieldToDive(data_map, decoded_value.bipredictiveFrameSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1GopRemainingFrameInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useGopRemainingFrames);
        FieldToDive(data_map, decoded_value.gopRemainingIntra);
        FieldToDive(data_map, decoded_value.gopRemainingPredictive);
        FieldToDive(data_map, decoded_value.gopRemainingBipredictive);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1RateControlInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1RateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1RateControlInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeAV1RateControlFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.gopFrameCount);
        FieldToDive(data_map, decoded_value.keyFramePeriod);
        FieldToDive(data_map, decoded_value.consecutiveBipredictiveFrameCount);
        FieldToDive(data_map, decoded_value.temporalLayerCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1RateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.useMinQIndex);
        FieldToDive(data_map, meta_struct.minQIndex);
        FieldToDive(data_map, decoded_value.useMaxQIndex);
        FieldToDive(data_map, meta_struct.maxQIndex);
        FieldToDive(data_map, decoded_value.useMaxFrameSize);
        FieldToDive(data_map, meta_struct.maxFrameSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoMaintenance1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.videoMaintenance1);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoInlineQueryInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoInlineQueryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoInlineQueryInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.queryPool);
        FieldToDive(data_map, decoded_value.firstQuery);
        FieldToDive(data_map, decoded_value.queryCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCalibratedTimestampInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkCalibratedTimestampInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCalibratedTimestampInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.timeDomain);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSetDescriptorBufferOffsetsInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSetDescriptorBufferOffsetsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSetDescriptorBufferOffsetsInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        HandleToDive(data_map, meta_struct.layout);
        FieldToDive(data_map, decoded_value.firstSet);
        FieldToDive(data_map, decoded_value.setCount);
        FieldToDive(data_map, meta_struct.pBufferIndices);
        FieldToDive(data_map, meta_struct.pOffsets);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkBindDescriptorBufferEmbeddedSamplersInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.stageFlags);
        HandleToDive(data_map, meta_struct.layout);
        FieldToDive(data_map, decoded_value.set);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.maxQuantizationMapExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoFormatQuantizationMapPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatQuantizationMapPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatQuantizationMapPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.quantizationMapTexelSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeQuantizationMapInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQuantizationMapInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQuantizationMapInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.quantizationMap);
        FieldToDive(data_map, meta_struct.quantizationMapExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.quantizationMapTexelSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.videoEncodeQuantizationMap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264QuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minQpDelta);
        FieldToDive(data_map, decoded_value.maxQpDelta);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265QuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minQpDelta);
        FieldToDive(data_map, decoded_value.maxQpDelta);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatH265QuantizationMapPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeH265CtbSizeFlagsKHR_t(),data_map, decoded_value.compatibleCtbSizes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minQIndexDelta);
        FieldToDive(data_map, decoded_value.maxQIndexDelta);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatAV1QuantizationMapPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkVideoEncodeAV1SuperblockSizeFlagsKHR_t(),data_map, decoded_value.compatibleSuperblockSizes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderRelaxedExtendedInstruction);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance7FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maintenance7);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance7PropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.robustFragmentShadingRateAttachmentAccess);
        FieldToDive(data_map, decoded_value.separateDepthStencilAttachmentAccess);
        FieldToDive(data_map, decoded_value.maxDescriptorSetTotalUniformBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetTotalStorageBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetTotalBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredApiPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vendorID);
        FieldToDive(data_map, decoded_value.deviceID);
        FieldToDive(data_map, decoded_value.layeredAPI);
        FieldToDive(data_map, &meta_struct.deviceName);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredApiPropertiesListKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.layeredApiCount);
        FieldToDive(data_map, meta_struct.pLayeredApis);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.properties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance8FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maintenance8);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryBarrierAccessFlags3KHR* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryBarrierAccessFlags3KHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryBarrierAccessFlags3KHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAccessFlags3KHR_t(),data_map, decoded_value.srcAccessMask3);
        FieldToDive(VkAccessFlags3KHR_t(),data_map, decoded_value.dstAccessMask3);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoMaintenance2FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.videoMaintenance2);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264InlineSessionParametersInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdSPS);
        FieldToDive(data_map, meta_struct.pStdPPS);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265InlineSessionParametersInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdVPS);
        FieldToDive(data_map, meta_struct.pStdSPS);
        FieldToDive(data_map, meta_struct.pStdPPS);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1InlineSessionParametersInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pStdSequenceHeader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthClampZeroOne);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugReportCallbackCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugReportCallbackCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugReportCallbackCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDebugReportFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnCallback));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pUserData));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationStateRasterizationOrderAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rasterizationOrder);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugMarkerObjectNameInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugMarkerObjectNameInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugMarkerObjectNameInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.objectType);
        FieldToDive(data_map, decoded_value.object);
        FieldToDive(data_map, &meta_struct.pObjectName);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugMarkerObjectTagInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugMarkerObjectTagInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugMarkerObjectTagInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.objectType);
        FieldToDive(data_map, decoded_value.object);
        FieldToDive(data_map, decoded_value.tagName);
        FieldToDive(data_map, decoded_value.tagSize);
        FieldToDive(data_map, meta_struct.pTag);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugMarkerMarkerInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugMarkerMarkerInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugMarkerMarkerInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.pMarkerName);
        FieldToDive(data_map, &meta_struct.color);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDedicatedAllocationImageCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDedicatedAllocationImageCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDedicatedAllocationImageCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dedicatedAllocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDedicatedAllocationBufferCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDedicatedAllocationBufferCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDedicatedAllocationBufferCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dedicatedAllocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDedicatedAllocationMemoryAllocateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.image);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTransformFeedbackFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.transformFeedback);
        FieldToDive(data_map, decoded_value.geometryStreams);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTransformFeedbackPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxTransformFeedbackStreams);
        FieldToDive(data_map, decoded_value.maxTransformFeedbackBuffers);
        FieldToDive(data_map, decoded_value.maxTransformFeedbackBufferSize);
        FieldToDive(data_map, decoded_value.maxTransformFeedbackStreamDataSize);
        FieldToDive(data_map, decoded_value.maxTransformFeedbackBufferDataSize);
        FieldToDive(data_map, decoded_value.maxTransformFeedbackBufferDataStride);
        FieldToDive(data_map, decoded_value.transformFeedbackQueries);
        FieldToDive(data_map, decoded_value.transformFeedbackStreamsLinesTriangles);
        FieldToDive(data_map, decoded_value.transformFeedbackRasterizationStreamSelect);
        FieldToDive(data_map, decoded_value.transformFeedbackDraw);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationStateStreamCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineRasterizationStateStreamCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.rasterizationStream);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewHandleInfoNVX* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewHandleInfoNVX& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewHandleInfoNVX& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.imageView);
        FieldToDive(data_map, decoded_value.descriptorType);
        HandleToDive(data_map, meta_struct.sampler);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewAddressPropertiesNVX* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewAddressPropertiesNVX& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewAddressPropertiesNVX& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.deviceAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkTextureLODGatherFormatPropertiesAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkTextureLODGatherFormatPropertiesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkTextureLODGatherFormatPropertiesAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.supportsTextureGatherLODBiasAMD);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkShaderResourceUsageAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkShaderResourceUsageAMD& decoded_value = *data->decoded_value;
        const Decoded_VkShaderResourceUsageAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.numUsedVgprs);
        FieldToDive(data_map, decoded_value.numUsedSgprs);
        FieldToDive(data_map, decoded_value.ldsSizePerLocalWorkGroup);
        FieldToDive(data_map, decoded_value.ldsUsageSizeInBytes);
        FieldToDive(data_map, decoded_value.scratchMemUsageInBytes);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkShaderStatisticsInfoAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkShaderStatisticsInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkShaderStatisticsInfoAMD& meta_struct = *data;

        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.shaderStageMask);
        FieldToDive(data_map, meta_struct.resourceUsage);
        FieldToDive(data_map, decoded_value.numPhysicalVgprs);
        FieldToDive(data_map, decoded_value.numPhysicalSgprs);
        FieldToDive(data_map, decoded_value.numAvailableVgprs);
        FieldToDive(data_map, decoded_value.numAvailableSgprs);
        FieldToDive(data_map, &meta_struct.computeWorkGroupSize);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP* data)
{
    if (data && data->decoded_value)
    {
        const VkStreamDescriptorSurfaceCreateInfoGGP& decoded_value = *data->decoded_value;
        const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkStreamDescriptorSurfaceCreateFlagsGGP_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.streamDescriptor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCornerSampledImageFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cornerSampledImage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalImageFormatPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalImageFormatPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkExternalImageFormatPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, meta_struct.imageFormatProperties);
        FieldToDive(VkExternalMemoryFeatureFlagsNV_t(),data_map, decoded_value.externalMemoryFeatures);
        FieldToDive(VkExternalMemoryHandleTypeFlagsNV_t(),data_map, decoded_value.exportFromImportedHandleTypes);
        FieldToDive(VkExternalMemoryHandleTypeFlagsNV_t(),data_map, decoded_value.compatibleHandleTypes);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalMemoryImageCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryImageCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryImageCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalMemoryHandleTypeFlagsNV_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportMemoryAllocateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryAllocateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryAllocateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalMemoryHandleTypeFlagsNV_t(),data_map, decoded_value.handleTypes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportMemoryWin32HandleInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryWin32HandleInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryWin32HandleInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkExternalMemoryHandleTypeFlagsNV_t(),data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.handle);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExportMemoryWin32HandleInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryWin32HandleInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryWin32HandleInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pAttributes);
        FieldToDive(data_map, decoded_value.dwAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkWin32KeyedMutexAcquireReleaseInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.acquireCount);
        HandleToDive(data_map, &meta_struct.pAcquireSyncs);
        FieldToDive(data_map, meta_struct.pAcquireKeys);
        FieldToDive(data_map, meta_struct.pAcquireTimeoutMilliseconds);
        FieldToDive(data_map, decoded_value.releaseCount);
        HandleToDive(data_map, &meta_struct.pReleaseSyncs);
        FieldToDive(data_map, meta_struct.pReleaseKeys);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkValidationFlagsEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkValidationFlagsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkValidationFlagsEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.disabledValidationCheckCount);
        FieldToDive(data_map, meta_struct.pDisabledValidationChecks);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkViSurfaceCreateInfoNN* data)
{
    if (data && data->decoded_value)
    {
        const VkViSurfaceCreateInfoNN& decoded_value = *data->decoded_value;
        const Decoded_VkViSurfaceCreateInfoNN& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkViSurfaceCreateFlagsNN_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.window);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewASTCDecodeModeEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewASTCDecodeModeEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewASTCDecodeModeEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.decodeMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceASTCDecodeFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.decodeModeSharedExponent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkConditionalRenderingBeginInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkConditionalRenderingBeginInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkConditionalRenderingBeginInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(VkConditionalRenderingFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceConditionalRenderingFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.conditionalRendering);
        FieldToDive(data_map, decoded_value.inheritedConditionalRendering);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceConditionalRenderingInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.conditionalRenderingEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkViewportWScalingNV* data)
{
    if (data && data->decoded_value)
    {
        const VkViewportWScalingNV& decoded_value = *data->decoded_value;
        const Decoded_VkViewportWScalingNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.xcoeff);
        FieldToDive(data_map, decoded_value.ycoeff);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportWScalingStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportWScalingStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.viewportWScalingEnable);
        FieldToDive(data_map, decoded_value.viewportCount);
        FieldToDive(data_map, meta_struct.pViewportWScalings);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceCapabilities2EXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilities2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilities2EXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minImageCount);
        FieldToDive(data_map, decoded_value.maxImageCount);
        FieldToDive(data_map, meta_struct.currentExtent);
        FieldToDive(data_map, meta_struct.minImageExtent);
        FieldToDive(data_map, meta_struct.maxImageExtent);
        FieldToDive(data_map, decoded_value.maxImageArrayLayers);
        FieldToDive(VkSurfaceTransformFlagsKHR_t(),data_map, decoded_value.supportedTransforms);
        FieldToDive(data_map, decoded_value.currentTransform);
        FieldToDive(VkCompositeAlphaFlagsKHR_t(),data_map, decoded_value.supportedCompositeAlpha);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.supportedUsageFlags);
        FieldToDive(VkSurfaceCounterFlagsEXT_t(),data_map, decoded_value.supportedSurfaceCounters);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayPowerInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPowerInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPowerInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.powerState);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceEventInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceEventInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceEventInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceEvent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayEventInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayEventInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayEventInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.displayEvent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainCounterCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainCounterCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainCounterCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSurfaceCounterFlagsEXT_t(),data_map, decoded_value.surfaceCounters);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRefreshCycleDurationGOOGLE* data)
{
    if (data && data->decoded_value)
    {
        const VkRefreshCycleDurationGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkRefreshCycleDurationGOOGLE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.refreshDuration);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPastPresentationTimingGOOGLE* data)
{
    if (data && data->decoded_value)
    {
        const VkPastPresentationTimingGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkPastPresentationTimingGOOGLE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.presentID);
        FieldToDive(data_map, decoded_value.desiredPresentTime);
        FieldToDive(data_map, decoded_value.actualPresentTime);
        FieldToDive(data_map, decoded_value.earliestPresentTime);
        FieldToDive(data_map, decoded_value.presentMargin);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentTimeGOOGLE* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentTimeGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkPresentTimeGOOGLE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.presentID);
        FieldToDive(data_map, decoded_value.desiredPresentTime);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentTimesInfoGOOGLE* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentTimesInfoGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkPresentTimesInfoGOOGLE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainCount);
        FieldToDive(data_map, meta_struct.pTimes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.perViewPositionAllComponents);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMultiviewPerViewAttributesInfoNVX* data)
{
    if (data && data->decoded_value)
    {
        const VkMultiviewPerViewAttributesInfoNVX& decoded_value = *data->decoded_value;
        const Decoded_VkMultiviewPerViewAttributesInfoNVX& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.perViewAttributes);
        FieldToDive(data_map, decoded_value.perViewAttributesPositionXOnly);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkViewportSwizzleNV* data)
{
    if (data && data->decoded_value)
    {
        const VkViewportSwizzleNV& decoded_value = *data->decoded_value;
        const Decoded_VkViewportSwizzleNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
        FieldToDive(data_map, decoded_value.z);
        FieldToDive(data_map, decoded_value.w);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportSwizzleStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineViewportSwizzleStateCreateFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.viewportCount);
        FieldToDive(data_map, meta_struct.pViewportSwizzles);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDiscardRectanglePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxDiscardRectangles);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineDiscardRectangleStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineDiscardRectangleStateCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.discardRectangleMode);
        FieldToDive(data_map, decoded_value.discardRectangleCount);
        FieldToDive(data_map, meta_struct.pDiscardRectangles);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceConservativeRasterizationPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.primitiveOverestimationSize);
        FieldToDive(data_map, decoded_value.maxExtraPrimitiveOverestimationSize);
        FieldToDive(data_map, decoded_value.extraPrimitiveOverestimationSizeGranularity);
        FieldToDive(data_map, decoded_value.primitiveUnderestimation);
        FieldToDive(data_map, decoded_value.conservativePointAndLineRasterization);
        FieldToDive(data_map, decoded_value.degenerateTrianglesRasterized);
        FieldToDive(data_map, decoded_value.degenerateLinesRasterized);
        FieldToDive(data_map, decoded_value.fullyCoveredFragmentShaderInputVariable);
        FieldToDive(data_map, decoded_value.conservativeRasterizationPostDepthCoverage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationConservativeStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineRasterizationConservativeStateCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.conservativeRasterizationMode);
        FieldToDive(data_map, decoded_value.extraPrimitiveOverestimationSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClipEnableFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthClipEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationDepthClipStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineRasterizationDepthClipStateCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.depthClipEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkXYColorEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkXYColorEXT& decoded_value = *data->decoded_value;
        const Decoded_VkXYColorEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkHdrMetadataEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkHdrMetadataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkHdrMetadataEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.displayPrimaryRed);
        FieldToDive(data_map, meta_struct.displayPrimaryGreen);
        FieldToDive(data_map, meta_struct.displayPrimaryBlue);
        FieldToDive(data_map, meta_struct.whitePoint);
        FieldToDive(data_map, decoded_value.maxLuminance);
        FieldToDive(data_map, decoded_value.minLuminance);
        FieldToDive(data_map, decoded_value.maxContentLightLevel);
        FieldToDive(data_map, decoded_value.maxFrameAverageLightLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.relaxedLineRasterization);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIOSSurfaceCreateInfoMVK* data)
{
    if (data && data->decoded_value)
    {
        const VkIOSSurfaceCreateInfoMVK& decoded_value = *data->decoded_value;
        const Decoded_VkIOSSurfaceCreateInfoMVK& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkIOSSurfaceCreateFlagsMVK_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pView);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMacOSSurfaceCreateInfoMVK* data)
{
    if (data && data->decoded_value)
    {
        const VkMacOSSurfaceCreateInfoMVK& decoded_value = *data->decoded_value;
        const Decoded_VkMacOSSurfaceCreateInfoMVK& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkMacOSSurfaceCreateFlagsMVK_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pView);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugUtilsLabelEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsLabelEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsLabelEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.pLabelName);
        FieldToDive(data_map, &meta_struct.color);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugUtilsObjectNameInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsObjectNameInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsObjectNameInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.objectType);
        HandleToDive(data_map, meta_struct.objectHandle);
        FieldToDive(data_map, &meta_struct.pObjectName);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugUtilsMessengerCallbackDataEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsMessengerCallbackDataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsMessengerCallbackDataEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDebugUtilsMessengerCallbackDataFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, &meta_struct.pMessageIdName);
        FieldToDive(data_map, decoded_value.messageIdNumber);
        FieldToDive(data_map, &meta_struct.pMessage);
        FieldToDive(data_map, decoded_value.queueLabelCount);
        FieldToDive(data_map, meta_struct.pQueueLabels);
        FieldToDive(data_map, decoded_value.cmdBufLabelCount);
        FieldToDive(data_map, meta_struct.pCmdBufLabels);
        FieldToDive(data_map, decoded_value.objectCount);
        FieldToDive(data_map, meta_struct.pObjects);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugUtilsMessengerCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsMessengerCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsMessengerCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDebugUtilsMessengerCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(VkDebugUtilsMessageSeverityFlagsEXT_t(),data_map, decoded_value.messageSeverity);
        FieldToDive(VkDebugUtilsMessageTypeFlagsEXT_t(),data_map, decoded_value.messageType);
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnUserCallback));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pUserData));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDebugUtilsObjectTagInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsObjectTagInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsObjectTagInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.objectType);
        HandleToDive(data_map, meta_struct.objectHandle);
        FieldToDive(data_map, decoded_value.tagName);
        FieldToDive(data_map, decoded_value.tagSize);
        FieldToDive(data_map, meta_struct.pTag);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAndroidHardwareBufferUsageANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferUsageANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferUsageANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.androidHardwareBufferUsage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAndroidHardwareBufferPropertiesANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferPropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferPropertiesANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.allocationSize);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferFormatPropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.externalFormat);
        FieldToDive(VkFormatFeatureFlags_t(),data_map, decoded_value.formatFeatures);
        FieldToDive(data_map, meta_struct.samplerYcbcrConversionComponents);
        FieldToDive(data_map, decoded_value.suggestedYcbcrModel);
        FieldToDive(data_map, decoded_value.suggestedYcbcrRange);
        FieldToDive(data_map, decoded_value.suggestedXChromaOffset);
        FieldToDive(data_map, decoded_value.suggestedYChromaOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportAndroidHardwareBufferInfoANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkImportAndroidHardwareBufferInfoANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkImportAndroidHardwareBufferInfoANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetAndroidHardwareBufferInfoANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalFormatANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalFormatANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkExternalFormatANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.externalFormat);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferFormatProperties2ANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.externalFormat);
        FieldToDive(VkFormatFeatureFlags2_t(),data_map, decoded_value.formatFeatures);
        FieldToDive(data_map, meta_struct.samplerYcbcrConversionComponents);
        FieldToDive(data_map, decoded_value.suggestedYcbcrModel);
        FieldToDive(data_map, decoded_value.suggestedYcbcrRange);
        FieldToDive(data_map, decoded_value.suggestedXChromaOffset);
        FieldToDive(data_map, decoded_value.suggestedYChromaOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentSampleCountInfoAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentSampleCountInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentSampleCountInfoAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.colorAttachmentCount);
        FieldToDive(data_map, meta_struct.pColorAttachmentSamples);
        FieldToDive(data_map, decoded_value.depthStencilAttachmentSamples);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSampleLocationEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSampleLocationEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSampleLocationEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.x);
        FieldToDive(data_map, decoded_value.y);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSampleLocationsInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSampleLocationsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSampleLocationsInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.sampleLocationsPerPixel);
        FieldToDive(data_map, meta_struct.sampleLocationGridSize);
        FieldToDive(data_map, decoded_value.sampleLocationsCount);
        FieldToDive(data_map, meta_struct.pSampleLocations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAttachmentSampleLocationsEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentSampleLocationsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentSampleLocationsEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.attachmentIndex);
        FieldToDive(data_map, meta_struct.sampleLocationsInfo);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassSampleLocationsEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassSampleLocationsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassSampleLocationsEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.subpassIndex);
        FieldToDive(data_map, meta_struct.sampleLocationsInfo);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassSampleLocationsBeginInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassSampleLocationsBeginInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachmentInitialSampleLocationsCount);
        FieldToDive(data_map, meta_struct.pAttachmentInitialSampleLocations);
        FieldToDive(data_map, decoded_value.postSubpassSampleLocationsCount);
        FieldToDive(data_map, meta_struct.pPostSubpassSampleLocations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineSampleLocationsStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.sampleLocationsEnable);
        FieldToDive(data_map, meta_struct.sampleLocationsInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSampleLocationsPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.sampleLocationSampleCounts);
        FieldToDive(data_map, meta_struct.maxSampleLocationGridSize);
        FieldToDive(data_map, &meta_struct.sampleLocationCoordinateRange);
        FieldToDive(data_map, decoded_value.sampleLocationSubPixelBits);
        FieldToDive(data_map, decoded_value.variableSampleLocations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMultisamplePropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMultisamplePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultisamplePropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.maxSampleLocationGridSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.advancedBlendCoherentOperations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.advancedBlendMaxColorAttachments);
        FieldToDive(data_map, decoded_value.advancedBlendIndependentBlend);
        FieldToDive(data_map, decoded_value.advancedBlendNonPremultipliedSrcColor);
        FieldToDive(data_map, decoded_value.advancedBlendNonPremultipliedDstColor);
        FieldToDive(data_map, decoded_value.advancedBlendCorrelatedOverlap);
        FieldToDive(data_map, decoded_value.advancedBlendAllOperations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorBlendAdvancedStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.srcPremultiplied);
        FieldToDive(data_map, decoded_value.dstPremultiplied);
        FieldToDive(data_map, decoded_value.blendOverlap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCoverageToColorStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCoverageToColorStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCoverageToColorStateCreateFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.coverageToColorEnable);
        FieldToDive(data_map, decoded_value.coverageToColorLocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCoverageModulationStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCoverageModulationStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCoverageModulationStateCreateFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.coverageModulationMode);
        FieldToDive(data_map, decoded_value.coverageModulationTableEnable);
        FieldToDive(data_map, decoded_value.coverageModulationTableCount);
        FieldToDive(data_map, meta_struct.pCoverageModulationTable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderSMCount);
        FieldToDive(data_map, decoded_value.shaderWarpsPerSM);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderSMBuiltins);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrmFormatModifierPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.drmFormatModifier);
        FieldToDive(data_map, decoded_value.drmFormatModifierPlaneCount);
        FieldToDive(VkFormatFeatureFlags_t(),data_map, decoded_value.drmFormatModifierTilingFeatures);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrmFormatModifierPropertiesListEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierPropertiesListEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierPropertiesListEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.drmFormatModifierCount);
        FieldToDive(data_map, meta_struct.pDrmFormatModifierProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageDrmFormatModifierInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.drmFormatModifier);
        FieldToDive(data_map, decoded_value.sharingMode);
        FieldToDive(data_map, decoded_value.queueFamilyIndexCount);
        FieldToDive(data_map, meta_struct.pQueueFamilyIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageDrmFormatModifierListCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageDrmFormatModifierListCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.drmFormatModifierCount);
        FieldToDive(data_map, meta_struct.pDrmFormatModifiers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageDrmFormatModifierExplicitCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.drmFormatModifier);
        FieldToDive(data_map, decoded_value.drmFormatModifierPlaneCount);
        FieldToDive(data_map, meta_struct.pPlaneLayouts);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageDrmFormatModifierPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageDrmFormatModifierPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageDrmFormatModifierPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.drmFormatModifier);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrmFormatModifierProperties2EXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierProperties2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierProperties2EXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.drmFormatModifier);
        FieldToDive(data_map, decoded_value.drmFormatModifierPlaneCount);
        FieldToDive(VkFormatFeatureFlags2_t(),data_map, decoded_value.drmFormatModifierTilingFeatures);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrmFormatModifierPropertiesList2EXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierPropertiesList2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierPropertiesList2EXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.drmFormatModifierCount);
        FieldToDive(data_map, meta_struct.pDrmFormatModifierProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkValidationCacheCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkValidationCacheCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkValidationCacheCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkValidationCacheCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.initialDataSize);
        FieldToDive(data_map, meta_struct.pInitialData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkShaderModuleValidationCacheCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkShaderModuleValidationCacheCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.validationCache);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkShadingRatePaletteNV* data)
{
    if (data && data->decoded_value)
    {
        const VkShadingRatePaletteNV& decoded_value = *data->decoded_value;
        const Decoded_VkShadingRatePaletteNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.shadingRatePaletteEntryCount);
        FieldToDive(data_map, meta_struct.pShadingRatePaletteEntries);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportShadingRateImageStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shadingRateImageEnable);
        FieldToDive(data_map, decoded_value.viewportCount);
        FieldToDive(data_map, meta_struct.pShadingRatePalettes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShadingRateImageFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shadingRateImage);
        FieldToDive(data_map, decoded_value.shadingRateCoarseSampleOrder);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShadingRateImagePropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.shadingRateTexelSize);
        FieldToDive(data_map, decoded_value.shadingRatePaletteSize);
        FieldToDive(data_map, decoded_value.shadingRateMaxCoarseSamples);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCoarseSampleLocationNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCoarseSampleLocationNV& decoded_value = *data->decoded_value;
        const Decoded_VkCoarseSampleLocationNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.pixelX);
        FieldToDive(data_map, decoded_value.pixelY);
        FieldToDive(data_map, decoded_value.sample);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCoarseSampleOrderCustomNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCoarseSampleOrderCustomNV& decoded_value = *data->decoded_value;
        const Decoded_VkCoarseSampleOrderCustomNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.shadingRate);
        FieldToDive(data_map, decoded_value.sampleCount);
        FieldToDive(data_map, decoded_value.sampleLocationCount);
        FieldToDive(data_map, meta_struct.pSampleLocations);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.sampleOrderType);
        FieldToDive(data_map, decoded_value.customSampleOrderCount);
        FieldToDive(data_map, meta_struct.pCustomSampleOrders);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRayTracingShaderGroupCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingShaderGroupCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingShaderGroupCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.generalShader);
        FieldToDive(data_map, decoded_value.closestHitShader);
        FieldToDive(data_map, decoded_value.anyHitShader);
        FieldToDive(data_map, decoded_value.intersectionShader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRayTracingPipelineCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingPipelineCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingPipelineCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.stageCount);
        FieldToDive(data_map, meta_struct.pStages);
        FieldToDive(data_map, decoded_value.groupCount);
        FieldToDive(data_map, meta_struct.pGroups);
        FieldToDive(data_map, decoded_value.maxRecursionDepth);
        HandleToDive(data_map, meta_struct.layout);
        HandleToDive(data_map, meta_struct.basePipelineHandle);
        FieldToDive(data_map, decoded_value.basePipelineIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeometryTrianglesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGeometryTrianglesNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryTrianglesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.vertexData);
        FieldToDive(data_map, decoded_value.vertexOffset);
        FieldToDive(data_map, decoded_value.vertexCount);
        FieldToDive(data_map, decoded_value.vertexStride);
        FieldToDive(data_map, decoded_value.vertexFormat);
        HandleToDive(data_map, meta_struct.indexData);
        FieldToDive(data_map, decoded_value.indexOffset);
        FieldToDive(data_map, decoded_value.indexCount);
        FieldToDive(data_map, decoded_value.indexType);
        HandleToDive(data_map, meta_struct.transformData);
        FieldToDive(data_map, decoded_value.transformOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeometryAABBNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGeometryAABBNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryAABBNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.aabbData);
        FieldToDive(data_map, decoded_value.numAABBs);
        FieldToDive(data_map, decoded_value.stride);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeometryDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGeometryDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryDataNV& meta_struct = *data;

        FieldToDive(data_map, meta_struct.triangles);
        FieldToDive(data_map, meta_struct.aabbs);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeometryNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGeometryNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.geometryType);
        FieldToDive(data_map, meta_struct.geometry);
        FieldToDive(VkGeometryFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(VkBuildAccelerationStructureFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.instanceCount);
        FieldToDive(data_map, decoded_value.geometryCount);
        FieldToDive(data_map, meta_struct.pGeometries);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.compactedSize);
        FieldToDive(data_map, meta_struct.info);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindAccelerationStructureMemoryInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBindAccelerationStructureMemoryInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindAccelerationStructureMemoryInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.accelerationStructure);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.memoryOffset);
        FieldToDive(data_map, decoded_value.deviceIndexCount);
        FieldToDive(data_map, meta_struct.pDeviceIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWriteDescriptorSetAccelerationStructureNV* data)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetAccelerationStructureNV& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetAccelerationStructureNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.accelerationStructureCount);
        HandleToDive(data_map, &meta_struct.pAccelerationStructures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureMemoryRequirementsInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        HandleToDive(data_map, meta_struct.accelerationStructure);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderGroupHandleSize);
        FieldToDive(data_map, decoded_value.maxRecursionDepth);
        FieldToDive(data_map, decoded_value.maxShaderGroupStride);
        FieldToDive(data_map, decoded_value.shaderGroupBaseAlignment);
        FieldToDive(data_map, decoded_value.maxGeometryCount);
        FieldToDive(data_map, decoded_value.maxInstanceCount);
        FieldToDive(data_map, decoded_value.maxTriangleCount);
        FieldToDive(data_map, decoded_value.maxDescriptorSetAccelerationStructures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkTransformMatrixKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkTransformMatrixKHR& decoded_value = *data->decoded_value;
        const Decoded_VkTransformMatrixKHR& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.matrix);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAabbPositionsKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAabbPositionsKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAabbPositionsKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.minX);
        FieldToDive(data_map, decoded_value.minY);
        FieldToDive(data_map, decoded_value.minZ);
        FieldToDive(data_map, decoded_value.maxX);
        FieldToDive(data_map, decoded_value.maxY);
        FieldToDive(data_map, decoded_value.maxZ);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureInstanceKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureInstanceKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureInstanceKHR& meta_struct = *data;

        FieldToDive(data_map, meta_struct.transform);
        FieldToDive(data_map, decoded_value.instanceCustomIndex);
        FieldToDive(data_map, decoded_value.mask);
        FieldToDive(data_map, decoded_value.instanceShaderBindingTableRecordOffset);
        FieldToDive(VkGeometryInstanceFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.accelerationStructureReference);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.representativeFragmentTest);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRepresentativeFragmentTestStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.representativeFragmentTestEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageViewImageFormatInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imageViewType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkFilterCubicImageViewImageFormatPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.filterCubic);
        FieldToDive(data_map, decoded_value.filterCubicMinmax);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportMemoryHostPointerInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryHostPointerInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryHostPointerInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pHostPointer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryHostPointerPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryHostPointerPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryHostPointerPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalMemoryHostPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minImportedHostPointerAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCompilerControlCreateInfoAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCompilerControlCreateInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCompilerControlCreateInfoAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCompilerControlFlagsAMD_t(),data_map, decoded_value.compilerControlFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCorePropertiesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderEngineCount);
        FieldToDive(data_map, decoded_value.shaderArraysPerEngineCount);
        FieldToDive(data_map, decoded_value.computeUnitsPerShaderArray);
        FieldToDive(data_map, decoded_value.simdPerComputeUnit);
        FieldToDive(data_map, decoded_value.wavefrontsPerSimd);
        FieldToDive(data_map, decoded_value.wavefrontSize);
        FieldToDive(data_map, decoded_value.sgprsPerSimd);
        FieldToDive(data_map, decoded_value.minSgprAllocation);
        FieldToDive(data_map, decoded_value.maxSgprAllocation);
        FieldToDive(data_map, decoded_value.sgprAllocationGranularity);
        FieldToDive(data_map, decoded_value.vgprsPerSimd);
        FieldToDive(data_map, decoded_value.minVgprAllocation);
        FieldToDive(data_map, decoded_value.maxVgprAllocation);
        FieldToDive(data_map, decoded_value.vgprAllocationGranularity);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceMemoryOverallocationCreateInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.overallocationBehavior);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxVertexAttribDivisor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPresentFrameTokenGGP* data)
{
    if (data && data->decoded_value)
    {
        const VkPresentFrameTokenGGP& decoded_value = *data->decoded_value;
        const Decoded_VkPresentFrameTokenGGP& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.frameToken);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.taskShader);
        FieldToDive(data_map, decoded_value.meshShader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxDrawMeshTasksCount);
        FieldToDive(data_map, decoded_value.maxTaskWorkGroupInvocations);
        FieldToDive(data_map, &meta_struct.maxTaskWorkGroupSize);
        FieldToDive(data_map, decoded_value.maxTaskTotalMemorySize);
        FieldToDive(data_map, decoded_value.maxTaskOutputCount);
        FieldToDive(data_map, decoded_value.maxMeshWorkGroupInvocations);
        FieldToDive(data_map, &meta_struct.maxMeshWorkGroupSize);
        FieldToDive(data_map, decoded_value.maxMeshTotalMemorySize);
        FieldToDive(data_map, decoded_value.maxMeshOutputVertices);
        FieldToDive(data_map, decoded_value.maxMeshOutputPrimitives);
        FieldToDive(data_map, decoded_value.maxMeshMultiviewViewCount);
        FieldToDive(data_map, decoded_value.meshOutputPerVertexGranularity);
        FieldToDive(data_map, decoded_value.meshOutputPerPrimitiveGranularity);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrawMeshTasksIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDrawMeshTasksIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkDrawMeshTasksIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.taskCount);
        FieldToDive(data_map, decoded_value.firstTask);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderImageFootprintFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imageFootprint);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportExclusiveScissorStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.exclusiveScissorCount);
        FieldToDive(data_map, meta_struct.pExclusiveScissors);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExclusiveScissorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.exclusiveScissor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyCheckpointPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyCheckpointPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyCheckpointPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineStageFlags_t(),data_map, decoded_value.checkpointExecutionStageMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCheckpointDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCheckpointDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkCheckpointDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stage);
        FieldToDive(data_map, meta_struct.pCheckpointMarker);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueueFamilyCheckpointProperties2NV* data)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyCheckpointProperties2NV& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyCheckpointProperties2NV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.checkpointExecutionStageMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCheckpointData2NV* data)
{
    if (data && data->decoded_value)
    {
        const VkCheckpointData2NV& decoded_value = *data->decoded_value;
        const Decoded_VkCheckpointData2NV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineStageFlags2_t(),data_map, decoded_value.stage);
        FieldToDive(data_map, meta_struct.pCheckpointMarker);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderIntegerFunctions2);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkInitializePerformanceApiInfoINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkInitializePerformanceApiInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkInitializePerformanceApiInfoINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pUserData));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolPerformanceQueryCreateInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.performanceCountersSampling);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceMarkerInfoINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceMarkerInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceMarkerInfoINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.marker);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceStreamMarkerInfoINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceStreamMarkerInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceStreamMarkerInfoINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.marker);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceOverrideInfoINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceOverrideInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceOverrideInfoINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.enable);
        FieldToDive(data_map, decoded_value.parameter);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL* data)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceConfigurationAcquireInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceConfigurationAcquireInfoINTEL& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePCIBusInfoPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pciDomain);
        FieldToDive(data_map, decoded_value.pciBus);
        FieldToDive(data_map, decoded_value.pciDevice);
        FieldToDive(data_map, decoded_value.pciFunction);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayNativeHdrSurfaceCapabilitiesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.localDimmingSupport);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainDisplayNativeHdrCreateInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.localDimmingEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA* data)
{
    if (data && data->decoded_value)
    {
        const VkImagePipeSurfaceCreateInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImagePipeSurfaceCreateFlagsFUCHSIA_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.imagePipeHandle);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMetalSurfaceCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMetalSurfaceCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMetalSurfaceCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkMetalSurfaceCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pLayer);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentDensityMap);
        FieldToDive(data_map, decoded_value.fragmentDensityMapDynamic);
        FieldToDive(data_map, decoded_value.fragmentDensityMapNonSubsampledImages);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.minFragmentDensityTexelSize);
        FieldToDive(data_map, meta_struct.maxFragmentDensityTexelSize);
        FieldToDive(data_map, decoded_value.fragmentDensityInvocations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassFragmentDensityMapCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.fragmentDensityMapAttachment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderingFragmentDensityMapAttachmentInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.imageView);
        FieldToDive(data_map, decoded_value.imageLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCoreProperties2AMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderCorePropertiesFlagsAMD_t(),data_map, decoded_value.shaderCoreFeatures);
        FieldToDive(data_map, decoded_value.activeComputeUnitCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCoherentMemoryFeaturesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceCoherentMemory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderImageInt64Atomics);
        FieldToDive(data_map, decoded_value.sparseImageInt64Atomics);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryBudgetPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.heapBudget);
        FieldToDive(data_map, &meta_struct.heapUsage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryPriorityFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryPriority);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryPriorityAllocateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryPriorityAllocateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryPriorityAllocateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.priority);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dedicatedAllocationImageAliasing);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.bufferDeviceAddress);
        FieldToDive(data_map, decoded_value.bufferDeviceAddressCaptureReplay);
        FieldToDive(data_map, decoded_value.bufferDeviceAddressMultiDevice);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBufferDeviceAddressCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkBufferDeviceAddressCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBufferDeviceAddressCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.deviceAddress));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkValidationFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkValidationFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkValidationFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.enabledValidationFeatureCount);
        FieldToDive(data_map, meta_struct.pEnabledValidationFeatures);
        FieldToDive(data_map, decoded_value.disabledValidationFeatureCount);
        FieldToDive(data_map, meta_struct.pDisabledValidationFeatures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCooperativeMatrixPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeMatrixPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeMatrixPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.MSize);
        FieldToDive(data_map, decoded_value.NSize);
        FieldToDive(data_map, decoded_value.KSize);
        FieldToDive(data_map, decoded_value.AType);
        FieldToDive(data_map, decoded_value.BType);
        FieldToDive(data_map, decoded_value.CType);
        FieldToDive(data_map, decoded_value.DType);
        FieldToDive(data_map, decoded_value.scope);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cooperativeMatrix);
        FieldToDive(data_map, decoded_value.cooperativeMatrixRobustBufferAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.cooperativeMatrixSupportedStages);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCoverageReductionModeFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.coverageReductionMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCoverageReductionStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCoverageReductionStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCoverageReductionStateCreateFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.coverageReductionMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFramebufferMixedSamplesCombinationNV* data)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferMixedSamplesCombinationNV& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferMixedSamplesCombinationNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.coverageReductionMode);
        FieldToDive(data_map, decoded_value.rasterizationSamples);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.depthStencilSamples);
        FieldToDive(VkSampleCountFlags_t(),data_map, decoded_value.colorSamples);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentShaderSampleInterlock);
        FieldToDive(data_map, decoded_value.fragmentShaderPixelInterlock);
        FieldToDive(data_map, decoded_value.fragmentShaderShadingRateInterlock);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.ycbcrImageArrays);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProvokingVertexFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.provokingVertexLast);
        FieldToDive(data_map, decoded_value.transformFeedbackPreservesProvokingVertex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProvokingVertexPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.provokingVertexModePerPipeline);
        FieldToDive(data_map, decoded_value.transformFeedbackPreservesTriangleFanProvokingVertex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.provokingVertexMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFullScreenExclusiveInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFullScreenExclusiveInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fullScreenExclusive);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesFullScreenExclusiveEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fullScreenExclusiveSupported);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFullScreenExclusiveWin32InfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.hmonitor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkHeadlessSurfaceCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkHeadlessSurfaceCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkHeadlessSurfaceCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkHeadlessSurfaceCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderBufferFloat32Atomics);
        FieldToDive(data_map, decoded_value.shaderBufferFloat32AtomicAdd);
        FieldToDive(data_map, decoded_value.shaderBufferFloat64Atomics);
        FieldToDive(data_map, decoded_value.shaderBufferFloat64AtomicAdd);
        FieldToDive(data_map, decoded_value.shaderSharedFloat32Atomics);
        FieldToDive(data_map, decoded_value.shaderSharedFloat32AtomicAdd);
        FieldToDive(data_map, decoded_value.shaderSharedFloat64Atomics);
        FieldToDive(data_map, decoded_value.shaderSharedFloat64AtomicAdd);
        FieldToDive(data_map, decoded_value.shaderImageFloat32Atomics);
        FieldToDive(data_map, decoded_value.shaderImageFloat32AtomicAdd);
        FieldToDive(data_map, decoded_value.sparseImageFloat32Atomics);
        FieldToDive(data_map, decoded_value.sparseImageFloat32AtomicAdd);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.extendedDynamicState);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryMapPlaced);
        FieldToDive(data_map, decoded_value.memoryMapRangePlaced);
        FieldToDive(data_map, decoded_value.memoryUnmapReserve);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minPlacedMemoryMapAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryMapPlacedInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryMapPlacedInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryMapPlacedInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pPlacedAddress);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderBufferFloat16Atomics);
        FieldToDive(data_map, decoded_value.shaderBufferFloat16AtomicAdd);
        FieldToDive(data_map, decoded_value.shaderBufferFloat16AtomicMinMax);
        FieldToDive(data_map, decoded_value.shaderBufferFloat32AtomicMinMax);
        FieldToDive(data_map, decoded_value.shaderBufferFloat64AtomicMinMax);
        FieldToDive(data_map, decoded_value.shaderSharedFloat16Atomics);
        FieldToDive(data_map, decoded_value.shaderSharedFloat16AtomicAdd);
        FieldToDive(data_map, decoded_value.shaderSharedFloat16AtomicMinMax);
        FieldToDive(data_map, decoded_value.shaderSharedFloat32AtomicMinMax);
        FieldToDive(data_map, decoded_value.shaderSharedFloat64AtomicMinMax);
        FieldToDive(data_map, decoded_value.shaderImageFloat32AtomicMinMax);
        FieldToDive(data_map, decoded_value.sparseImageFloat32AtomicMinMax);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfacePresentModeEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfacePresentModeEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfacePresentModeEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfacePresentScalingCapabilitiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfacePresentScalingCapabilitiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfacePresentScalingCapabilitiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPresentScalingFlagsEXT_t(),data_map, decoded_value.supportedPresentScaling);
        FieldToDive(VkPresentGravityFlagsEXT_t(),data_map, decoded_value.supportedPresentGravityX);
        FieldToDive(VkPresentGravityFlagsEXT_t(),data_map, decoded_value.supportedPresentGravityY);
        FieldToDive(data_map, meta_struct.minScaledImageExtent);
        FieldToDive(data_map, meta_struct.maxScaledImageExtent);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfacePresentModeCompatibilityEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfacePresentModeCompatibilityEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfacePresentModeCompatibilityEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentModeCount);
        FieldToDive(data_map, meta_struct.pPresentModes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainMaintenance1);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainPresentFenceInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentFenceInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentFenceInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainCount);
        HandleToDive(data_map, &meta_struct.pFences);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainPresentModesCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentModesCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentModesCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentModeCount);
        FieldToDive(data_map, meta_struct.pPresentModes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainPresentModeInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentModeInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentModeInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.swapchainCount);
        FieldToDive(data_map, meta_struct.pPresentModes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainPresentScalingCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentScalingCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentScalingCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPresentScalingFlagsEXT_t(),data_map, decoded_value.scalingBehavior);
        FieldToDive(VkPresentGravityFlagsEXT_t(),data_map, decoded_value.presentGravityX);
        FieldToDive(VkPresentGravityFlagsEXT_t(),data_map, decoded_value.presentGravityY);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkReleaseSwapchainImagesInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkReleaseSwapchainImagesInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkReleaseSwapchainImagesInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.swapchain);
        FieldToDive(data_map, decoded_value.imageIndexCount);
        FieldToDive(data_map, meta_struct.pImageIndices);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxGraphicsShaderGroupCount);
        FieldToDive(data_map, decoded_value.maxIndirectSequenceCount);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsTokenCount);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsStreamCount);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsTokenOffset);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsStreamStride);
        FieldToDive(data_map, decoded_value.minSequencesCountBufferOffsetAlignment);
        FieldToDive(data_map, decoded_value.minSequencesIndexBufferOffsetAlignment);
        FieldToDive(data_map, decoded_value.minIndirectCommandsBufferOffsetAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceGeneratedCommands);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGraphicsShaderGroupCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsShaderGroupCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsShaderGroupCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stageCount);
        FieldToDive(data_map, meta_struct.pStages);
        FieldToDive(data_map, meta_struct.pVertexInputState);
        FieldToDive(data_map, meta_struct.pTessellationState);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsPipelineShaderGroupsCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.groupCount);
        FieldToDive(data_map, meta_struct.pGroups);
        FieldToDive(data_map, decoded_value.pipelineCount);
        HandleToDive(data_map, &meta_struct.pPipelines);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindShaderGroupIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBindShaderGroupIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindShaderGroupIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.groupIndex);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindIndexBufferIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBindIndexBufferIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindIndexBufferIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.bufferAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.indexType);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindVertexBufferIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBindVertexBufferIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindVertexBufferIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.bufferAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.stride);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSetStateFlagsIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSetStateFlagsIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkSetStateFlagsIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.data);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsStreamNV* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsStreamNV& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsStreamNV& meta_struct = *data;

        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsLayoutTokenNV* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsLayoutTokenNV& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsLayoutTokenNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.tokenType);
        FieldToDive(data_map, decoded_value.stream);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.vertexBindingUnit);
        FieldToDive(data_map, decoded_value.vertexDynamicStride);
        HandleToDive(data_map, meta_struct.pushconstantPipelineLayout);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.pushconstantShaderStageFlags);
        FieldToDive(data_map, decoded_value.pushconstantOffset);
        FieldToDive(data_map, decoded_value.pushconstantSize);
        FieldToDive(VkIndirectStateFlagsNV_t(),data_map, decoded_value.indirectStateFlags);
        FieldToDive(data_map, decoded_value.indexTypeCount);
        FieldToDive(data_map, meta_struct.pIndexTypes);
        FieldToDive(data_map, meta_struct.pIndexTypeValues);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsLayoutCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsLayoutCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsLayoutCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkIndirectCommandsLayoutUsageFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        FieldToDive(data_map, decoded_value.tokenCount);
        FieldToDive(data_map, meta_struct.pTokens);
        FieldToDive(data_map, decoded_value.streamCount);
        FieldToDive(data_map, meta_struct.pStreamStrides);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeneratedCommandsInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        HandleToDive(data_map, meta_struct.pipeline);
        HandleToDive(data_map, meta_struct.indirectCommandsLayout);
        FieldToDive(data_map, decoded_value.streamCount);
        FieldToDive(data_map, meta_struct.pStreams);
        FieldToDive(data_map, decoded_value.sequencesCount);
        HandleToDive(data_map, meta_struct.preprocessBuffer);
        FieldToDive(data_map, decoded_value.preprocessOffset);
        FieldToDive(data_map, decoded_value.preprocessSize);
        HandleToDive(data_map, meta_struct.sequencesCountBuffer);
        FieldToDive(data_map, decoded_value.sequencesCountOffset);
        HandleToDive(data_map, meta_struct.sequencesIndexBuffer);
        FieldToDive(data_map, decoded_value.sequencesIndexOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsMemoryRequirementsInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        HandleToDive(data_map, meta_struct.pipeline);
        HandleToDive(data_map, meta_struct.indirectCommandsLayout);
        FieldToDive(data_map, decoded_value.maxSequencesCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInheritedViewportScissorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.inheritedViewportScissor2D);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceViewportScissorInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.viewportScissor2D);
        FieldToDive(data_map, decoded_value.viewportDepthCount);
        FieldToDive(data_map, meta_struct.pViewportDepths);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.texelBufferAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassTransformBeginInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassTransformBeginInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassTransformBeginInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.transform);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceRenderPassTransformInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.transform);
        FieldToDive(data_map, meta_struct.renderArea);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthBiasControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthBiasControl);
        FieldToDive(data_map, decoded_value.leastRepresentableValueForceUnormRepresentation);
        FieldToDive(data_map, decoded_value.floatRepresentation);
        FieldToDive(data_map, decoded_value.depthBiasExact);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDepthBiasInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDepthBiasInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDepthBiasInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthBiasConstantFactor);
        FieldToDive(data_map, decoded_value.depthBiasClamp);
        FieldToDive(data_map, decoded_value.depthBiasSlopeFactor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDepthBiasRepresentationInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDepthBiasRepresentationInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDepthBiasRepresentationInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthBiasRepresentation);
        FieldToDive(data_map, decoded_value.depthBiasExact);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceMemoryReport);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceMemoryReportCallbackDataEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceMemoryReportCallbackDataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceMemoryReportCallbackDataEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceMemoryReportFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.memoryObjectId);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.objectType);
        FieldToDive(data_map, decoded_value.objectHandle);
        FieldToDive(data_map, decoded_value.heapIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceDeviceMemoryReportCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceMemoryReportFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnUserCallback));
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pUserData));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRobustness2FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRobustness2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRobustness2FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.robustBufferAccess2);
        FieldToDive(data_map, decoded_value.robustImageAccess2);
        FieldToDive(data_map, decoded_value.nullDescriptor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRobustness2PropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRobustness2PropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRobustness2PropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.robustStorageBufferAccessSizeAlignment);
        FieldToDive(data_map, decoded_value.robustUniformBufferAccessSizeAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerCustomBorderColorCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerCustomBorderColorCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerCustomBorderColorCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.customBorderColor);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCustomBorderColorPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxCustomBorderColorSamplers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCustomBorderColorFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.customBorderColors);
        FieldToDive(data_map, decoded_value.customBorderColorWithoutFormat);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentBarrierFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentBarrier);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSurfaceCapabilitiesPresentBarrierNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesPresentBarrierNV& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesPresentBarrierNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentBarrierSupported);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainPresentBarrierCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentBarrierCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentBarrierCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentBarrierEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDiagnosticsConfigFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.diagnosticsConfig);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceDiagnosticsConfigCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceDiagnosticsConfigFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkQueryLowLatencySupportNV* data)
{
    if (data && data->decoded_value)
    {
        const VkQueryLowLatencySupportNV& decoded_value = *data->decoded_value;
        const Decoded_VkQueryLowLatencySupportNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pQueriedLowLatencyData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.graphicsPipelineLibrary);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.graphicsPipelineLibraryFastLinking);
        FieldToDive(data_map, decoded_value.graphicsPipelineLibraryIndependentInterpolationDecoration);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsPipelineLibraryCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkGraphicsPipelineLibraryFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderEarlyAndLateFragmentTests);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentShadingRateEnums);
        FieldToDive(data_map, decoded_value.supersampleFragmentShadingRates);
        FieldToDive(data_map, decoded_value.noInvocationFragmentShadingRates);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxFragmentShadingRateInvocationCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineFragmentShadingRateEnumStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shadingRateType);
        FieldToDive(data_map, decoded_value.shadingRate);
        FieldToDive(data_map, &meta_struct.combinerOps);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryMotionTrianglesDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.vertexData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureMotionInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureMotionInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureMotionInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxInstances);
        FieldToDive(VkAccelerationStructureMotionInfoFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureMatrixMotionInstanceNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureMatrixMotionInstanceNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureMatrixMotionInstanceNV& meta_struct = *data;

        FieldToDive(data_map, meta_struct.transformT0);
        FieldToDive(data_map, meta_struct.transformT1);
        FieldToDive(data_map, decoded_value.instanceCustomIndex);
        FieldToDive(data_map, decoded_value.mask);
        FieldToDive(data_map, decoded_value.instanceShaderBindingTableRecordOffset);
        FieldToDive(VkGeometryInstanceFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.accelerationStructureReference);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSRTDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSRTDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkSRTDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sx);
        FieldToDive(data_map, decoded_value.a);
        FieldToDive(data_map, decoded_value.b);
        FieldToDive(data_map, decoded_value.pvx);
        FieldToDive(data_map, decoded_value.sy);
        FieldToDive(data_map, decoded_value.c);
        FieldToDive(data_map, decoded_value.pvy);
        FieldToDive(data_map, decoded_value.sz);
        FieldToDive(data_map, decoded_value.pvz);
        FieldToDive(data_map, decoded_value.qx);
        FieldToDive(data_map, decoded_value.qy);
        FieldToDive(data_map, decoded_value.qz);
        FieldToDive(data_map, decoded_value.qw);
        FieldToDive(data_map, decoded_value.tx);
        FieldToDive(data_map, decoded_value.ty);
        FieldToDive(data_map, decoded_value.tz);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureSRTMotionInstanceNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureSRTMotionInstanceNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureSRTMotionInstanceNV& meta_struct = *data;

        FieldToDive(data_map, meta_struct.transformT0);
        FieldToDive(data_map, meta_struct.transformT1);
        FieldToDive(data_map, decoded_value.instanceCustomIndex);
        FieldToDive(data_map, decoded_value.mask);
        FieldToDive(data_map, decoded_value.instanceShaderBindingTableRecordOffset);
        FieldToDive(VkGeometryInstanceFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.accelerationStructureReference);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingMotionBlur);
        FieldToDive(data_map, decoded_value.rayTracingMotionBlurPipelineTraceRaysIndirect);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.ycbcr2plane444Formats);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentDensityMapDeferred);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.subsampledLoads);
        FieldToDive(data_map, decoded_value.subsampledCoarseReconstructionEarlyAccess);
        FieldToDive(data_map, decoded_value.maxSubsampledArrayLayers);
        FieldToDive(data_map, decoded_value.maxDescriptorSetSubsampledSamplers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyCommandTransformInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyCommandTransformInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkCopyCommandTransformInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.transform);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageCompressionControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imageCompressionControl);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageCompressionControlEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageCompressionControlEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageCompressionControlEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageCompressionFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.compressionControlPlaneCount);
        FieldToDive(data_map, meta_struct.pFixedRateFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageCompressionPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageCompressionPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageCompressionPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkImageCompressionFlagsEXT_t(),data_map, decoded_value.imageCompressionFlags);
        FieldToDive(VkImageCompressionFixedRateFlagsEXT_t(),data_map, decoded_value.imageCompressionFixedRateFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachmentFeedbackLoopLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevice4444FormatsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.formatA4R4G4B4);
        FieldToDive(data_map, decoded_value.formatA4B4G4R4);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFaultFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFaultFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFaultFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceFault);
        FieldToDive(data_map, decoded_value.deviceFaultVendorBinary);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceFaultCountsEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultCountsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultCountsEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.addressInfoCount);
        FieldToDive(data_map, decoded_value.vendorInfoCount);
        FieldToDive(data_map, decoded_value.vendorBinarySize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceFaultAddressInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultAddressInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultAddressInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.addressType);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.reportedAddress));
        FieldToDive(data_map, decoded_value.addressPrecision);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceFaultVendorInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultVendorInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultVendorInfoEXT& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, decoded_value.vendorFaultCode);
        FieldToDive(data_map, decoded_value.vendorFaultData);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceFaultInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, meta_struct.pAddressInfos);
        FieldToDive(data_map, meta_struct.pVendorInfos);
        FieldToDive(data_map, meta_struct.pVendorBinaryData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultVendorBinaryHeaderVersionOneEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.headerSize);
        FieldToDive(data_map, decoded_value.headerVersion);
        FieldToDive(data_map, decoded_value.vendorID);
        FieldToDive(data_map, decoded_value.deviceID);
        FieldToDive(data_map, decoded_value.driverVersion);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.pipelineCacheUUID), decoded_value.pipelineCacheUUID));
        FieldToDive(data_map, decoded_value.applicationNameOffset);
        FieldToDive(data_map, decoded_value.applicationVersion);
        FieldToDive(data_map, decoded_value.engineNameOffset);
        FieldToDive(data_map, decoded_value.engineVersion);
        FieldToDive(data_map, decoded_value.apiVersion);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rasterizationOrderColorAttachmentAccess);
        FieldToDive(data_map, decoded_value.rasterizationOrderDepthAttachmentAccess);
        FieldToDive(data_map, decoded_value.rasterizationOrderStencilAttachmentAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.formatRgba10x6WithoutYCbCrSampler);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDirectFBSurfaceCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDirectFBSurfaceCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDirectFBSurfaceCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDirectFBSurfaceCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.dfb);
        FieldToDive(data_map, meta_struct.surface);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.mutableDescriptorType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMutableDescriptorTypeListEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMutableDescriptorTypeListEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMutableDescriptorTypeListEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.descriptorTypeCount);
        FieldToDive(data_map, meta_struct.pDescriptorTypes);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMutableDescriptorTypeCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMutableDescriptorTypeCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMutableDescriptorTypeCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.mutableDescriptorTypeListCount);
        FieldToDive(data_map, meta_struct.pMutableDescriptorTypeLists);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexInputDynamicState);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVertexInputBindingDescription2EXT* data)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputBindingDescription2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputBindingDescription2EXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, decoded_value.stride);
        FieldToDive(data_map, decoded_value.inputRate);
        FieldToDive(data_map, decoded_value.divisor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkVertexInputAttributeDescription2EXT* data)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputAttributeDescription2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputAttributeDescription2EXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.location);
        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDrmPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDrmPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDrmPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hasPrimary);
        FieldToDive(data_map, decoded_value.hasRender);
        FieldToDive(data_map, decoded_value.primaryMajor);
        FieldToDive(data_map, decoded_value.primaryMinor);
        FieldToDive(data_map, decoded_value.renderMajor);
        FieldToDive(data_map, decoded_value.renderMinor);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAddressBindingReportFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.reportAddressBinding);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceAddressBindingCallbackDataEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceAddressBindingCallbackDataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceAddressBindingCallbackDataEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDeviceAddressBindingFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.baseAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.bindingType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClipControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthClipControl);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportDepthClipControlCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.negativeOneToOne);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.primitiveTopologyListRestart);
        FieldToDive(data_map, decoded_value.primitiveTopologyPatchListRestart);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentModeFifoLatestReady);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA* data)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, decoded_value.handle);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryZirconHandlePropertiesFUCHSIA* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryZirconHandlePropertiesFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryZirconHandlePropertiesFUCHSIA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryGetZirconHandleInfoFUCHSIA* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA* data)
{
    if (data && data->decoded_value)
    {
        const VkImportSemaphoreZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(VkSemaphoreImportFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, decoded_value.zirconHandle);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA* data)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreGetZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.semaphore);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.invocationMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryGetRemoteAddressInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetRemoteAddressInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetRemoteAddressInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.externalMemoryRDMA);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFrameBoundaryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.frameBoundary);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkFrameBoundaryEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkFrameBoundaryEXT& decoded_value = *data->decoded_value;
        const Decoded_VkFrameBoundaryEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkFrameBoundaryFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.frameID);
        FieldToDive(data_map, decoded_value.imageCount);
        HandleToDive(data_map, &meta_struct.pImages);
        FieldToDive(data_map, decoded_value.bufferCount);
        HandleToDive(data_map, &meta_struct.pBuffers);
        FieldToDive(data_map, decoded_value.tagName);
        FieldToDive(data_map, decoded_value.tagSize);
        FieldToDive(data_map, meta_struct.pTag);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.multisampledRenderToSingleSampled);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassResolvePerformanceQueryEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassResolvePerformanceQueryEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassResolvePerformanceQueryEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.optimal);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMultisampledRenderToSingleSampledInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMultisampledRenderToSingleSampledInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultisampledRenderToSingleSampledInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.multisampledRenderToSingleSampledEnable);
        FieldToDive(data_map, decoded_value.rasterizationSamples);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.extendedDynamicState2);
        FieldToDive(data_map, decoded_value.extendedDynamicState2LogicOp);
        FieldToDive(data_map, decoded_value.extendedDynamicState2PatchControlPoints);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkScreenSurfaceCreateInfoQNX* data)
{
    if (data && data->decoded_value)
    {
        const VkScreenSurfaceCreateInfoQNX& decoded_value = *data->decoded_value;
        const Decoded_VkScreenSurfaceCreateInfoQNX& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkScreenSurfaceCreateFlagsQNX_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.context);
        FieldToDive(data_map, meta_struct.window);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceColorWriteEnableFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.colorWriteEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineColorWriteCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorWriteCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorWriteCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachmentCount);
        FieldToDive(data_map, meta_struct.pColorWriteEnables);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.primitivesGeneratedQuery);
        FieldToDive(data_map, decoded_value.primitivesGeneratedQueryWithRasterizerDiscard);
        FieldToDive(data_map, decoded_value.primitivesGeneratedQueryWithNonZeroStreams);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageViewMinLodFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minLod);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewMinLodCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewMinLodCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewMinLodCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.minLod);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiDrawFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.multiDraw);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiDrawPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxMultiDrawCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMultiDrawInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMultiDrawInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultiDrawInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.firstVertex);
        FieldToDive(data_map, decoded_value.vertexCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMultiDrawIndexedInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMultiDrawIndexedInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultiDrawIndexedInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.firstIndex);
        FieldToDive(data_map, decoded_value.indexCount);
        FieldToDive(data_map, decoded_value.vertexOffset);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.image2DViewOf3D);
        FieldToDive(data_map, decoded_value.sampler2DViewOf3D);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderTileImageFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderTileImageColorReadAccess);
        FieldToDive(data_map, decoded_value.shaderTileImageDepthReadAccess);
        FieldToDive(data_map, decoded_value.shaderTileImageStencilReadAccess);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderTileImagePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderTileImageCoherentReadAccelerated);
        FieldToDive(data_map, decoded_value.shaderTileImageReadSampleFromPixelRateInvocation);
        FieldToDive(data_map, decoded_value.shaderTileImageReadFromHelperInvocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMicromapUsageEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMicromapUsageEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapUsageEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.count);
        FieldToDive(data_map, decoded_value.subdivisionLevel);
        FieldToDive(data_map, decoded_value.format);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMicromapBuildInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMicromapBuildInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapBuildInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(VkBuildMicromapFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.mode);
        HandleToDive(data_map, meta_struct.dstMicromap);
        FieldToDive(data_map, decoded_value.usageCountsCount);
        FieldToDive(data_map, meta_struct.pUsageCounts);
        FieldToDive(data_map, meta_struct.ppUsageCounts);
        FieldToDive(data_map, meta_struct.data);
        FieldToDive(data_map, meta_struct.scratchData);
        FieldToDive(data_map, meta_struct.triangleArray);
        FieldToDive(data_map, decoded_value.triangleArrayStride);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMicromapCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMicromapCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkMicromapCreateFlagsEXT_t(),data_map, decoded_value.createFlags);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.deviceAddress));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpacityMicromapFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.micromap);
        FieldToDive(data_map, decoded_value.micromapCaptureReplay);
        FieldToDive(data_map, decoded_value.micromapHostCommands);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpacityMicromapPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxOpacity2StateSubdivisionLevel);
        FieldToDive(data_map, decoded_value.maxOpacity4StateSubdivisionLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMicromapVersionInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMicromapVersionInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapVersionInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pVersionData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyMicromapToMemoryInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyMicromapToMemoryInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMicromapToMemoryInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.src);
        FieldToDive(data_map, meta_struct.dst);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyMemoryToMicromapInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyMemoryToMicromapInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMemoryToMicromapInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.src);
        HandleToDive(data_map, meta_struct.dst);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyMicromapInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyMicromapInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMicromapInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.src);
        HandleToDive(data_map, meta_struct.dst);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMicromapBuildSizesInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMicromapBuildSizesInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapBuildSizesInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.micromapSize);
        FieldToDive(data_map, decoded_value.buildScratchSize);
        FieldToDive(data_map, decoded_value.discardable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureTrianglesOpacityMicromapEXT& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.indexType);
        FieldToDive(data_map, meta_struct.indexBuffer);
        FieldToDive(data_map, decoded_value.indexStride);
        FieldToDive(data_map, decoded_value.baseTriangle);
        FieldToDive(data_map, decoded_value.usageCountsCount);
        FieldToDive(data_map, meta_struct.pUsageCounts);
        FieldToDive(data_map, meta_struct.ppUsageCounts);
        HandleToDive(data_map, meta_struct.micromap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMicromapTriangleEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMicromapTriangleEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapTriangleEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.dataOffset);
        FieldToDive(data_map, decoded_value.subdivisionLevel);
        FieldToDive(data_map, decoded_value.format);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDisplacementMicromapFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.displacementMicromap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDisplacementMicromapPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxDisplacementMicromapSubdivisionLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureTrianglesDisplacementMicromapNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.displacementBiasAndScaleFormat);
        FieldToDive(data_map, decoded_value.displacementVectorFormat);
        FieldToDive(data_map, meta_struct.displacementBiasAndScaleBuffer);
        FieldToDive(data_map, decoded_value.displacementBiasAndScaleStride);
        FieldToDive(data_map, meta_struct.displacementVectorBuffer);
        FieldToDive(data_map, decoded_value.displacementVectorStride);
        FieldToDive(data_map, meta_struct.displacedMicromapPrimitiveFlags);
        FieldToDive(data_map, decoded_value.displacedMicromapPrimitiveFlagsStride);
        FieldToDive(data_map, decoded_value.indexType);
        FieldToDive(data_map, meta_struct.indexBuffer);
        FieldToDive(data_map, decoded_value.indexStride);
        FieldToDive(data_map, decoded_value.baseTriangle);
        FieldToDive(data_map, decoded_value.usageCountsCount);
        FieldToDive(data_map, meta_struct.pUsageCounts);
        FieldToDive(data_map, meta_struct.ppUsageCounts);
        HandleToDive(data_map, meta_struct.micromap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.clustercullingShader);
        FieldToDive(data_map, decoded_value.multiviewClusterCullingShader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, &meta_struct.maxWorkGroupCount);
        FieldToDive(data_map, &meta_struct.maxWorkGroupSize);
        FieldToDive(data_map, decoded_value.maxOutputClusterCount);
        FieldToDive(data_map, decoded_value.indirectBufferOffsetAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.clusterShadingRate);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.borderColorSwizzle);
        FieldToDive(data_map, decoded_value.borderColorSwizzleFromImage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerBorderColorComponentMappingCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.components);
        FieldToDive(data_map, decoded_value.srgb);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pageableDeviceLocalMemory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderCorePropertiesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCorePropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCorePropertiesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pixelRate);
        FieldToDive(data_map, decoded_value.texelRate);
        FieldToDive(data_map, decoded_value.fmaRate);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM* data)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueShaderCoreControlCreateInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderCoreCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSchedulingControlsFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.schedulingControls);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSchedulingControlsPropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPhysicalDeviceSchedulingControlsFlagsARM_t(),data_map, decoded_value.schedulingControlsFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imageSlicedViewOf3D);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewSlicedCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewSlicedCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewSlicedCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.sliceOffset);
        FieldToDive(data_map, decoded_value.sliceCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.descriptorSetHostMapping);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetBindingReferenceVALVE* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetBindingReferenceVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetBindingReferenceVALVE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.descriptorSetLayout);
        FieldToDive(data_map, decoded_value.binding);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE* data)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutHostMappingInfoVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.descriptorOffset);
        FieldToDive(data_map, decoded_value.descriptorSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.nonSeamlessCubeMap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRenderPassStripedFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.renderPassStriped);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRenderPassStripedPropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.renderPassStripeGranularity);
        FieldToDive(data_map, decoded_value.maxRenderPassStripes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassStripeInfoARM* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassStripeInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassStripeInfoARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.stripeArea);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassStripeBeginInfoARM* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassStripeBeginInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassStripeBeginInfoARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stripeInfoCount);
        FieldToDive(data_map, meta_struct.pStripeInfos);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassStripeSubmitInfoARM* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassStripeSubmitInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassStripeSubmitInfoARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stripeSemaphoreInfoCount);
        FieldToDive(data_map, meta_struct.pStripeSemaphoreInfos);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentDensityMapOffset);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.fragmentDensityOffsetGranularity);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSubpassFragmentDensityMapOffsetEndInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkSubpassFragmentDensityMapOffsetEndInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassFragmentDensityMapOffsetEndInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.fragmentDensityOffsetCount);
        FieldToDive(data_map, meta_struct.pFragmentDensityOffsets);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceGeneratedCompute);
        FieldToDive(data_map, decoded_value.deviceGeneratedComputePipelines);
        FieldToDive(data_map, decoded_value.deviceGeneratedComputeCaptureReplay);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkComputePipelineIndirectBufferInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkComputePipelineIndirectBufferInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkComputePipelineIndirectBufferInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.deviceAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.pipelineDeviceAddressCaptureReplay));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineIndirectDeviceAddressInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineIndirectDeviceAddressInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineIndirectDeviceAddressInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineBindPoint);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindPipelineIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBindPipelineIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindPipelineIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.pipelineAddress));
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.spheres);
        FieldToDive(data_map, decoded_value.linearSweptSpheres);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryLinearSweptSpheresDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexFormat);
        FieldToDive(data_map, meta_struct.vertexData);
        FieldToDive(data_map, decoded_value.vertexStride);
        FieldToDive(data_map, decoded_value.radiusFormat);
        FieldToDive(data_map, meta_struct.radiusData);
        FieldToDive(data_map, decoded_value.radiusStride);
        FieldToDive(data_map, decoded_value.indexType);
        FieldToDive(data_map, meta_struct.indexData);
        FieldToDive(data_map, decoded_value.indexStride);
        FieldToDive(data_map, decoded_value.indexingMode);
        FieldToDive(data_map, decoded_value.endCapsMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureGeometrySpheresDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometrySpheresDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometrySpheresDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexFormat);
        FieldToDive(data_map, meta_struct.vertexData);
        FieldToDive(data_map, decoded_value.vertexStride);
        FieldToDive(data_map, decoded_value.radiusFormat);
        FieldToDive(data_map, meta_struct.radiusData);
        FieldToDive(data_map, decoded_value.radiusStride);
        FieldToDive(data_map, decoded_value.indexType);
        FieldToDive(data_map, meta_struct.indexData);
        FieldToDive(data_map, decoded_value.indexStride);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLinearColorAttachmentFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.linearColorAttachment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imageCompressionControlSwapchain);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageViewSampleWeightCreateInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkImageViewSampleWeightCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewSampleWeightCreateInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.filterCenter);
        FieldToDive(data_map, meta_struct.filterSize);
        FieldToDive(data_map, decoded_value.numPhases);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessingFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.textureSampleWeighted);
        FieldToDive(data_map, decoded_value.textureBoxFilter);
        FieldToDive(data_map, decoded_value.textureBlockMatch);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessingPropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxWeightFilterPhases);
        FieldToDive(data_map, meta_struct.maxWeightFilterDimension);
        FieldToDive(data_map, meta_struct.maxBlockMatchRegion);
        FieldToDive(data_map, meta_struct.maxBoxFilterBlockSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceNestedCommandBufferFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.nestedCommandBuffer);
        FieldToDive(data_map, decoded_value.nestedCommandBufferRendering);
        FieldToDive(data_map, decoded_value.nestedCommandBufferSimultaneousUse);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceNestedCommandBufferPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxCommandBufferNestingLevel);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkExternalMemoryAcquireUnmodifiedEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryAcquireUnmodifiedEXT& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryAcquireUnmodifiedEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.acquireUnmodifiedMemory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.extendedDynamicState3TessellationDomainOrigin);
        FieldToDive(data_map, decoded_value.extendedDynamicState3DepthClampEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3PolygonMode);
        FieldToDive(data_map, decoded_value.extendedDynamicState3RasterizationSamples);
        FieldToDive(data_map, decoded_value.extendedDynamicState3SampleMask);
        FieldToDive(data_map, decoded_value.extendedDynamicState3AlphaToCoverageEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3AlphaToOneEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3LogicOpEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ColorBlendEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ColorBlendEquation);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ColorWriteMask);
        FieldToDive(data_map, decoded_value.extendedDynamicState3RasterizationStream);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ConservativeRasterizationMode);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ExtraPrimitiveOverestimationSize);
        FieldToDive(data_map, decoded_value.extendedDynamicState3DepthClipEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3SampleLocationsEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ColorBlendAdvanced);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ProvokingVertexMode);
        FieldToDive(data_map, decoded_value.extendedDynamicState3LineRasterizationMode);
        FieldToDive(data_map, decoded_value.extendedDynamicState3LineStippleEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3DepthClipNegativeOneToOne);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ViewportWScalingEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ViewportSwizzle);
        FieldToDive(data_map, decoded_value.extendedDynamicState3CoverageToColorEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3CoverageToColorLocation);
        FieldToDive(data_map, decoded_value.extendedDynamicState3CoverageModulationMode);
        FieldToDive(data_map, decoded_value.extendedDynamicState3CoverageModulationTableEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3CoverageModulationTable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3CoverageReductionMode);
        FieldToDive(data_map, decoded_value.extendedDynamicState3RepresentativeFragmentTestEnable);
        FieldToDive(data_map, decoded_value.extendedDynamicState3ShadingRateImageEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dynamicPrimitiveTopologyUnrestricted);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkColorBlendEquationEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkColorBlendEquationEXT& decoded_value = *data->decoded_value;
        const Decoded_VkColorBlendEquationEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.srcColorBlendFactor);
        FieldToDive(data_map, decoded_value.dstColorBlendFactor);
        FieldToDive(data_map, decoded_value.colorBlendOp);
        FieldToDive(data_map, decoded_value.srcAlphaBlendFactor);
        FieldToDive(data_map, decoded_value.dstAlphaBlendFactor);
        FieldToDive(data_map, decoded_value.alphaBlendOp);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkColorBlendAdvancedEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkColorBlendAdvancedEXT& decoded_value = *data->decoded_value;
        const Decoded_VkColorBlendAdvancedEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.advancedBlendOp);
        FieldToDive(data_map, decoded_value.srcPremultiplied);
        FieldToDive(data_map, decoded_value.dstPremultiplied);
        FieldToDive(data_map, decoded_value.blendOverlap);
        FieldToDive(data_map, decoded_value.clampResults);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.subpassMergeFeedback);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassCreationControlEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreationControlEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreationControlEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.disallowMerging);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassCreationFeedbackInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreationFeedbackInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreationFeedbackInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.postMergeSubpassCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreationFeedbackCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pRenderPassFeedback);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassSubpassFeedbackInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassSubpassFeedbackInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassSubpassFeedbackInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.subpassMergeStatus);
        FieldToDive(data_map, &meta_struct.description);
        FieldToDive(data_map, decoded_value.postMergeIndex);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassSubpassFeedbackCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pSubpassFeedback);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDirectDriverLoadingInfoLUNARG* data)
{
    if (data && data->decoded_value)
    {
        const VkDirectDriverLoadingInfoLUNARG& decoded_value = *data->decoded_value;
        const Decoded_VkDirectDriverLoadingInfoLUNARG& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkDirectDriverLoadingFlagsLUNARG_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, to_hex_variable_width(meta_struct.pfnGetInstanceProcAddr));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDirectDriverLoadingListLUNARG* data)
{
    if (data && data->decoded_value)
    {
        const VkDirectDriverLoadingListLUNARG& decoded_value = *data->decoded_value;
        const Decoded_VkDirectDriverLoadingListLUNARG& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, decoded_value.driverCount);
        FieldToDive(data_map, meta_struct.pDrivers);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderModuleIdentifier);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.shaderModuleIdentifierAlgorithmUUID), decoded_value.shaderModuleIdentifierAlgorithmUUID));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineShaderStageModuleIdentifierCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.identifierSize);
        FieldToDive(data_map, meta_struct.pIdentifier);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkShaderModuleIdentifierEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkShaderModuleIdentifierEXT& decoded_value = *data->decoded_value;
        const Decoded_VkShaderModuleIdentifierEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.identifierSize);
        FieldToDive(data_map, &meta_struct.identifier);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpticalFlowFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.opticalFlow);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpticalFlowPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkOpticalFlowGridSizeFlagsNV_t(),data_map, decoded_value.supportedOutputGridSizes);
        FieldToDive(VkOpticalFlowGridSizeFlagsNV_t(),data_map, decoded_value.supportedHintGridSizes);
        FieldToDive(data_map, decoded_value.hintSupported);
        FieldToDive(data_map, decoded_value.costSupported);
        FieldToDive(data_map, decoded_value.bidirectionalFlowSupported);
        FieldToDive(data_map, decoded_value.globalFlowSupported);
        FieldToDive(data_map, decoded_value.minWidth);
        FieldToDive(data_map, decoded_value.minHeight);
        FieldToDive(data_map, decoded_value.maxWidth);
        FieldToDive(data_map, decoded_value.maxHeight);
        FieldToDive(data_map, decoded_value.maxNumRegionsOfInterest);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOpticalFlowImageFormatInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowImageFormatInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowImageFormatInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkOpticalFlowUsageFlagsNV_t(),data_map, decoded_value.usage);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOpticalFlowImageFormatPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowImageFormatPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowImageFormatPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.format);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOpticalFlowSessionCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowSessionCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowSessionCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.imageFormat);
        FieldToDive(data_map, decoded_value.flowVectorFormat);
        FieldToDive(data_map, decoded_value.costFormat);
        FieldToDive(VkOpticalFlowGridSizeFlagsNV_t(),data_map, decoded_value.outputGridSize);
        FieldToDive(VkOpticalFlowGridSizeFlagsNV_t(),data_map, decoded_value.hintGridSize);
        FieldToDive(data_map, decoded_value.performanceLevel);
        FieldToDive(VkOpticalFlowSessionCreateFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowSessionCreatePrivateDataInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.id);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, meta_struct.pPrivateData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOpticalFlowExecuteInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowExecuteInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowExecuteInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkOpticalFlowExecuteFlagsNV_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.regionCount);
        FieldToDive(data_map, meta_struct.pRegions);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLegacyDitheringFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.legacyDithering);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.externalFormatResolve);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.nullColorAttachmentWithExternalFormatResolve);
        FieldToDive(data_map, decoded_value.externalFormatResolveChromaOffsetX);
        FieldToDive(data_map, decoded_value.externalFormatResolveChromaOffsetY);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID* data)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferFormatResolvePropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.colorAttachmentFormat);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAntiLagFeaturesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.antiLag);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAntiLagPresentationInfoAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkAntiLagPresentationInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkAntiLagPresentationInfoAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stage);
        FieldToDive(data_map, decoded_value.frameIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAntiLagDataAMD* data)
{
    if (data && data->decoded_value)
    {
        const VkAntiLagDataAMD& decoded_value = *data->decoded_value;
        const Decoded_VkAntiLagDataAMD& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, decoded_value.maxFPS);
        FieldToDive(data_map, meta_struct.pPresentationInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderObjectFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderObject);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderObjectPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, uuid_to_string(sizeof(decoded_value.shaderBinaryUUID), decoded_value.shaderBinaryUUID));
        FieldToDive(data_map, decoded_value.shaderBinaryVersion);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkShaderCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkShaderCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkShaderCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderCreateFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.stage);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.nextStage);
        FieldToDive(data_map, decoded_value.codeType);
        FieldToDive(data_map, decoded_value.codeSize);
        FieldToDive(data_map, meta_struct.pCode);
        FieldToDive(data_map, &meta_struct.pName);
        FieldToDive(data_map, decoded_value.setLayoutCount);
        HandleToDive(data_map, &meta_struct.pSetLayouts);
        FieldToDive(data_map, decoded_value.pushConstantRangeCount);
        FieldToDive(data_map, meta_struct.pPushConstantRanges);
        FieldToDive(data_map, meta_struct.pSpecializationInfo);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDepthClampRangeEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDepthClampRangeEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDepthClampRangeEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.minDepthClamp);
        FieldToDive(data_map, decoded_value.maxDepthClamp);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTilePropertiesFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.tileProperties);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkTilePropertiesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkTilePropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkTilePropertiesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.tileSize);
        FieldToDive(data_map, meta_struct.apronSize);
        FieldToDive(data_map, meta_struct.origin);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAmigoProfilingFeaturesSEC& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.amigoProfiling);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAmigoProfilingSubmitInfoSEC* data)
{
    if (data && data->decoded_value)
    {
        const VkAmigoProfilingSubmitInfoSEC& decoded_value = *data->decoded_value;
        const Decoded_VkAmigoProfilingSubmitInfoSEC& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.firstDrawTimestamp);
        FieldToDive(data_map, decoded_value.swapBufferTimestamp);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.multiviewPerViewViewports);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingInvocationReorderReorderingHint);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingInvocationReorder);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeVectorPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.cooperativeVectorSupportedStages);
        FieldToDive(data_map, decoded_value.cooperativeVectorTrainingFloat16Accumulation);
        FieldToDive(data_map, decoded_value.cooperativeVectorTrainingFloat32Accumulation);
        FieldToDive(data_map, decoded_value.maxCooperativeVectorComponents);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeVectorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cooperativeVector);
        FieldToDive(data_map, decoded_value.cooperativeVectorTraining);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCooperativeVectorPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeVectorPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeVectorPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.inputType);
        FieldToDive(data_map, decoded_value.inputInterpretation);
        FieldToDive(data_map, decoded_value.matrixInterpretation);
        FieldToDive(data_map, decoded_value.biasInterpretation);
        FieldToDive(data_map, decoded_value.resultType);
        FieldToDive(data_map, decoded_value.transpose);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkConvertCooperativeVectorMatrixInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkConvertCooperativeVectorMatrixInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkConvertCooperativeVectorMatrixInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.srcSize);
        FieldToDive(data_map, meta_struct.srcData);
        FieldToDive(data_map, meta_struct.pDstSize);
        FieldToDive(data_map, meta_struct.dstData);
        FieldToDive(data_map, decoded_value.srcComponentType);
        FieldToDive(data_map, decoded_value.dstComponentType);
        FieldToDive(data_map, decoded_value.numRows);
        FieldToDive(data_map, decoded_value.numColumns);
        FieldToDive(data_map, decoded_value.srcLayout);
        FieldToDive(data_map, decoded_value.srcStride);
        FieldToDive(data_map, decoded_value.dstLayout);
        FieldToDive(data_map, decoded_value.dstStride);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.extendedSparseAddressSpace);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.extendedSparseAddressSpaceSize);
        FieldToDive(VkImageUsageFlags_t(),data_map, decoded_value.extendedSparseImageUsageFlags);
        FieldToDive(VkBufferUsageFlags_t(),data_map, decoded_value.extendedSparseBufferUsageFlags);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.legacyVertexAttributes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.nativeUnalignedPerformance);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLayerSettingEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkLayerSettingEXT& decoded_value = *data->decoded_value;
        const Decoded_VkLayerSettingEXT& meta_struct = *data;

        FieldToDive(data_map, &meta_struct.pLayerName);
        FieldToDive(data_map, &meta_struct.pSettingName);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.valueCount);
        FieldToDive(data_map, meta_struct.pValues);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLayerSettingsCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkLayerSettingsCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkLayerSettingsCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.settingCount);
        FieldToDive(data_map, meta_struct.pSettings);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderCoreBuiltins);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderCoreMask);
        FieldToDive(data_map, decoded_value.shaderCoreCount);
        FieldToDive(data_map, decoded_value.shaderWarpsPerCore);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineLibraryGroupHandles);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dynamicRenderingUnusedAttachments);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLatencySleepModeInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkLatencySleepModeInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySleepModeInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.lowLatencyMode);
        FieldToDive(data_map, decoded_value.lowLatencyBoost);
        FieldToDive(data_map, decoded_value.minimumIntervalUs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLatencySleepInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkLatencySleepInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySleepInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.signalSemaphore);
        FieldToDive(data_map, decoded_value.value);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSetLatencyMarkerInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSetLatencyMarkerInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkSetLatencyMarkerInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentID);
        FieldToDive(data_map, decoded_value.marker);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLatencyTimingsFrameReportNV* data)
{
    if (data && data->decoded_value)
    {
        const VkLatencyTimingsFrameReportNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencyTimingsFrameReportNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentID);
        FieldToDive(data_map, decoded_value.inputSampleTimeUs);
        FieldToDive(data_map, decoded_value.simStartTimeUs);
        FieldToDive(data_map, decoded_value.simEndTimeUs);
        FieldToDive(data_map, decoded_value.renderSubmitStartTimeUs);
        FieldToDive(data_map, decoded_value.renderSubmitEndTimeUs);
        FieldToDive(data_map, decoded_value.presentStartTimeUs);
        FieldToDive(data_map, decoded_value.presentEndTimeUs);
        FieldToDive(data_map, decoded_value.driverStartTimeUs);
        FieldToDive(data_map, decoded_value.driverEndTimeUs);
        FieldToDive(data_map, decoded_value.osRenderQueueStartTimeUs);
        FieldToDive(data_map, decoded_value.osRenderQueueEndTimeUs);
        FieldToDive(data_map, decoded_value.gpuRenderStartTimeUs);
        FieldToDive(data_map, decoded_value.gpuRenderEndTimeUs);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGetLatencyMarkerInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkGetLatencyMarkerInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGetLatencyMarkerInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.timingCount);
        FieldToDive(data_map, meta_struct.pTimings);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLatencySubmissionPresentIdNV* data)
{
    if (data && data->decoded_value)
    {
        const VkLatencySubmissionPresentIdNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySubmissionPresentIdNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentID);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSwapchainLatencyCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainLatencyCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainLatencyCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.latencyModeEnable);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkOutOfBandQueueTypeInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkOutOfBandQueueTypeInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOutOfBandQueueTypeInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.queueType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkLatencySurfaceCapabilitiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkLatencySurfaceCapabilitiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySurfaceCapabilitiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentModeCount);
        FieldToDive(data_map, meta_struct.pPresentModes);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.multiviewPerViewRenderAreas);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.perViewRenderAreaCount);
        FieldToDive(data_map, meta_struct.pPerViewRenderAreas);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePerStageDescriptorSetFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.perStageDescriptorSet);
        FieldToDive(data_map, decoded_value.dynamicPipelineLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessing2FeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.textureBlockMatch2);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessing2PropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.maxBlockMatchWindow);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerBlockMatchWindowCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.windowExtent);
        FieldToDive(data_map, decoded_value.windowCompareMode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCubicWeightsFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.selectableCubicWeights);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerCubicWeightsCreateInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerCubicWeightsCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerCubicWeightsCreateInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cubicWeights);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBlitImageCubicWeightsInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkBlitImageCubicWeightsInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkBlitImageCubicWeightsInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cubicWeights);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.ycbcrDegamma);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.enableYDegamma);
        FieldToDive(data_map, decoded_value.enableCbCrDegamma);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCubicClampFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cubicRangeClamp);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.attachmentFeedbackLoopDynamicState);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredDriverPropertiesMSFT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.underlyingAPI);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.descriptorPoolOverallocation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplaySurfaceStereoCreateInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplaySurfaceStereoCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDisplaySurfaceStereoCreateInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.stereoType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDisplayModeStereoPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeStereoPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeStereoPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hdmi3DSupported);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRawAccessChainsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderRawAccessChains);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.commandBufferInheritance);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderFloat16VectorAtomics);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderReplicatedComposites);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingValidationFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingValidation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.partitionedAccelerationStructure);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxPartitionCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPartitionedAccelerationStructureFlagsNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureFlagsNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureFlagsNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.enablePartitionTranslation);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkStridedDeviceAddressNV* data)
{
    if (data && data->decoded_value)
    {
        const VkStridedDeviceAddressNV& decoded_value = *data->decoded_value;
        const Decoded_VkStridedDeviceAddressNV& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.startAddress));
        FieldToDive(data_map, decoded_value.strideInBytes);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBuildPartitionedAccelerationStructureIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.opType);
        FieldToDive(data_map, decoded_value.argCount);
        FieldToDive(data_map, meta_struct.argData);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureWriteInstanceDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV& meta_struct = *data;

        FieldToDive(data_map, meta_struct.transform);
        FieldToDive(data_map, &meta_struct.explicitAABB);
        FieldToDive(data_map, decoded_value.instanceID);
        FieldToDive(data_map, decoded_value.instanceMask);
        FieldToDive(data_map, decoded_value.instanceContributionToHitGroupIndex);
        FieldToDive(VkPartitionedAccelerationStructureInstanceFlagsNV_t(),data_map, decoded_value.instanceFlags);
        FieldToDive(data_map, decoded_value.instanceIndex);
        FieldToDive(data_map, decoded_value.partitionIndex);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.accelerationStructure));
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureUpdateInstanceDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.instanceIndex);
        FieldToDive(data_map, decoded_value.instanceContributionToHitGroupIndex);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.accelerationStructure));
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureWritePartitionTranslationDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.partitionIndex);
        FieldToDive(data_map, &meta_struct.partitionTranslation);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV* data)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetPartitionedAccelerationStructureNV& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.accelerationStructureCount);
        FieldToDive(data_map, meta_struct.pAccelerationStructures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPartitionedAccelerationStructureInstancesInputNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureInstancesInputNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureInstancesInputNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkBuildAccelerationStructureFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.instanceCount);
        FieldToDive(data_map, decoded_value.maxInstancePerPartitionCount);
        FieldToDive(data_map, decoded_value.partitionCount);
        FieldToDive(data_map, decoded_value.maxInstanceInGlobalPartitionCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBuildPartitionedAccelerationStructureInfoNV* data)
{
    if (data && data->decoded_value)
    {
        const VkBuildPartitionedAccelerationStructureInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkBuildPartitionedAccelerationStructureInfoNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.input);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.srcAccelerationStructureData));
        FieldToDive(data_map, to_hex_variable_width(decoded_value.dstAccelerationStructureData));
        FieldToDive(data_map, to_hex_variable_width(decoded_value.scratchData));
        FieldToDive(data_map, to_hex_variable_width(decoded_value.srcInfos));
        FieldToDive(data_map, to_hex_variable_width(decoded_value.srcInfosCount));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureBuildSizesInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureBuildSizesInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureBuildSizesInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.accelerationStructureSize);
        FieldToDive(data_map, decoded_value.updateScratchSize);
        FieldToDive(data_map, decoded_value.buildScratchSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.deviceGeneratedCommands);
        FieldToDive(data_map, decoded_value.dynamicGeneratedPipelineLayout);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxIndirectPipelineCount);
        FieldToDive(data_map, decoded_value.maxIndirectShaderObjectCount);
        FieldToDive(data_map, decoded_value.maxIndirectSequenceCount);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsTokenCount);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsTokenOffset);
        FieldToDive(data_map, decoded_value.maxIndirectCommandsIndirectStride);
        FieldToDive(VkIndirectCommandsInputModeFlagsEXT_t(),data_map, decoded_value.supportedIndirectCommandsInputModes);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.supportedIndirectCommandsShaderStages);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.supportedIndirectCommandsShaderStagesPipelineBinding);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.supportedIndirectCommandsShaderStagesShaderBinding);
        FieldToDive(data_map, decoded_value.deviceGeneratedCommandsTransformFeedback);
        FieldToDive(data_map, decoded_value.deviceGeneratedCommandsMultiDrawIndirectCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsMemoryRequirementsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.indirectExecutionSet);
        HandleToDive(data_map, meta_struct.indirectCommandsLayout);
        FieldToDive(data_map, decoded_value.maxSequenceCount);
        FieldToDive(data_map, decoded_value.maxDrawCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectExecutionSetPipelineInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectExecutionSetPipelineInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectExecutionSetPipelineInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.initialPipeline);
        FieldToDive(data_map, decoded_value.maxPipelineCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectExecutionSetShaderLayoutInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.setLayoutCount);
        HandleToDive(data_map, &meta_struct.pSetLayouts);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectExecutionSetShaderInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectExecutionSetShaderInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectExecutionSetShaderInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderCount);
        HandleToDive(data_map, &meta_struct.pInitialShaders);
        FieldToDive(data_map, meta_struct.pSetLayoutInfos);
        FieldToDive(data_map, decoded_value.maxShaderCount);
        FieldToDive(data_map, decoded_value.pushConstantRangeCount);
        FieldToDive(data_map, meta_struct.pPushConstantRanges);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeneratedCommandsInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.shaderStages);
        HandleToDive(data_map, meta_struct.indirectExecutionSet);
        HandleToDive(data_map, meta_struct.indirectCommandsLayout);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.indirectAddress));
        FieldToDive(data_map, decoded_value.indirectAddressSize);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.preprocessAddress));
        FieldToDive(data_map, decoded_value.preprocessSize);
        FieldToDive(data_map, decoded_value.maxSequenceCount);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.sequenceCountAddress));
        FieldToDive(data_map, decoded_value.maxDrawCount);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWriteIndirectExecutionSetPipelineEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkWriteIndirectExecutionSetPipelineEXT& decoded_value = *data->decoded_value;
        const Decoded_VkWriteIndirectExecutionSetPipelineEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.index);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsPushConstantTokenEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsPushConstantTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsPushConstantTokenEXT& meta_struct = *data;

        FieldToDive(data_map, meta_struct.updateRange);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsVertexBufferTokenEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsVertexBufferTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsVertexBufferTokenEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.vertexBindingUnit);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsIndexBufferTokenEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsIndexBufferTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsIndexBufferTokenEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.mode);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsExecutionSetTokenEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsExecutionSetTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsExecutionSetTokenEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.type);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.shaderStages);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkIndirectCommandsLayoutCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsLayoutCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsLayoutCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkIndirectCommandsLayoutUsageFlagsEXT_t(),data_map, decoded_value.flags);
        FieldToDive(VkShaderStageFlags_t(),data_map, decoded_value.shaderStages);
        FieldToDive(data_map, decoded_value.indirectStride);
        HandleToDive(data_map, meta_struct.pipelineLayout);
        FieldToDive(data_map, decoded_value.tokenCount);
        FieldToDive(data_map, meta_struct.pTokens);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrawIndirectCountIndirectCommandEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDrawIndirectCountIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrawIndirectCountIndirectCommandEXT& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.bufferAddress));
        FieldToDive(data_map, decoded_value.stride);
        FieldToDive(data_map, decoded_value.commandCount);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindVertexBufferIndirectCommandEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkBindVertexBufferIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBindVertexBufferIndirectCommandEXT& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.bufferAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.stride);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkBindIndexBufferIndirectCommandEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkBindIndexBufferIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBindIndexBufferIndirectCommandEXT& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.bufferAddress));
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.indexType);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeneratedCommandsPipelineInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsPipelineInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsPipelineInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.pipeline);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkGeneratedCommandsShaderInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsShaderInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsShaderInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderCount);
        HandleToDive(data_map, &meta_struct.pShaders);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWriteIndirectExecutionSetShaderEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkWriteIndirectExecutionSetShaderEXT& decoded_value = *data->decoded_value;
        const Decoded_VkWriteIndirectExecutionSetShaderEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.index);
        HandleToDive(data_map, meta_struct.shader);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageAlignmentControlFeaturesMESA& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.imageAlignmentControl);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageAlignmentControlPropertiesMESA& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.supportedImageAlignmentMask);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImageAlignmentControlCreateInfoMESA* data)
{
    if (data && data->decoded_value)
    {
        const VkImageAlignmentControlCreateInfoMESA& decoded_value = *data->decoded_value;
        const Decoded_VkImageAlignmentControlCreateInfoMESA& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maximumRequestedAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClampControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthClampControl);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportDepthClampControlCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.depthClampMode);
        FieldToDive(data_map, meta_struct.pDepthClampRange);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHdrVividFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.hdrVivid);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkHdrVividDynamicMetadataHUAWEI* data)
{
    if (data && data->decoded_value)
    {
        const VkHdrVividDynamicMetadataHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkHdrVividDynamicMetadataHUAWEI& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.dynamicMetadataSize);
        FieldToDive(data_map, meta_struct.pDynamicMetadata);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeMatrixFlexibleDimensionsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.MGranularity);
        FieldToDive(data_map, decoded_value.NGranularity);
        FieldToDive(data_map, decoded_value.KGranularity);
        FieldToDive(data_map, decoded_value.AType);
        FieldToDive(data_map, decoded_value.BType);
        FieldToDive(data_map, decoded_value.CType);
        FieldToDive(data_map, decoded_value.ResultType);
        FieldToDive(data_map, decoded_value.saturatingAccumulation);
        FieldToDive(data_map, decoded_value.scope);
        FieldToDive(data_map, decoded_value.workgroupInvocations);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrix2FeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cooperativeMatrixWorkgroupScope);
        FieldToDive(data_map, decoded_value.cooperativeMatrixFlexibleDimensions);
        FieldToDive(data_map, decoded_value.cooperativeMatrixReductions);
        FieldToDive(data_map, decoded_value.cooperativeMatrixConversions);
        FieldToDive(data_map, decoded_value.cooperativeMatrixPerElementOperations);
        FieldToDive(data_map, decoded_value.cooperativeMatrixTensorAddressing);
        FieldToDive(data_map, decoded_value.cooperativeMatrixBlockLoads);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrix2PropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize);
        FieldToDive(data_map, decoded_value.cooperativeMatrixFlexibleDimensionsMaxDimension);
        FieldToDive(data_map, decoded_value.cooperativeMatrixWorkgroupScopeReservedSharedMemory);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.pipelineOpacityMicromap);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkImportMemoryMetalHandleInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryMetalHandleInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryMetalHandleInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.handle);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryMetalHandlePropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryMetalHandlePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryMetalHandlePropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.memoryTypeBits);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkMemoryGetMetalHandleInfoEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetMetalHandleInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetMetalHandleInfoEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.memory);
        FieldToDive(data_map, decoded_value.handleType);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexAttributeRobustness);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkSetPresentConfigNV* data)
{
    if (data && data->decoded_value)
    {
        const VkSetPresentConfigNV& decoded_value = *data->decoded_value;
        const Decoded_VkSetPresentConfigNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.numFramesPerBatch);
        FieldToDive(data_map, decoded_value.presentConfigFeedback);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentMeteringFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.presentMetering);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureBuildRangeInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureBuildRangeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureBuildRangeInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.primitiveCount);
        FieldToDive(data_map, decoded_value.primitiveOffset);
        FieldToDive(data_map, decoded_value.firstVertex);
        FieldToDive(data_map, decoded_value.transformOffset);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureGeometryTrianglesDataKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryTrianglesDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryTrianglesDataKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.vertexFormat);
        FieldToDive(data_map, meta_struct.vertexData);
        FieldToDive(data_map, decoded_value.vertexStride);
        FieldToDive(data_map, decoded_value.maxVertex);
        FieldToDive(data_map, decoded_value.indexType);
        FieldToDive(data_map, meta_struct.indexData);
        FieldToDive(data_map, meta_struct.transformData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureGeometryAabbsDataKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryAabbsDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryAabbsDataKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.data);
        FieldToDive(data_map, decoded_value.stride);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureGeometryInstancesDataKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryInstancesDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryInstancesDataKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.arrayOfPointers);
        FieldToDive(data_map, meta_struct.data);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureBuildGeometryInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureBuildGeometryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureBuildGeometryInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(VkBuildAccelerationStructureFlagsKHR_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.mode);
        HandleToDive(data_map, meta_struct.srcAccelerationStructure);
        HandleToDive(data_map, meta_struct.dstAccelerationStructure);
        FieldToDive(data_map, decoded_value.geometryCount);
        FieldToDive(data_map, meta_struct.pGeometries);
        FieldToDive(data_map, meta_struct.ppGeometries);
        FieldToDive(data_map, meta_struct.scratchData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkAccelerationStructureCreateFlagsKHR_t(),data_map, decoded_value.createFlags);
        HandleToDive(data_map, meta_struct.buffer);
        FieldToDive(data_map, decoded_value.offset);
        FieldToDive(data_map, decoded_value.size);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, to_hex_variable_width(decoded_value.deviceAddress));
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkWriteDescriptorSetAccelerationStructureKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetAccelerationStructureKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetAccelerationStructureKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.accelerationStructureCount);
        HandleToDive(data_map, &meta_struct.pAccelerationStructures);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAccelerationStructureFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.accelerationStructure);
        FieldToDive(data_map, decoded_value.accelerationStructureCaptureReplay);
        FieldToDive(data_map, decoded_value.accelerationStructureIndirectBuild);
        FieldToDive(data_map, decoded_value.accelerationStructureHostCommands);
        FieldToDive(data_map, decoded_value.descriptorBindingAccelerationStructureUpdateAfterBind);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAccelerationStructurePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxGeometryCount);
        FieldToDive(data_map, decoded_value.maxInstanceCount);
        FieldToDive(data_map, decoded_value.maxPrimitiveCount);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorAccelerationStructures);
        FieldToDive(data_map, decoded_value.maxPerStageDescriptorUpdateAfterBindAccelerationStructures);
        FieldToDive(data_map, decoded_value.maxDescriptorSetAccelerationStructures);
        FieldToDive(data_map, decoded_value.maxDescriptorSetUpdateAfterBindAccelerationStructures);
        FieldToDive(data_map, decoded_value.minAccelerationStructureScratchOffsetAlignment);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureDeviceAddressInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureDeviceAddressInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureDeviceAddressInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.accelerationStructure);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkAccelerationStructureVersionInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureVersionInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureVersionInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.pVersionData);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyAccelerationStructureToMemoryInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyAccelerationStructureToMemoryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCopyAccelerationStructureToMemoryInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.src);
        FieldToDive(data_map, meta_struct.dst);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyMemoryToAccelerationStructureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyMemoryToAccelerationStructureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMemoryToAccelerationStructureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, meta_struct.src);
        HandleToDive(data_map, meta_struct.dst);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkCopyAccelerationStructureInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkCopyAccelerationStructureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCopyAccelerationStructureInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        HandleToDive(data_map, meta_struct.src);
        HandleToDive(data_map, meta_struct.dst);
        FieldToDive(data_map, decoded_value.mode);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRayTracingShaderGroupCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingShaderGroupCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingShaderGroupCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.type);
        FieldToDive(data_map, decoded_value.generalShader);
        FieldToDive(data_map, decoded_value.closestHitShader);
        FieldToDive(data_map, decoded_value.anyHitShader);
        FieldToDive(data_map, decoded_value.intersectionShader);
        FieldToDive(data_map, meta_struct.pShaderGroupCaptureReplayHandle);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingPipelineInterfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxPipelineRayPayloadSize);
        FieldToDive(data_map, decoded_value.maxPipelineRayHitAttributeSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkRayTracingPipelineCreateInfoKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingPipelineCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingPipelineCreateInfoKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(VkPipelineCreateFlags_t(),data_map, decoded_value.flags);
        FieldToDive(data_map, decoded_value.stageCount);
        FieldToDive(data_map, meta_struct.pStages);
        FieldToDive(data_map, decoded_value.groupCount);
        FieldToDive(data_map, meta_struct.pGroups);
        FieldToDive(data_map, decoded_value.maxPipelineRayRecursionDepth);
        FieldToDive(data_map, meta_struct.pLibraryInfo);
        FieldToDive(data_map, meta_struct.pLibraryInterface);
        FieldToDive(data_map, meta_struct.pDynamicState);
        HandleToDive(data_map, meta_struct.layout);
        HandleToDive(data_map, meta_struct.basePipelineHandle);
        FieldToDive(data_map, decoded_value.basePipelineIndex);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPipelineFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayTracingPipeline);
        FieldToDive(data_map, decoded_value.rayTracingPipelineShaderGroupHandleCaptureReplay);
        FieldToDive(data_map, decoded_value.rayTracingPipelineShaderGroupHandleCaptureReplayMixed);
        FieldToDive(data_map, decoded_value.rayTracingPipelineTraceRaysIndirect);
        FieldToDive(data_map, decoded_value.rayTraversalPrimitiveCulling);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPipelinePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.shaderGroupHandleSize);
        FieldToDive(data_map, decoded_value.maxRayRecursionDepth);
        FieldToDive(data_map, decoded_value.maxShaderGroupStride);
        FieldToDive(data_map, decoded_value.shaderGroupBaseAlignment);
        FieldToDive(data_map, decoded_value.shaderGroupHandleCaptureReplaySize);
        FieldToDive(data_map, decoded_value.maxRayDispatchInvocationCount);
        FieldToDive(data_map, decoded_value.shaderGroupHandleAlignment);
        FieldToDive(data_map, decoded_value.maxRayHitAttributeSize);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkStridedDeviceAddressRegionKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkStridedDeviceAddressRegionKHR& decoded_value = *data->decoded_value;
        const Decoded_VkStridedDeviceAddressRegionKHR& meta_struct = *data;

        FieldToDive(data_map, to_hex_variable_width(decoded_value.deviceAddress));
        FieldToDive(data_map, decoded_value.stride);
        FieldToDive(data_map, decoded_value.size);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkTraceRaysIndirectCommandKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkTraceRaysIndirectCommandKHR& decoded_value = *data->decoded_value;
        const Decoded_VkTraceRaysIndirectCommandKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.width);
        FieldToDive(data_map, decoded_value.height);
        FieldToDive(data_map, decoded_value.depth);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayQueryFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.rayQuery);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.taskShader);
        FieldToDive(data_map, decoded_value.meshShader);
        FieldToDive(data_map, decoded_value.multiviewMeshShader);
        FieldToDive(data_map, decoded_value.primitiveFragmentShadingRateMeshShader);
        FieldToDive(data_map, decoded_value.meshShaderQueries);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.sType);
        FieldToDive(data_map, decoded_value.maxTaskWorkGroupTotalCount);
        FieldToDive(data_map, &meta_struct.maxTaskWorkGroupCount);
        FieldToDive(data_map, decoded_value.maxTaskWorkGroupInvocations);
        FieldToDive(data_map, &meta_struct.maxTaskWorkGroupSize);
        FieldToDive(data_map, decoded_value.maxTaskPayloadSize);
        FieldToDive(data_map, decoded_value.maxTaskSharedMemorySize);
        FieldToDive(data_map, decoded_value.maxTaskPayloadAndSharedMemorySize);
        FieldToDive(data_map, decoded_value.maxMeshWorkGroupTotalCount);
        FieldToDive(data_map, &meta_struct.maxMeshWorkGroupCount);
        FieldToDive(data_map, decoded_value.maxMeshWorkGroupInvocations);
        FieldToDive(data_map, &meta_struct.maxMeshWorkGroupSize);
        FieldToDive(data_map, decoded_value.maxMeshSharedMemorySize);
        FieldToDive(data_map, decoded_value.maxMeshPayloadAndSharedMemorySize);
        FieldToDive(data_map, decoded_value.maxMeshOutputMemorySize);
        FieldToDive(data_map, decoded_value.maxMeshPayloadAndOutputMemorySize);
        FieldToDive(data_map, decoded_value.maxMeshOutputComponents);
        FieldToDive(data_map, decoded_value.maxMeshOutputVertices);
        FieldToDive(data_map, decoded_value.maxMeshOutputPrimitives);
        FieldToDive(data_map, decoded_value.maxMeshOutputLayers);
        FieldToDive(data_map, decoded_value.maxMeshMultiviewViewCount);
        FieldToDive(data_map, decoded_value.meshOutputPerVertexGranularity);
        FieldToDive(data_map, decoded_value.meshOutputPerPrimitiveGranularity);
        FieldToDive(data_map, decoded_value.maxPreferredTaskWorkGroupInvocations);
        FieldToDive(data_map, decoded_value.maxPreferredMeshWorkGroupInvocations);
        FieldToDive(data_map, decoded_value.prefersLocalInvocationVertexOutput);
        FieldToDive(data_map, decoded_value.prefersLocalInvocationPrimitiveOutput);
        FieldToDive(data_map, decoded_value.prefersCompactVertexOutput);
        FieldToDive(data_map, decoded_value.prefersCompactPrimitiveOutput);
        FieldToDive(data_map, meta_struct.pNext);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const Decoded_VkDrawMeshTasksIndirectCommandEXT* data)
{
    if (data && data->decoded_value)
    {
        const VkDrawMeshTasksIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrawMeshTasksIndirectCommandEXT& meta_struct = *data;

        FieldToDive(data_map, decoded_value.groupCountX);
        FieldToDive(data_map, decoded_value.groupCountY);
        FieldToDive(data_map, decoded_value.groupCountZ);
    }
}

void FieldToDive(std::map<std::string, std::map<std::string, std::string>>& data_map, const PNextNode* data)
{
    if (data && data->GetPointer())
    {
        const auto s_type = reinterpret_cast<const VkBaseInStructure*>(data->GetPointer())->sType;
        switch (s_type)
        {
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureGeometrySpheresDataNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureMotionInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAmigoProfilingSubmitInfoSEC*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferUsageANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentDescriptionStencilLayout*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentReferenceStencilLayout*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentSampleCountInfoAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindBufferMemoryDeviceGroupInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindImageMemoryDeviceGroupInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindImageMemorySwapchainInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindImagePlaneMemoryInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindMemoryStatus*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBlitImageCubicWeightsInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBufferDeviceAddressCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBufferOpaqueCaptureAddressCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBufferUsageFlags2CreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceRenderingInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkComputePipelineIndirectBufferInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCopyCommandTransformInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkD3D12FenceSubmitInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDebugReportCallbackCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDebugUtilsMessengerCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDebugUtilsObjectNameInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDedicatedAllocationBufferCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDedicatedAllocationImageCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDepthBiasRepresentationInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceAddressBindingCallbackDataEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupBindSparseInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupCommandBufferBeginInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupDeviceCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupPresentInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupRenderPassBeginInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupSubmitInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupSwapchainCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDevicePrivateDataCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceQueueGlobalPriorityCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDirectDriverLoadingListLUNARG*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplayModeStereoPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplayPresentInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplaySurfaceStereoCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDrmFormatModifierPropertiesList2EXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDrmFormatModifierPropertiesListEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportFenceCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportFenceWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryAllocateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryAllocateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportSemaphoreCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportSemaphoreWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalFormatANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalImageFormatProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryAcquireUnmodifiedEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryBufferCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFormatProperties3*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFragmentShadingRateAttachmentInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFrameBoundaryEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFramebufferAttachmentsCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGeneratedCommandsPipelineInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGeneratedCommandsShaderInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkHdrVividDynamicMetadataHUAWEI*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkHostImageCopyDevicePerformanceQuery*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageAlignmentControlCreateInfoMESA*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageCompressionControlEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageCompressionPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageDrmFormatModifierListCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageFormatListCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImagePlaneMemoryRequirementsInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageStencilUsageCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageSwapchainCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewASTCDecodeModeEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewMinLodCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewSampleWeightCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewSlicedCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewUsageCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportAndroidHardwareBufferInfoANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryFdInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryHostPointerInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryMetalHandleInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkLatencySubmissionPresentIdNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkLatencySurfaceCapabilitiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkLayerSettingsCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryAllocateFlagsInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryBarrier2*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryBarrierAccessFlags3KHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryDedicatedAllocateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryDedicatedRequirements*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryMapPlacedInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryPriorityAllocateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMultisampledRenderToSingleSampledInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMultiviewPerViewAttributesInfoNVX*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMutableDescriptorTypeCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkOpticalFlowImageFormatInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPartitionedAccelerationStructureFlagsNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPerformanceQuerySubmitInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevice16BitStorageFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevice8BitStorageFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthStencilResolveProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDriverProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDrmPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDynamicRenderingFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalImageFormatInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFaultFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFeatures2*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFloatControlsProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHostImageCopyFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHostImageCopyProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHostQueryResetFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceIDProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageRobustnessFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceIndexTypeUint8Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance3Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance4Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance4Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance5Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance5Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance6Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance6Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineRobustnessFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineRobustnessProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePointClippingProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentIdFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePrivateDataFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePushDescriptorProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRobustness2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRobustness2PropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicInt64Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCorePropertiesARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloat16Int8Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloatControls2Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSynchronization2Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVariablePointersFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan11Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan11Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan12Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan12Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan13Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan13Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan14Features*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan14Properties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineBinaryInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineColorWriteCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCompilerControlCreateInfoAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCoverageModulationStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCoverageReductionStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCoverageToColorStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCreateFlags2CreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCreationFeedbackCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineLayoutCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineLibraryCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationLineStateCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRenderingCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRobustnessCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineVertexInputDivisorStateCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportWScalingStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentFrameTokenGGP*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentIdKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentRegionsKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentTimesInfoGOOGLE*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkProtectedSubmitInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryLowLatencySupportNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryPoolPerformanceCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyCheckpointProperties2NV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyCheckpointPropertiesNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyGlobalPriorityProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyVideoPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassAttachmentBeginInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassCreationControlEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassInputAttachmentAspectCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassMultiviewCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassSampleLocationsBeginInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassStripeBeginInfoARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassStripeSubmitInfoARM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassTransformBeginInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingAttachmentLocationInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingInputAttachmentIndexInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSampleLocationsInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerCubicWeightsCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerCustomBorderColorCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerReductionModeCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerYcbcrConversionImageFormatProperties*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerYcbcrConversionInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSemaphoreTypeCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSetPresentConfigNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkShaderModuleCreateInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkShaderModuleValidationCacheCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSharedPresentSurfaceCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubpassDescriptionDepthStencilResolve*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubpassFragmentDensityMapOffsetEndInfoQCOM*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubpassResolvePerformanceQueryEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubresourceHostMemcpySize*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceCapabilitiesPresentBarrierNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfacePresentModeCompatibilityEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfacePresentModeEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfacePresentScalingCapabilitiesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceProtectedCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainCounterCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainLatencyCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentBarrierCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentFenceInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentModeInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentModesCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentScalingCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTextureLODGatherFormatPropertiesAMD*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTimelineSemaphoreSubmitInfo*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkValidationFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkValidationFlagsEXT*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeUsageInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1RateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264RateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265RateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQualityLevelInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQuantizationMapInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeRateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeUsageInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoFormatQuantizationMapPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoInlineQueryInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoProfileListInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetAccelerationStructureKHR*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetAccelerationStructureNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetInlineUniformBlock*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV*>(data->GetMetaStructPointer());
                FieldToDive(data_map, pnext);
                break;
            }

            default:
            {
                GFXRECON_LOG_WARNING("Unknown pnext node type: %u.", (unsigned) s_type);
            }
        }
    }
}

GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
