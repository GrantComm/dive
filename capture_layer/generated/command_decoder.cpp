/*
 * Copyright (C) 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

#include "command_decoder.h"
#include "command_arguments.h"
#include "command_printer.h"
#include "vulkan_metadata.h"

namespace Dive
{
VkBufferCreateInfo *CommandDecoder::CopyArray(const VkBufferCreateInfo *src,
                                              uint64_t                  start_index,
                                              uint64_t                  count)
{
    size_t alloc_size = sizeof(VkBufferCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkBufferCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;              // enum
        ptr[i].pNext = src[start_index + i].pNext;              // ptr void
        ptr[i].flags = src[start_index + i].flags;              // VkBufferCreateFlags
        ptr[i].size = src[start_index + i].size;                // VkDeviceSize
        ptr[i].usage = src[start_index + i].usage;              // VkBufferUsageFlags
        ptr[i].sharingMode = src[start_index + i].sharingMode;  // enum
        ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;  // uint32_t
        ptr[i].pQueueFamilyIndices = nullptr;
        if (src[start_index + i].pQueueFamilyIndices &&
            NextDecodeOffset() + sizeof(uint32_t) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].pQueueFamilyIndices)
        {
            ptr[i].pQueueFamilyIndices = CopyArray(reinterpret_cast<uint32_t const *>(
                                                   m_data + NextDecodeOffset()),
                                                   0,
                                                   1);  // ptr uint32_t // TODO (b/184758440): do we
                                                        // know count?
        }
    }
    return ptr;
}

VkBufferViewCreateInfo *CommandDecoder::CopyArray(const VkBufferViewCreateInfo *src,
                                                  uint64_t                      start_index,
                                                  uint64_t                      count)
{
    size_t alloc_size = sizeof(VkBufferViewCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkBufferViewCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;    // enum
        ptr[i].pNext = src[start_index + i].pNext;    // ptr void
        ptr[i].flags = src[start_index + i].flags;    // VkBufferViewCreateFlags
        ptr[i].buffer = src[start_index + i].buffer;  // VkBuffer
        ptr[i].format = src[start_index + i].format;  // enum
        ptr[i].offset = src[start_index + i].offset;  // VkDeviceSize
        ptr[i].range = src[start_index + i].range;    // VkDeviceSize
    }
    return ptr;
}

VkCommandBufferBeginInfo *CommandDecoder::CopyArray(const VkCommandBufferBeginInfo *src,
                                                    uint64_t                        start_index,
                                                    uint64_t                        count)
{
    size_t alloc_size = sizeof(VkCommandBufferBeginInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkCommandBufferBeginInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;  // enum
        ptr[i].pNext = src[start_index + i].pNext;  // ptr void
        ptr[i].flags = src[start_index + i].flags;  // VkCommandBufferUsageFlags
        ptr[i].pInheritanceInfo = nullptr;
        if (src[start_index + i].pInheritanceInfo &&
            NextDecodeOffset() + sizeof(VkCommandBufferInheritanceInfo) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].pInheritanceInfo)
        {
            ptr[i]
            .pInheritanceInfo = CopyArray(reinterpret_cast<VkCommandBufferInheritanceInfo const *>(
                                          m_data + NextDecodeOffset()),
                                          0,
                                          1);  // ptr VkCommandBufferInheritanceInfo // TODO
                                               // (b/184758440): do we know count?
        }
    }
    return ptr;
}

VkBufferCopy *CommandDecoder::CopyArray(const VkBufferCopy *src,
                                        uint64_t            start_index,
                                        uint64_t            count)
{
    size_t alloc_size = sizeof(VkBufferCopy) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkBufferCopy *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].srcOffset = src[start_index + i].srcOffset;  // VkDeviceSize
        ptr[i].dstOffset = src[start_index + i].dstOffset;  // VkDeviceSize
        ptr[i].size = src[start_index + i].size;            // VkDeviceSize
    }
    return ptr;
}

VkImageCopy *CommandDecoder::CopyArray(const VkImageCopy *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkImageCopy) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageCopy *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;  // VkImageSubresourceLayers
        ptr[i].srcOffset = src[start_index + i].srcOffset;            // VkOffset3D
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;  // VkImageSubresourceLayers
        ptr[i].dstOffset = src[start_index + i].dstOffset;            // VkOffset3D
        ptr[i].extent = src[start_index + i].extent;                  // VkExtent3D
    }
    return ptr;
}

VkImageBlit *CommandDecoder::CopyArray(const VkImageBlit *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkImageBlit) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageBlit *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;  // VkImageSubresourceLayers
        std::memcpy(ptr[i].srcOffsets,
                    src[start_index + i].srcOffsets,
                    sizeof(src[start_index + i].srcOffsets));         // staticArray
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;  // VkImageSubresourceLayers
        std::memcpy(ptr[i].dstOffsets,
                    src[start_index + i].dstOffsets,
                    sizeof(src[start_index + i].dstOffsets));  // staticArray
    }
    return ptr;
}

VkBufferImageCopy *CommandDecoder::CopyArray(const VkBufferImageCopy *src,
                                             uint64_t                 start_index,
                                             uint64_t                 count)
{
    size_t alloc_size = sizeof(VkBufferImageCopy) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkBufferImageCopy *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].bufferOffset = src[start_index + i].bufferOffset;            // VkDeviceSize
        ptr[i].bufferRowLength = src[start_index + i].bufferRowLength;      // uint32_t
        ptr[i].bufferImageHeight = src[start_index + i].bufferImageHeight;  // uint32_t
        ptr[i].imageSubresource = src[start_index + i]
                                  .imageSubresource;            // VkImageSubresourceLayers
        ptr[i].imageOffset = src[start_index + i].imageOffset;  // VkOffset3D
        ptr[i].imageExtent = src[start_index + i].imageExtent;  // VkExtent3D
    }
    return ptr;
}

VkClearColorValue *CommandDecoder::CopyArray(const VkClearColorValue *src,
                                             uint64_t                 start_index,
                                             uint64_t                 count)
{
    size_t alloc_size = sizeof(VkClearColorValue) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkClearColorValue *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        std::memcpy(ptr[i].uint32,
                    src[start_index + i].uint32,
                    sizeof(src[start_index + i].uint32));  // staticArray
    }
    return ptr;
}

VkImageSubresourceRange *CommandDecoder::CopyArray(const VkImageSubresourceRange *src,
                                                   uint64_t                       start_index,
                                                   uint64_t                       count)
{
    size_t alloc_size = sizeof(VkImageSubresourceRange) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageSubresourceRange *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].aspectMask = src[start_index + i].aspectMask;          // VkImageAspectFlags
        ptr[i].baseMipLevel = src[start_index + i].baseMipLevel;      // uint32_t
        ptr[i].levelCount = src[start_index + i].levelCount;          // uint32_t
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;  // uint32_t
        ptr[i].layerCount = src[start_index + i].layerCount;          // uint32_t
    }
    return ptr;
}

VkClearDepthStencilValue *CommandDecoder::CopyArray(const VkClearDepthStencilValue *src,
                                                    uint64_t                        start_index,
                                                    uint64_t                        count)
{
    size_t alloc_size = sizeof(VkClearDepthStencilValue) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkClearDepthStencilValue *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].depth = src[start_index + i].depth;      // float
        ptr[i].stencil = src[start_index + i].stencil;  // uint32_t
    }
    return ptr;
}

VkClearAttachment *CommandDecoder::CopyArray(const VkClearAttachment *src,
                                             uint64_t                 start_index,
                                             uint64_t                 count)
{
    size_t alloc_size = sizeof(VkClearAttachment) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkClearAttachment *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].aspectMask = src[start_index + i].aspectMask;            // VkImageAspectFlags
        ptr[i].colorAttachment = src[start_index + i].colorAttachment;  // uint32_t
        ptr[i].clearValue = src[start_index + i].clearValue;            // VkClearValue
    }
    return ptr;
}

VkClearRect *CommandDecoder::CopyArray(const VkClearRect *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkClearRect) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkClearRect *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].rect = src[start_index + i].rect;                      // VkRect2D
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;  // uint32_t
        ptr[i].layerCount = src[start_index + i].layerCount;          // uint32_t
    }
    return ptr;
}

VkImageResolve *CommandDecoder::CopyArray(const VkImageResolve *src,
                                          uint64_t              start_index,
                                          uint64_t              count)
{
    size_t alloc_size = sizeof(VkImageResolve) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageResolve *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;  // VkImageSubresourceLayers
        ptr[i].srcOffset = src[start_index + i].srcOffset;            // VkOffset3D
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;  // VkImageSubresourceLayers
        ptr[i].dstOffset = src[start_index + i].dstOffset;            // VkOffset3D
        ptr[i].extent = src[start_index + i].extent;                  // VkExtent3D
    }
    return ptr;
}

VkDescriptorSetLayoutCreateInfo *CommandDecoder::CopyArray(
const VkDescriptorSetLayoutCreateInfo *src,
uint64_t                               start_index,
uint64_t                               count)
{
    size_t alloc_size = sizeof(VkDescriptorSetLayoutCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;  // enum
        ptr[i].pNext = src[start_index + i].pNext;  // ptr void
        ptr[i].flags = src[start_index + i].flags;  // VkDescriptorSetLayoutCreateFlags
        ptr[i].bindingCount = src[start_index + i].bindingCount;  // uint32_t
        ptr[i].pBindings = nullptr;
        if (src[start_index + i].pBindings &&
            NextDecodeOffset() + sizeof(VkDescriptorSetLayoutBinding) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].bindingCount > 0 && src[start_index + i].pBindings)
        {
            ptr[i].pBindings = CopyArray(reinterpret_cast<VkDescriptorSetLayoutBinding const *>(
                                         m_data + NextDecodeOffset()),
                                         0,
                                         src[start_index + i].bindingCount);
        }
    }
    return ptr;
}

VkDescriptorSetAllocateInfo *CommandDecoder::CopyArray(const VkDescriptorSetAllocateInfo *src,
                                                       uint64_t start_index,
                                                       uint64_t count)
{
    size_t alloc_size = sizeof(VkDescriptorSetAllocateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDescriptorSetAllocateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                            // enum
        ptr[i].pNext = src[start_index + i].pNext;                            // ptr void
        ptr[i].descriptorPool = src[start_index + i].descriptorPool;          // VkDescriptorPool
        ptr[i].descriptorSetCount = src[start_index + i].descriptorSetCount;  // uint32_t
        ptr[i].pSetLayouts = nullptr;
        if (src[start_index + i].pSetLayouts &&
            NextDecodeOffset() + sizeof(VkDescriptorSetLayout) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].descriptorSetCount > 0 && src[start_index + i].pSetLayouts)
        {
            ptr[i].pSetLayouts = CopyArray(reinterpret_cast<VkDescriptorSetLayout const *>(
                                           m_data + NextDecodeOffset()),
                                           0,
                                           src[start_index + i].descriptorSetCount);
        }
    }
    return ptr;
}

VkWriteDescriptorSet *CommandDecoder::CopyArray(const VkWriteDescriptorSet *src,
                                                uint64_t                    start_index,
                                                uint64_t                    count)
{
    size_t alloc_size = sizeof(VkWriteDescriptorSet) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkWriteDescriptorSet *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                      // enum
        ptr[i].pNext = src[start_index + i].pNext;                      // ptr void
        ptr[i].dstSet = src[start_index + i].dstSet;                    // VkDescriptorSet
        ptr[i].dstBinding = src[start_index + i].dstBinding;            // uint32_t
        ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;  // uint32_t
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;  // uint32_t
        ptr[i].descriptorType = src[start_index + i].descriptorType;    // enum
        ptr[i].pImageInfo = nullptr;
        if (src[start_index + i].pImageInfo &&
            NextDecodeOffset() + sizeof(VkDescriptorImageInfo) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pImageInfo)
        {
            ptr[i].pImageInfo = CopyArray(reinterpret_cast<VkDescriptorImageInfo const *>(
                                          m_data + NextDecodeOffset()),
                                          0,
                                          src[start_index + i].descriptorCount);
        }
        ptr[i].pBufferInfo = nullptr;
        if (src[start_index + i].pBufferInfo &&
            NextDecodeOffset() + sizeof(VkDescriptorBufferInfo) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pBufferInfo)
        {
            ptr[i].pBufferInfo = CopyArray(reinterpret_cast<VkDescriptorBufferInfo const *>(
                                           m_data + NextDecodeOffset()),
                                           0,
                                           src[start_index + i].descriptorCount);
        }
        ptr[i].pTexelBufferView = nullptr;
        if (src[start_index + i].pTexelBufferView &&
            NextDecodeOffset() + sizeof(VkBufferView) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pTexelBufferView)
        {
            ptr[i].pTexelBufferView = CopyArray(reinterpret_cast<VkBufferView const *>(
                                                m_data + NextDecodeOffset()),
                                                0,
                                                src[start_index + i].descriptorCount);
        }
    }
    return ptr;
}

VkCopyDescriptorSet *CommandDecoder::CopyArray(const VkCopyDescriptorSet *src,
                                               uint64_t                   start_index,
                                               uint64_t                   count)
{
    size_t alloc_size = sizeof(VkCopyDescriptorSet) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkCopyDescriptorSet *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                      // enum
        ptr[i].pNext = src[start_index + i].pNext;                      // ptr void
        ptr[i].srcSet = src[start_index + i].srcSet;                    // VkDescriptorSet
        ptr[i].srcBinding = src[start_index + i].srcBinding;            // uint32_t
        ptr[i].srcArrayElement = src[start_index + i].srcArrayElement;  // uint32_t
        ptr[i].dstSet = src[start_index + i].dstSet;                    // VkDescriptorSet
        ptr[i].dstBinding = src[start_index + i].dstBinding;            // uint32_t
        ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;  // uint32_t
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;  // uint32_t
    }
    return ptr;
}

VkImageCreateInfo *CommandDecoder::CopyArray(const VkImageCreateInfo *src,
                                             uint64_t                 start_index,
                                             uint64_t                 count)
{
    size_t alloc_size = sizeof(VkImageCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;              // enum
        ptr[i].pNext = src[start_index + i].pNext;              // ptr void
        ptr[i].flags = src[start_index + i].flags;              // VkImageCreateFlags
        ptr[i].imageType = src[start_index + i].imageType;      // enum
        ptr[i].format = src[start_index + i].format;            // enum
        ptr[i].extent = src[start_index + i].extent;            // VkExtent3D
        ptr[i].mipLevels = src[start_index + i].mipLevels;      // uint32_t
        ptr[i].arrayLayers = src[start_index + i].arrayLayers;  // uint32_t
        ptr[i].samples = src[start_index + i].samples;          // enum
        ptr[i].tiling = src[start_index + i].tiling;            // enum
        ptr[i].usage = src[start_index + i].usage;              // VkImageUsageFlags
        ptr[i].sharingMode = src[start_index + i].sharingMode;  // enum
        ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;  // uint32_t
        ptr[i].pQueueFamilyIndices = nullptr;
        if (src[start_index + i].pQueueFamilyIndices &&
            NextDecodeOffset() + sizeof(uint32_t) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].pQueueFamilyIndices)
        {
            ptr[i].pQueueFamilyIndices = CopyArray(reinterpret_cast<uint32_t const *>(
                                                   m_data + NextDecodeOffset()),
                                                   0,
                                                   1);  // ptr uint32_t // TODO (b/184758440): do we
                                                        // know count?
        }
        ptr[i].initialLayout = src[start_index + i].initialLayout;  // enum
    }
    return ptr;
}

VkImageViewCreateInfo *CommandDecoder::CopyArray(const VkImageViewCreateInfo *src,
                                                 uint64_t                     start_index,
                                                 uint64_t                     count)
{
    size_t alloc_size = sizeof(VkImageViewCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageViewCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                        // enum
        ptr[i].pNext = src[start_index + i].pNext;                        // ptr void
        ptr[i].flags = src[start_index + i].flags;                        // VkImageViewCreateFlags
        ptr[i].image = src[start_index + i].image;                        // VkImage
        ptr[i].viewType = src[start_index + i].viewType;                  // enum
        ptr[i].format = src[start_index + i].format;                      // enum
        ptr[i].components = src[start_index + i].components;              // VkComponentMapping
        ptr[i].subresourceRange = src[start_index + i].subresourceRange;  // VkImageSubresourceRange
    }
    return ptr;
}

VkViewport *CommandDecoder::CopyArray(const VkViewport *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkViewport) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkViewport *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].x = src[start_index + i].x;                // float
        ptr[i].y = src[start_index + i].y;                // float
        ptr[i].width = src[start_index + i].width;        // float
        ptr[i].height = src[start_index + i].height;      // float
        ptr[i].minDepth = src[start_index + i].minDepth;  // float
        ptr[i].maxDepth = src[start_index + i].maxDepth;  // float
    }
    return ptr;
}

VkRect2D *CommandDecoder::CopyArray(const VkRect2D *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkRect2D) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkRect2D *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].offset = src[start_index + i].offset;  // VkOffset2D
        ptr[i].extent = src[start_index + i].extent;  // VkExtent2D
    }
    return ptr;
}

VkSubmitInfo *CommandDecoder::CopyArray(const VkSubmitInfo *src,
                                        uint64_t            start_index,
                                        uint64_t            count)
{
    size_t alloc_size = sizeof(VkSubmitInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkSubmitInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                            // enum
        ptr[i].pNext = src[start_index + i].pNext;                            // ptr void
        ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;  // uint32_t
        ptr[i].pWaitSemaphores = nullptr;
        if (src[start_index + i].pWaitSemaphores &&
            NextDecodeOffset() + sizeof(VkSemaphore) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].waitSemaphoreCount > 0 && src[start_index + i].pWaitSemaphores)
        {
            ptr[i].pWaitSemaphores = CopyArray(reinterpret_cast<VkSemaphore const *>(
                                               m_data + NextDecodeOffset()),
                                               0,
                                               src[start_index + i].waitSemaphoreCount);
        }
        ptr[i].pWaitDstStageMask = nullptr;
        if (src[start_index + i].pWaitDstStageMask &&
            NextDecodeOffset() + sizeof(VkPipelineStageFlags) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].waitSemaphoreCount > 0 && src[start_index + i].pWaitDstStageMask)
        {
            ptr[i].pWaitDstStageMask = CopyArray(reinterpret_cast<VkPipelineStageFlags const *>(
                                                 m_data + NextDecodeOffset()),
                                                 0,
                                                 src[start_index + i].waitSemaphoreCount);
        }
        ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;  // uint32_t
        ptr[i].pCommandBuffers = nullptr;
        if (src[start_index + i].pCommandBuffers &&
            NextDecodeOffset() + sizeof(VkCommandBuffer) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].commandBufferCount > 0 && src[start_index + i].pCommandBuffers)
        {
            ptr[i].pCommandBuffers = CopyArray(reinterpret_cast<VkCommandBuffer const *>(
                                               m_data + NextDecodeOffset()),
                                               0,
                                               src[start_index + i].commandBufferCount);
        }
        ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;  // uint32_t
        ptr[i].pSignalSemaphores = nullptr;
        if (src[start_index + i].pSignalSemaphores &&
            NextDecodeOffset() + sizeof(VkSemaphore) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].signalSemaphoreCount > 0 && src[start_index + i].pSignalSemaphores)
        {
            ptr[i].pSignalSemaphores = CopyArray(reinterpret_cast<VkSemaphore const *>(
                                                 m_data + NextDecodeOffset()),
                                                 0,
                                                 src[start_index + i].signalSemaphoreCount);
        }
    }
    return ptr;
}

VkFramebufferCreateInfo *CommandDecoder::CopyArray(const VkFramebufferCreateInfo *src,
                                                   uint64_t                       start_index,
                                                   uint64_t                       count)
{
    size_t alloc_size = sizeof(VkFramebufferCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkFramebufferCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                      // enum
        ptr[i].pNext = src[start_index + i].pNext;                      // ptr void
        ptr[i].flags = src[start_index + i].flags;                      // VkFramebufferCreateFlags
        ptr[i].renderPass = src[start_index + i].renderPass;            // VkRenderPass
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;  // uint32_t
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments &&
            NextDecodeOffset() + sizeof(VkImageView) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].attachmentCount > 0 && src[start_index + i].pAttachments)
        {
            ptr[i].pAttachments = CopyArray(reinterpret_cast<VkImageView const *>(
                                            m_data + NextDecodeOffset()),
                                            0,
                                            src[start_index + i].attachmentCount);
        }
        ptr[i].width = src[start_index + i].width;    // uint32_t
        ptr[i].height = src[start_index + i].height;  // uint32_t
        ptr[i].layers = src[start_index + i].layers;  // uint32_t
    }
    return ptr;
}

VkRenderPassCreateInfo *CommandDecoder::CopyArray(const VkRenderPassCreateInfo *src,
                                                  uint64_t                      start_index,
                                                  uint64_t                      count)
{
    size_t alloc_size = sizeof(VkRenderPassCreateInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkRenderPassCreateInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                      // enum
        ptr[i].pNext = src[start_index + i].pNext;                      // ptr void
        ptr[i].flags = src[start_index + i].flags;                      // VkRenderPassCreateFlags
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;  // uint32_t
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments &&
            NextDecodeOffset() + sizeof(VkAttachmentDescription) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].attachmentCount > 0 && src[start_index + i].pAttachments)
        {
            ptr[i].pAttachments = CopyArray(reinterpret_cast<VkAttachmentDescription const *>(
                                            m_data + NextDecodeOffset()),
                                            0,
                                            src[start_index + i].attachmentCount);
        }
        ptr[i].subpassCount = src[start_index + i].subpassCount;  // uint32_t
        ptr[i].pSubpasses = nullptr;
        if (src[start_index + i].pSubpasses &&
            NextDecodeOffset() + sizeof(VkSubpassDescription) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].subpassCount > 0 && src[start_index + i].pSubpasses)
        {
            ptr[i].pSubpasses = CopyArray(reinterpret_cast<VkSubpassDescription const *>(
                                          m_data + NextDecodeOffset()),
                                          0,
                                          src[start_index + i].subpassCount);
        }
        ptr[i].dependencyCount = src[start_index + i].dependencyCount;  // uint32_t
        ptr[i].pDependencies = nullptr;
        if (src[start_index + i].pDependencies &&
            NextDecodeOffset() + sizeof(VkSubpassDependency) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].dependencyCount > 0 && src[start_index + i].pDependencies)
        {
            ptr[i].pDependencies = CopyArray(reinterpret_cast<VkSubpassDependency const *>(
                                             m_data + NextDecodeOffset()),
                                             0,
                                             src[start_index + i].dependencyCount);
        }
    }
    return ptr;
}

VkRenderPassBeginInfo *CommandDecoder::CopyArray(const VkRenderPassBeginInfo *src,
                                                 uint64_t                     start_index,
                                                 uint64_t                     count)
{
    size_t alloc_size = sizeof(VkRenderPassBeginInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkRenderPassBeginInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                      // enum
        ptr[i].pNext = src[start_index + i].pNext;                      // ptr void
        ptr[i].renderPass = src[start_index + i].renderPass;            // VkRenderPass
        ptr[i].framebuffer = src[start_index + i].framebuffer;          // VkFramebuffer
        ptr[i].renderArea = src[start_index + i].renderArea;            // VkRect2D
        ptr[i].clearValueCount = src[start_index + i].clearValueCount;  // uint32_t
        ptr[i].pClearValues = nullptr;
        if (src[start_index + i].pClearValues &&
            NextDecodeOffset() + sizeof(VkClearValue) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].clearValueCount > 0 && src[start_index + i].pClearValues)
        {
            // version 0.1 and before only recorded 1 value in the array.
            if (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version <= 1)
            {
                ptr[i].pClearValues = CopyArray(reinterpret_cast<VkClearValue const *>(
                                                m_data + NextDecodeOffset()),
                                                0,
                                                1);  // ptr VkClearValue
            }
            else
            {
                ptr[i].pClearValues = CopyArray(reinterpret_cast<VkClearValue const *>(
                                                m_data + NextDecodeOffset()),
                                                0,
                                                src[start_index + i]
                                                .clearValueCount);  // ptr VkClearValue
            }
        }
    }
    return ptr;
}

VkMemoryBarrier *CommandDecoder::CopyArray(const VkMemoryBarrier *src,
                                           uint64_t               start_index,
                                           uint64_t               count)
{
    size_t alloc_size = sizeof(VkMemoryBarrier) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkMemoryBarrier *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                  // enum
        ptr[i].pNext = src[start_index + i].pNext;                  // ptr void
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;  // VkAccessFlags
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;  // VkAccessFlags
    }
    return ptr;
}

VkBufferMemoryBarrier *CommandDecoder::CopyArray(const VkBufferMemoryBarrier *src,
                                                 uint64_t                     start_index,
                                                 uint64_t                     count)
{
    size_t alloc_size = sizeof(VkBufferMemoryBarrier) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkBufferMemoryBarrier *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                              // enum
        ptr[i].pNext = src[start_index + i].pNext;                              // ptr void
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;              // VkAccessFlags
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;              // VkAccessFlags
        ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;  // uint32_t
        ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;  // uint32_t
        ptr[i].buffer = src[start_index + i].buffer;                            // VkBuffer
        ptr[i].offset = src[start_index + i].offset;                            // VkDeviceSize
        ptr[i].size = src[start_index + i].size;                                // VkDeviceSize
    }
    return ptr;
}

VkImageMemoryBarrier *CommandDecoder::CopyArray(const VkImageMemoryBarrier *src,
                                                uint64_t                    start_index,
                                                uint64_t                    count)
{
    size_t alloc_size = sizeof(VkImageMemoryBarrier) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageMemoryBarrier *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                              // enum
        ptr[i].pNext = src[start_index + i].pNext;                              // ptr void
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;              // VkAccessFlags
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;              // VkAccessFlags
        ptr[i].oldLayout = src[start_index + i].oldLayout;                      // enum
        ptr[i].newLayout = src[start_index + i].newLayout;                      // enum
        ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;  // uint32_t
        ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;  // uint32_t
        ptr[i].image = src[start_index + i].image;                              // VkImage
        ptr[i].subresourceRange = src[start_index + i].subresourceRange;  // VkImageSubresourceRange
    }
    return ptr;
}

VkConditionalRenderingBeginInfoEXT *CommandDecoder::CopyArray(
const VkConditionalRenderingBeginInfoEXT *src,
uint64_t                                  start_index,
uint64_t                                  count)
{
    size_t alloc_size = sizeof(VkConditionalRenderingBeginInfoEXT) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkConditionalRenderingBeginInfoEXT *>(
    m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;    // enum
        ptr[i].pNext = src[start_index + i].pNext;    // ptr void
        ptr[i].buffer = src[start_index + i].buffer;  // VkBuffer
        ptr[i].offset = src[start_index + i].offset;  // VkDeviceSize
        ptr[i].flags = src[start_index + i].flags;    // VkConditionalRenderingFlagsEXT
    }
    return ptr;
}

VkDebugMarkerMarkerInfoEXT *CommandDecoder::CopyArray(const VkDebugMarkerMarkerInfoEXT *src,
                                                      uint64_t                          start_index,
                                                      uint64_t                          count)
{
    size_t alloc_size = sizeof(VkDebugMarkerMarkerInfoEXT) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDebugMarkerMarkerInfoEXT *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;  // enum
        ptr[i].pNext = src[start_index + i].pNext;  // ptr void
        ptr[i].pMarkerName = nullptr;
        if (src[start_index + i].pMarkerName)
        {
            const char *str = reinterpret_cast<const char *>(m_data + NextDecodeOffset());
            uint64_t    max_str_len = this->GetDataSize() - NextDecodeOffset() - 1;
            ptr[i].pMarkerName = CopyString(str, max_str_len);
        }
        std::memcpy(ptr[i].color,
                    src[start_index + i].color,
                    sizeof(src[start_index + i].color));  // staticArray
    }
    return ptr;
}

VkDebugUtilsLabelEXT *CommandDecoder::CopyArray(const VkDebugUtilsLabelEXT *src,
                                                uint64_t                    start_index,
                                                uint64_t                    count)
{
    size_t alloc_size = sizeof(VkDebugUtilsLabelEXT) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDebugUtilsLabelEXT *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;  // enum
        ptr[i].pNext = src[start_index + i].pNext;  // ptr void
        ptr[i].pLabelName = nullptr;
        if (src[start_index + i].pLabelName)
        {
            const char *str = reinterpret_cast<const char *>(m_data + NextDecodeOffset());
            uint64_t    max_str_len = this->GetDataSize() - NextDecodeOffset() - 1;
            ptr[i].pLabelName = CopyString(str, max_str_len);
        }
        std::memcpy(ptr[i].color,
                    src[start_index + i].color,
                    sizeof(src[start_index + i].color));  // staticArray
    }
    return ptr;
}

VkCommandBufferInheritanceInfo *CommandDecoder::CopyArray(const VkCommandBufferInheritanceInfo *src,
                                                          uint64_t start_index,
                                                          uint64_t count)
{
    size_t alloc_size = sizeof(VkCommandBufferInheritanceInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkCommandBufferInheritanceInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sType = src[start_index + i].sType;                                // enum
        ptr[i].pNext = src[start_index + i].pNext;                                // ptr void
        ptr[i].renderPass = src[start_index + i].renderPass;                      // VkRenderPass
        ptr[i].subpass = src[start_index + i].subpass;                            // uint32_t
        ptr[i].framebuffer = src[start_index + i].framebuffer;                    // VkFramebuffer
        ptr[i].occlusionQueryEnable = src[start_index + i].occlusionQueryEnable;  // VkBool32
        ptr[i].queryFlags = src[start_index + i].queryFlags;  // VkQueryControlFlags
        ptr[i].pipelineStatistics = src[start_index + i]
                                    .pipelineStatistics;  // VkQueryPipelineStatisticFlags
    }
    return ptr;
}

VkImageSubresourceLayers *CommandDecoder::CopyArray(const VkImageSubresourceLayers *src,
                                                    uint64_t                        start_index,
                                                    uint64_t                        count)
{
    size_t alloc_size = sizeof(VkImageSubresourceLayers) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkImageSubresourceLayers *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].aspectMask = src[start_index + i].aspectMask;          // VkImageAspectFlags
        ptr[i].mipLevel = src[start_index + i].mipLevel;              // uint32_t
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;  // uint32_t
        ptr[i].layerCount = src[start_index + i].layerCount;          // uint32_t
    }
    return ptr;
}

VkOffset3D *CommandDecoder::CopyArray(const VkOffset3D *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkOffset3D) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkOffset3D *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].x = src[start_index + i].x;  // int32_t
        ptr[i].y = src[start_index + i].y;  // int32_t
        ptr[i].z = src[start_index + i].z;  // int32_t
    }
    return ptr;
}

VkExtent3D *CommandDecoder::CopyArray(const VkExtent3D *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkExtent3D) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkExtent3D *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].width = src[start_index + i].width;    // uint32_t
        ptr[i].height = src[start_index + i].height;  // uint32_t
        ptr[i].depth = src[start_index + i].depth;    // uint32_t
    }
    return ptr;
}

VkClearValue *CommandDecoder::CopyArray(const VkClearValue *src,
                                        uint64_t            start_index,
                                        uint64_t            count)
{
    size_t alloc_size = sizeof(VkClearValue) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkClearValue *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].color = src[start_index + i].color;  // VkClearColorValue
    }
    return ptr;
}

VkDescriptorSetLayoutBinding *CommandDecoder::CopyArray(const VkDescriptorSetLayoutBinding *src,
                                                        uint64_t start_index,
                                                        uint64_t count)
{
    size_t alloc_size = sizeof(VkDescriptorSetLayoutBinding) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutBinding *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].binding = src[start_index + i].binding;                  // uint32_t
        ptr[i].descriptorType = src[start_index + i].descriptorType;    // enum
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;  // uint32_t
        ptr[i].stageFlags = src[start_index + i].stageFlags;            // VkShaderStageFlags
        ptr[i].pImmutableSamplers = nullptr;
        if (src[start_index + i].pImmutableSamplers &&
            NextDecodeOffset() + sizeof(VkSampler) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pImmutableSamplers)
        {
            ptr[i].pImmutableSamplers = CopyArray(reinterpret_cast<VkSampler const *>(
                                                  m_data + NextDecodeOffset()),
                                                  0,
                                                  src[start_index + i].descriptorCount);
        }
    }
    return ptr;
}

VkDescriptorImageInfo *CommandDecoder::CopyArray(const VkDescriptorImageInfo *src,
                                                 uint64_t                     start_index,
                                                 uint64_t                     count)
{
    size_t alloc_size = sizeof(VkDescriptorImageInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDescriptorImageInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].sampler = src[start_index + i].sampler;          // VkSampler
        ptr[i].imageView = src[start_index + i].imageView;      // VkImageView
        ptr[i].imageLayout = src[start_index + i].imageLayout;  // enum
    }
    return ptr;
}

VkDescriptorBufferInfo *CommandDecoder::CopyArray(const VkDescriptorBufferInfo *src,
                                                  uint64_t                      start_index,
                                                  uint64_t                      count)
{
    size_t alloc_size = sizeof(VkDescriptorBufferInfo) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkDescriptorBufferInfo *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].buffer = src[start_index + i].buffer;  // VkBuffer
        ptr[i].offset = src[start_index + i].offset;  // VkDeviceSize
        ptr[i].range = src[start_index + i].range;    // VkDeviceSize
    }
    return ptr;
}

VkComponentMapping *CommandDecoder::CopyArray(const VkComponentMapping *src,
                                              uint64_t                  start_index,
                                              uint64_t                  count)
{
    size_t alloc_size = sizeof(VkComponentMapping) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkComponentMapping *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].r = src[start_index + i].r;  // enum
        ptr[i].g = src[start_index + i].g;  // enum
        ptr[i].b = src[start_index + i].b;  // enum
        ptr[i].a = src[start_index + i].a;  // enum
    }
    return ptr;
}

VkOffset2D *CommandDecoder::CopyArray(const VkOffset2D *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkOffset2D) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkOffset2D *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].x = src[start_index + i].x;  // int32_t
        ptr[i].y = src[start_index + i].y;  // int32_t
    }
    return ptr;
}

VkExtent2D *CommandDecoder::CopyArray(const VkExtent2D *src, uint64_t start_index, uint64_t count)
{
    size_t alloc_size = sizeof(VkExtent2D) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkExtent2D *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].width = src[start_index + i].width;    // uint32_t
        ptr[i].height = src[start_index + i].height;  // uint32_t
    }
    return ptr;
}

VkAttachmentDescription *CommandDecoder::CopyArray(const VkAttachmentDescription *src,
                                                   uint64_t                       start_index,
                                                   uint64_t                       count)
{
    size_t alloc_size = sizeof(VkAttachmentDescription) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkAttachmentDescription *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].flags = src[start_index + i].flags;                  // VkAttachmentDescriptionFlags
        ptr[i].format = src[start_index + i].format;                // enum
        ptr[i].samples = src[start_index + i].samples;              // enum
        ptr[i].loadOp = src[start_index + i].loadOp;                // enum
        ptr[i].storeOp = src[start_index + i].storeOp;              // enum
        ptr[i].stencilLoadOp = src[start_index + i].stencilLoadOp;  // enum
        ptr[i].stencilStoreOp = src[start_index + i].stencilStoreOp;  // enum
        ptr[i].initialLayout = src[start_index + i].initialLayout;    // enum
        ptr[i].finalLayout = src[start_index + i].finalLayout;        // enum
    }
    return ptr;
}

VkSubpassDescription *CommandDecoder::CopyArray(const VkSubpassDescription *src,
                                                uint64_t                    start_index,
                                                uint64_t                    count)
{
    size_t alloc_size = sizeof(VkSubpassDescription) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkSubpassDescription *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].flags = src[start_index + i].flags;  // VkSubpassDescriptionFlags
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;        // enum
        ptr[i].inputAttachmentCount = src[start_index + i].inputAttachmentCount;  // uint32_t
        ptr[i].pInputAttachments = nullptr;
        if (src[start_index + i].pInputAttachments &&
            NextDecodeOffset() + sizeof(VkAttachmentReference) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].inputAttachmentCount > 0 && src[start_index + i].pInputAttachments)
        {
            ptr[i].pInputAttachments = CopyArray(reinterpret_cast<VkAttachmentReference const *>(
                                                 m_data + NextDecodeOffset()),
                                                 0,
                                                 src[start_index + i].inputAttachmentCount);
        }
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;  // uint32_t
        ptr[i].pColorAttachments = nullptr;
        if (src[start_index + i].pColorAttachments &&
            NextDecodeOffset() + sizeof(VkAttachmentReference) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].colorAttachmentCount > 0 && src[start_index + i].pColorAttachments)
        {
            ptr[i].pColorAttachments = CopyArray(reinterpret_cast<VkAttachmentReference const *>(
                                                 m_data + NextDecodeOffset()),
                                                 0,
                                                 src[start_index + i].colorAttachmentCount);
        }
        ptr[i].pResolveAttachments = nullptr;
        if (src[start_index + i].pResolveAttachments &&
            NextDecodeOffset() + sizeof(VkAttachmentReference) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].colorAttachmentCount > 0 &&
            src[start_index + i].pResolveAttachments)
        {
            ptr[i].pResolveAttachments = CopyArray(reinterpret_cast<VkAttachmentReference const *>(
                                                   m_data + NextDecodeOffset()),
                                                   0,
                                                   src[start_index + i].colorAttachmentCount);
        }
        ptr[i].pDepthStencilAttachment = nullptr;
        if (src[start_index + i].pDepthStencilAttachment &&
            NextDecodeOffset() + sizeof(VkAttachmentReference) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].pDepthStencilAttachment)
        {
            ptr[i]
            .pDepthStencilAttachment = CopyArray(reinterpret_cast<VkAttachmentReference const *>(
                                                 m_data + NextDecodeOffset()),
                                                 0,
                                                 1);  // ptr VkAttachmentReference // TODO
                                                      // (b/184758440): do we know count?
        }
        ptr[i].preserveAttachmentCount = src[start_index + i].preserveAttachmentCount;  // uint32_t
        ptr[i].pPreserveAttachments = nullptr;
        if (src[start_index + i].pPreserveAttachments &&
            NextDecodeOffset() + sizeof(uint32_t) > m_data_size)
        {
            return nullptr;
        }
        if (src[start_index + i].preserveAttachmentCount > 0 &&
            src[start_index + i].pPreserveAttachments)
        {
            ptr[i].pPreserveAttachments = CopyArray(reinterpret_cast<uint32_t const *>(
                                                    m_data + NextDecodeOffset()),
                                                    0,
                                                    src[start_index + i].preserveAttachmentCount);
        }
    }
    return ptr;
}

VkSubpassDependency *CommandDecoder::CopyArray(const VkSubpassDependency *src,
                                               uint64_t                   start_index,
                                               uint64_t                   count)
{
    size_t alloc_size = sizeof(VkSubpassDependency) * count;
    if (NextDecodeOffset() + alloc_size > m_data_size)
    {
        return nullptr;
    }
    auto ptr = reinterpret_cast<VkSubpassDependency *>(m_allocator->Alloc(alloc_size));
    if (ptr == nullptr)
    {
        return ptr;
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        ptr[i].srcSubpass = src[start_index + i].srcSubpass;            // uint32_t
        ptr[i].dstSubpass = src[start_index + i].dstSubpass;            // uint32_t
        ptr[i].srcStageMask = src[start_index + i].srcStageMask;        // VkPipelineStageFlags
        ptr[i].dstStageMask = src[start_index + i].dstStageMask;        // VkPipelineStageFlags
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;      // VkAccessFlags
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;      // VkAccessFlags
        ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;  // VkDependencyFlags
    }
    return ptr;
}

void *CommandDecoder::Decode(VKCmdID cmdId, const char *data, size_t data_size)
{
    switch (cmdId)
    {
    case VKCmdID::vkBeginCommandBufferCmdID: return DecodeBeginCommandBuffer(data, data_size);
    case VKCmdID::vkEndCommandBufferCmdID: return DecodeEndCommandBuffer(data, data_size);
    case VKCmdID::vkCmdExecuteCommandsCmdID: return DecodeCmdExecuteCommands(data, data_size);
    case VKCmdID::vkCmdCopyBufferCmdID: return DecodeCmdCopyBuffer(data, data_size);
    case VKCmdID::vkCmdCopyImageCmdID: return DecodeCmdCopyImage(data, data_size);
    case VKCmdID::vkCmdBlitImageCmdID: return DecodeCmdBlitImage(data, data_size);
    case VKCmdID::vkCmdCopyBufferToImageCmdID: return DecodeCmdCopyBufferToImage(data, data_size);
    case VKCmdID::vkCmdCopyImageToBufferCmdID: return DecodeCmdCopyImageToBuffer(data, data_size);
    case VKCmdID::vkCmdUpdateBufferCmdID: return DecodeCmdUpdateBuffer(data, data_size);
    case VKCmdID::vkCmdFillBufferCmdID: return DecodeCmdFillBuffer(data, data_size);
    case VKCmdID::vkCmdClearColorImageCmdID: return DecodeCmdClearColorImage(data, data_size);
    case VKCmdID::vkCmdClearDepthStencilImageCmdID:
        return DecodeCmdClearDepthStencilImage(data, data_size);
    case VKCmdID::vkCmdClearAttachmentsCmdID: return DecodeCmdClearAttachments(data, data_size);
    case VKCmdID::vkCmdResolveImageCmdID: return DecodeCmdResolveImage(data, data_size);
    case VKCmdID::vkCmdBindDescriptorSetsCmdID: return DecodeCmdBindDescriptorSets(data, data_size);
    case VKCmdID::vkCmdPushConstantsCmdID: return DecodeCmdPushConstants(data, data_size);
    case VKCmdID::vkCmdBindIndexBufferCmdID: return DecodeCmdBindIndexBuffer(data, data_size);
    case VKCmdID::vkCmdBindVertexBuffersCmdID: return DecodeCmdBindVertexBuffers(data, data_size);
    case VKCmdID::vkCmdDrawCmdID: return DecodeCmdDraw(data, data_size);
    case VKCmdID::vkCmdDrawIndexedCmdID: return DecodeCmdDrawIndexed(data, data_size);
    case VKCmdID::vkCmdDrawIndirectCmdID: return DecodeCmdDrawIndirect(data, data_size);
    case VKCmdID::vkCmdDrawIndexedIndirectCmdID:
        return DecodeCmdDrawIndexedIndirect(data, data_size);
    case VKCmdID::vkCmdDispatchCmdID: return DecodeCmdDispatch(data, data_size);
    case VKCmdID::vkCmdDispatchIndirectCmdID: return DecodeCmdDispatchIndirect(data, data_size);
    case VKCmdID::vkCmdBindPipelineCmdID: return DecodeCmdBindPipeline(data, data_size);
    case VKCmdID::vkCmdSetViewportCmdID: return DecodeCmdSetViewport(data, data_size);
    case VKCmdID::vkCmdSetScissorCmdID: return DecodeCmdSetScissor(data, data_size);
    case VKCmdID::vkCmdSetLineWidthCmdID: return DecodeCmdSetLineWidth(data, data_size);
    case VKCmdID::vkCmdSetDepthBiasCmdID: return DecodeCmdSetDepthBias(data, data_size);
    case VKCmdID::vkCmdSetBlendConstantsCmdID: return DecodeCmdSetBlendConstants(data, data_size);
    case VKCmdID::vkCmdSetDepthBoundsCmdID: return DecodeCmdSetDepthBounds(data, data_size);
    case VKCmdID::vkCmdSetStencilCompareMaskCmdID:
        return DecodeCmdSetStencilCompareMask(data, data_size);
    case VKCmdID::vkCmdSetStencilWriteMaskCmdID:
        return DecodeCmdSetStencilWriteMask(data, data_size);
    case VKCmdID::vkCmdSetStencilReferenceCmdID:
        return DecodeCmdSetStencilReference(data, data_size);
    case VKCmdID::vkCmdBeginQueryCmdID: return DecodeCmdBeginQuery(data, data_size);
    case VKCmdID::vkCmdEndQueryCmdID: return DecodeCmdEndQuery(data, data_size);
    case VKCmdID::vkCmdResetQueryPoolCmdID: return DecodeCmdResetQueryPool(data, data_size);
    case VKCmdID::vkCmdWriteTimestampCmdID: return DecodeCmdWriteTimestamp(data, data_size);
    case VKCmdID::vkCmdCopyQueryPoolResultsCmdID:
        return DecodeCmdCopyQueryPoolResults(data, data_size);
    case VKCmdID::vkCmdBeginRenderPassCmdID: return DecodeCmdBeginRenderPass(data, data_size);
    case VKCmdID::vkCmdNextSubpassCmdID: return DecodeCmdNextSubpass(data, data_size);
    case VKCmdID::vkCmdEndRenderPassCmdID: return DecodeCmdEndRenderPass(data, data_size);
    case VKCmdID::vkCmdSetEventCmdID: return DecodeCmdSetEvent(data, data_size);
    case VKCmdID::vkCmdResetEventCmdID: return DecodeCmdResetEvent(data, data_size);
    case VKCmdID::vkCmdWaitEventsCmdID: return DecodeCmdWaitEvents(data, data_size);
    case VKCmdID::vkCmdPipelineBarrierCmdID: return DecodeCmdPipelineBarrier(data, data_size);
    case VKCmdID::vkCmdWriteBufferMarkerAMDCmdID:
        return DecodeCmdWriteBufferMarkerAMD(data, data_size);
    case VKCmdID::vkCmdDrawIndirectCountAMDCmdID:
        return DecodeCmdDrawIndirectCountAMD(data, data_size);
    case VKCmdID::vkCmdDrawIndexedIndirectCountAMDCmdID:
        return DecodeCmdDrawIndexedIndirectCountAMD(data, data_size);
    case VKCmdID::vkCmdBeginConditionalRenderingEXTCmdID:
        return DecodeCmdBeginConditionalRenderingEXT(data, data_size);
    case VKCmdID::vkCmdEndConditionalRenderingEXTCmdID:
        return DecodeCmdEndConditionalRenderingEXT(data, data_size);
    case VKCmdID::vkCmdBeginDebugUtilsLabelEXTCmdID:
        return DecodeCmdBeginDebugUtilsLabelEXT(data, data_size);
    case VKCmdID::vkCmdEndDebugUtilsLabelEXTCmdID:
        return DecodeCmdEndDebugUtilsLabelEXT(data, data_size);
    case VKCmdID::vkCmdInsertDebugUtilsLabelEXTCmdID:
        return DecodeCmdInsertDebugUtilsLabelEXT(data, data_size);
    case VKCmdID::vkCmdSetDeviceMaskKHRCmdID: return DecodeCmdSetDeviceMaskKHR(data, data_size);
    case VKCmdID::vkCmdSetDeviceMaskCmdID: return DecodeCmdSetDeviceMask(data, data_size);
    case VKCmdID::vkCmdDispatchBaseKHRCmdID: return DecodeCmdDispatchBaseKHR(data, data_size);
    case VKCmdID::vkCmdDispatchBaseCmdID: return DecodeCmdDispatchBase(data, data_size);
    case VKCmdID::vkCmdDrawIndirectCountKHRCmdID:
        return DecodeCmdDrawIndirectCountKHR(data, data_size);
    case VKCmdID::vkCmdDrawIndexedIndirectCountKHRCmdID:
        return DecodeCmdDrawIndexedIndirectCountKHR(data, data_size);
    case VKCmdID::vkQueueSubmit: break;
    default: break;
    }
    return nullptr;
}
CreateBufferArgs *CommandDecoder::DecodeCreateBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(CreateBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateBufferArgs *src = reinterpret_cast<const CreateBufferArgs *>(m_data);
    args->device = src->device;            // VkDevice
    args->pCreateInfo = src->pCreateInfo;  // VkBufferCreateInfo*
    args->pAllocator = src->pAllocator;    // AllocationCallbacks
    args->pBuffer = src->pBuffer;          // VkBuffer*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkBufferCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferCreateInfo *>(m_data + NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkBuffer) > m_data_size)
        {
            args->pBuffer = nullptr;
            return args;
        }
        args->pBuffer = CopyArray(reinterpret_cast<const VkBuffer *>(m_data + NextDecodeOffset()),
                                  0,
                                  1);
    }
    return args;
}

CreateBufferViewArgs *CommandDecoder::DecodeCreateBufferView(const char *data, size_t data_size)
{
    if (data_size < sizeof(CreateBufferViewArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateBufferViewArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateBufferViewArgs *src = reinterpret_cast<const CreateBufferViewArgs *>(m_data);
    args->device = src->device;            // VkDevice
    args->pCreateInfo = src->pCreateInfo;  // VkBufferViewCreateInfo*
    args->pAllocator = src->pAllocator;    // AllocationCallbacks
    args->pView = src->pView;              // VkBufferView*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkBufferViewCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferViewCreateInfo *>(m_data + NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkBufferView) > m_data_size)
        {
            args->pView = nullptr;
            return args;
        }
        args->pView = CopyArray(reinterpret_cast<const VkBufferView *>(m_data + NextDecodeOffset()),
                                0,
                                1);
    }
    return args;
}

BeginCommandBufferArgs *CommandDecoder::DecodeBeginCommandBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(BeginCommandBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<BeginCommandBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const BeginCommandBufferArgs *src = reinterpret_cast<const BeginCommandBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pBeginInfo = src->pBeginInfo;        // VkCommandBufferBeginInfo*
    if (src->pBeginInfo)
    {
        if (NextDecodeOffset() + sizeof(VkCommandBufferBeginInfo) > m_data_size)
        {
            args->pBeginInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkCommandBufferBeginInfo *>(m_data + NextDecodeOffset());
        args->pBeginInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

EndCommandBufferArgs *CommandDecoder::DecodeEndCommandBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(EndCommandBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<EndCommandBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const EndCommandBufferArgs *src = reinterpret_cast<const EndCommandBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    return args;
}

ResetCommandBufferArgs *CommandDecoder::DecodeResetCommandBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(ResetCommandBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<ResetCommandBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const ResetCommandBufferArgs *src = reinterpret_cast<const ResetCommandBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->flags = src->flags;                  // VkCommandBufferResetFlags
    return args;
}

CmdExecuteCommandsArgs *CommandDecoder::DecodeCmdExecuteCommands(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdExecuteCommandsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdExecuteCommandsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdExecuteCommandsArgs *src = reinterpret_cast<const CmdExecuteCommandsArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;            // VkCommandBuffer
    args->commandBufferCount = src->commandBufferCount;  // u32
    args->pCommandBuffers = src->pCommandBuffers;        // VkCommandBuffer*
    if (src->pCommandBuffers)
    {
        if (NextDecodeOffset() + sizeof(VkCommandBuffer) > m_data_size)
        {
            args->pCommandBuffers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkCommandBuffer *>(m_data + NextDecodeOffset());
        args->pCommandBuffers = CopyArray(ptr,
                                          (uint64_t)(static_cast<uint32_t>(0U)),
                                          src->commandBufferCount);
    }
    return args;
}

CmdCopyBufferArgs *CommandDecoder::DecodeCmdCopyBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdCopyBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdCopyBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdCopyBufferArgs *src = reinterpret_cast<const CmdCopyBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->srcBuffer = src->srcBuffer;          // VkBuffer
    args->dstBuffer = src->dstBuffer;          // VkBuffer
    args->regionCount = src->regionCount;      // u32
    args->pRegions = src->pRegions;            // VkBufferCopy*
    if (src->pRegions)
    {
        if (NextDecodeOffset() + sizeof(VkBufferCopy) > m_data_size)
        {
            args->pRegions = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferCopy *>(m_data + NextDecodeOffset());
        args->pRegions = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->regionCount);
    }
    return args;
}

CmdCopyImageArgs *CommandDecoder::DecodeCmdCopyImage(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdCopyImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdCopyImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdCopyImageArgs *src = reinterpret_cast<const CmdCopyImageArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;    // VkCommandBuffer
    args->srcImage = src->srcImage;              // VkImage
    args->srcImageLayout = src->srcImageLayout;  // VkImageLayout
    args->dstImage = src->dstImage;              // VkImage
    args->dstImageLayout = src->dstImageLayout;  // VkImageLayout
    args->regionCount = src->regionCount;        // u32
    args->pRegions = src->pRegions;              // VkImageCopy*
    if (src->pRegions)
    {
        if (NextDecodeOffset() + sizeof(VkImageCopy) > m_data_size)
        {
            args->pRegions = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageCopy *>(m_data + NextDecodeOffset());
        args->pRegions = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->regionCount);
    }
    return args;
}

CmdBlitImageArgs *CommandDecoder::DecodeCmdBlitImage(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdBlitImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBlitImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBlitImageArgs *src = reinterpret_cast<const CmdBlitImageArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;    // VkCommandBuffer
    args->srcImage = src->srcImage;              // VkImage
    args->srcImageLayout = src->srcImageLayout;  // VkImageLayout
    args->dstImage = src->dstImage;              // VkImage
    args->dstImageLayout = src->dstImageLayout;  // VkImageLayout
    args->regionCount = src->regionCount;        // u32
    args->pRegions = src->pRegions;              // VkImageBlit*
    args->filter = src->filter;                  // VkFilter
    if (src->pRegions)
    {
        if (NextDecodeOffset() + sizeof(VkImageBlit) > m_data_size)
        {
            args->pRegions = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageBlit *>(m_data + NextDecodeOffset());
        args->pRegions = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->regionCount);
    }
    return args;
}

CmdCopyBufferToImageArgs *CommandDecoder::DecodeCmdCopyBufferToImage(const char *data,
                                                                     size_t      data_size)
{
    if (data_size < sizeof(CmdCopyBufferToImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdCopyBufferToImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdCopyBufferToImageArgs *src = reinterpret_cast<const CmdCopyBufferToImageArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;    // VkCommandBuffer
    args->srcBuffer = src->srcBuffer;            // VkBuffer
    args->dstImage = src->dstImage;              // VkImage
    args->dstImageLayout = src->dstImageLayout;  // VkImageLayout
    args->regionCount = src->regionCount;        // u32
    args->pRegions = src->pRegions;              // VkBufferImageCopy*
    if (src->pRegions)
    {
        if (NextDecodeOffset() + sizeof(VkBufferImageCopy) > m_data_size)
        {
            args->pRegions = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferImageCopy *>(m_data + NextDecodeOffset());
        args->pRegions = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->regionCount);
    }
    return args;
}

CmdCopyImageToBufferArgs *CommandDecoder::DecodeCmdCopyImageToBuffer(const char *data,
                                                                     size_t      data_size)
{
    if (data_size < sizeof(CmdCopyImageToBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdCopyImageToBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdCopyImageToBufferArgs *src = reinterpret_cast<const CmdCopyImageToBufferArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;    // VkCommandBuffer
    args->srcImage = src->srcImage;              // VkImage
    args->srcImageLayout = src->srcImageLayout;  // VkImageLayout
    args->dstBuffer = src->dstBuffer;            // VkBuffer
    args->regionCount = src->regionCount;        // u32
    args->pRegions = src->pRegions;              // VkBufferImageCopy*
    if (src->pRegions)
    {
        if (NextDecodeOffset() + sizeof(VkBufferImageCopy) > m_data_size)
        {
            args->pRegions = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferImageCopy *>(m_data + NextDecodeOffset());
        args->pRegions = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->regionCount);
    }
    return args;
}

CmdUpdateBufferArgs *CommandDecoder::DecodeCmdUpdateBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdUpdateBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdUpdateBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdUpdateBufferArgs *src = reinterpret_cast<const CmdUpdateBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->dstBuffer = src->dstBuffer;          // VkBuffer
    args->dstOffset = src->dstOffset;          // VkDeviceSize
    args->dataSize = src->dataSize;            // VkDeviceSize
    args->pData = src->pData;                  // void*
    return args;
}

CmdFillBufferArgs *CommandDecoder::DecodeCmdFillBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdFillBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdFillBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdFillBufferArgs *src = reinterpret_cast<const CmdFillBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->dstBuffer = src->dstBuffer;          // VkBuffer
    args->dstOffset = src->dstOffset;          // VkDeviceSize
    args->size = src->size;                    // VkDeviceSize
    args->data = src->data;                    // u32
    return args;
}

CmdClearColorImageArgs *CommandDecoder::DecodeCmdClearColorImage(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdClearColorImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdClearColorImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdClearColorImageArgs *src = reinterpret_cast<const CmdClearColorImageArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->image = src->image;                  // VkImage
    args->imageLayout = src->imageLayout;      // VkImageLayout
    args->pColor = src->pColor;                // VkClearColorValue*
    args->rangeCount = src->rangeCount;        // u32
    args->pRanges = src->pRanges;              // VkImageSubresourceRange*
    if (src->pColor)
    {
        if (NextDecodeOffset() + sizeof(VkClearColorValue) > m_data_size)
        {
            args->pColor = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkClearColorValue *>(m_data + NextDecodeOffset());
        args->pColor = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (src->pRanges)
    {
        if (NextDecodeOffset() + sizeof(VkImageSubresourceRange) > m_data_size)
        {
            args->pRanges = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageSubresourceRange *>(m_data + NextDecodeOffset());
        args->pRanges = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->rangeCount);
    }
    return args;
}

CmdClearDepthStencilImageArgs *CommandDecoder::DecodeCmdClearDepthStencilImage(const char *data,
                                                                               size_t data_size)
{
    if (data_size < sizeof(CmdClearDepthStencilImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdClearDepthStencilImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdClearDepthStencilImageArgs
    *src = reinterpret_cast<const CmdClearDepthStencilImageArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->image = src->image;                  // VkImage
    args->imageLayout = src->imageLayout;      // VkImageLayout
    args->pDepthStencil = src->pDepthStencil;  // VkClearDepthStencilValue*
    args->rangeCount = src->rangeCount;        // u32
    args->pRanges = src->pRanges;              // VkImageSubresourceRange*
    if (src->pDepthStencil)
    {
        if (NextDecodeOffset() + sizeof(VkClearDepthStencilValue) > m_data_size)
        {
            args->pDepthStencil = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkClearDepthStencilValue *>(m_data + NextDecodeOffset());
        args->pDepthStencil = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (src->pRanges)
    {
        if (NextDecodeOffset() + sizeof(VkImageSubresourceRange) > m_data_size)
        {
            args->pRanges = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageSubresourceRange *>(m_data + NextDecodeOffset());
        args->pRanges = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->rangeCount);
    }
    return args;
}

CmdClearAttachmentsArgs *CommandDecoder::DecodeCmdClearAttachments(const char *data,
                                                                   size_t      data_size)
{
    if (data_size < sizeof(CmdClearAttachmentsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdClearAttachmentsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdClearAttachmentsArgs *src = reinterpret_cast<const CmdClearAttachmentsArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;      // VkCommandBuffer
    args->attachmentCount = src->attachmentCount;  // u32
    args->pAttachments = src->pAttachments;        // VkClearAttachment*
    args->rectCount = src->rectCount;              // u32
    args->pRects = src->pRects;                    // VkClearRect*
    if (src->pAttachments)
    {
        if (NextDecodeOffset() + sizeof(VkClearAttachment) > m_data_size)
        {
            args->pAttachments = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkClearAttachment *>(m_data + NextDecodeOffset());
        args->pAttachments = CopyArray(ptr,
                                       (uint64_t)(static_cast<uint32_t>(0U)),
                                       src->attachmentCount);
    }
    if (src->pRects)
    {
        if (NextDecodeOffset() + sizeof(VkClearRect) > m_data_size)
        {
            args->pRects = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkClearRect *>(m_data + NextDecodeOffset());
        args->pRects = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->rectCount);
    }
    return args;
}

CmdResolveImageArgs *CommandDecoder::DecodeCmdResolveImage(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdResolveImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdResolveImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdResolveImageArgs *src = reinterpret_cast<const CmdResolveImageArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;    // VkCommandBuffer
    args->srcImage = src->srcImage;              // VkImage
    args->srcImageLayout = src->srcImageLayout;  // VkImageLayout
    args->dstImage = src->dstImage;              // VkImage
    args->dstImageLayout = src->dstImageLayout;  // VkImageLayout
    args->regionCount = src->regionCount;        // u32
    args->pRegions = src->pRegions;              // VkImageResolve*
    if (src->pRegions)
    {
        if (NextDecodeOffset() + sizeof(VkImageResolve) > m_data_size)
        {
            args->pRegions = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageResolve *>(m_data + NextDecodeOffset());
        args->pRegions = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->regionCount);
    }
    return args;
}

CreateDescriptorSetLayoutArgs *CommandDecoder::DecodeCreateDescriptorSetLayout(const char *data,
                                                                               size_t data_size)
{
    if (data_size < sizeof(CreateDescriptorSetLayoutArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateDescriptorSetLayoutArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateDescriptorSetLayoutArgs
    *src = reinterpret_cast<const CreateDescriptorSetLayoutArgs *>(m_data);
    args->device = src->device;            // VkDevice
    args->pCreateInfo = src->pCreateInfo;  // VkDescriptorSetLayoutCreateInfo*
    args->pAllocator = src->pAllocator;    // AllocationCallbacks
    args->pSetLayout = src->pSetLayout;    // VkDescriptorSetLayout*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkDescriptorSetLayoutCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDescriptorSetLayoutCreateInfo *>(m_data +
                                                                             NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkDescriptorSetLayout) > m_data_size)
        {
            args->pSetLayout = nullptr;
            return args;
        }
        args->pSetLayout = CopyArray(reinterpret_cast<const VkDescriptorSetLayout *>(
                                     m_data + NextDecodeOffset()),
                                     0,
                                     1);
    }
    return args;
}

AllocateDescriptorSetsArgs *CommandDecoder::DecodeAllocateDescriptorSets(const char *data,
                                                                         size_t      data_size)
{
    if (data_size < sizeof(AllocateDescriptorSetsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<AllocateDescriptorSetsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const AllocateDescriptorSetsArgs *src = reinterpret_cast<const AllocateDescriptorSetsArgs *>(
    m_data);
    args->device = src->device;                    // VkDevice
    args->pAllocateInfo = src->pAllocateInfo;      // VkDescriptorSetAllocateInfo*
    args->pDescriptorSets = src->pDescriptorSets;  // VkDescriptorSet*
    if (src->pAllocateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkDescriptorSetAllocateInfo) > m_data_size)
        {
            args->pAllocateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDescriptorSetAllocateInfo *>(m_data +
                                                                         NextDecodeOffset());
        args->pAllocateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (src->pDescriptorSets)
    {
        if (NextDecodeOffset() + sizeof(VkDescriptorSet) > m_data_size)
        {
            args->pDescriptorSets = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDescriptorSet *>(m_data + NextDecodeOffset());
        args->pDescriptorSets = CopyArray(ptr,
                                          (uint64_t)(static_cast<uint32_t>(0U)),
                                          args->pAllocateInfo->descriptorSetCount);
    }
    return args;
}

UpdateDescriptorSetsArgs *CommandDecoder::DecodeUpdateDescriptorSets(const char *data,
                                                                     size_t      data_size)
{
    if (data_size < sizeof(UpdateDescriptorSetsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<UpdateDescriptorSetsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const UpdateDescriptorSetsArgs *src = reinterpret_cast<const UpdateDescriptorSetsArgs *>(
    m_data);
    args->device = src->device;                              // VkDevice
    args->descriptorWriteCount = src->descriptorWriteCount;  // u32
    args->pDescriptorWrites = src->pDescriptorWrites;        // VkWriteDescriptorSet*
    args->descriptorCopyCount = src->descriptorCopyCount;    // u32
    args->pDescriptorCopies = src->pDescriptorCopies;        // VkCopyDescriptorSet*
    if (src->pDescriptorWrites)
    {
        if (NextDecodeOffset() + sizeof(VkWriteDescriptorSet) > m_data_size)
        {
            args->pDescriptorWrites = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkWriteDescriptorSet *>(m_data + NextDecodeOffset());
        args->pDescriptorWrites = CopyArray(ptr,
                                            (uint64_t)(static_cast<uint32_t>(0U)),
                                            src->descriptorWriteCount);
    }
    if (src->pDescriptorCopies)
    {
        if (NextDecodeOffset() + sizeof(VkCopyDescriptorSet) > m_data_size)
        {
            args->pDescriptorCopies = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkCopyDescriptorSet *>(m_data + NextDecodeOffset());
        args->pDescriptorCopies = CopyArray(ptr,
                                            (uint64_t)(static_cast<uint32_t>(0U)),
                                            src->descriptorCopyCount);
    }
    return args;
}

CmdBindDescriptorSetsArgs *CommandDecoder::DecodeCmdBindDescriptorSets(const char *data,
                                                                       size_t      data_size)
{
    if (data_size < sizeof(CmdBindDescriptorSetsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBindDescriptorSetsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBindDescriptorSetsArgs *src = reinterpret_cast<const CmdBindDescriptorSetsArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;            // VkCommandBuffer
    args->pipelineBindPoint = src->pipelineBindPoint;    // VkPipelineBindPoint
    args->layout = src->layout;                          // VkPipelineLayout
    args->firstSet = src->firstSet;                      // u32
    args->descriptorSetCount = src->descriptorSetCount;  // u32
    args->pDescriptorSets = src->pDescriptorSets;        // VkDescriptorSet*
    args->dynamicOffsetCount = src->dynamicOffsetCount;  // u32
    args->pDynamicOffsets = src->pDynamicOffsets;        // u32*
    if (src->pDescriptorSets)
    {
        if (NextDecodeOffset() + sizeof(VkDescriptorSet) > m_data_size)
        {
            args->pDescriptorSets = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDescriptorSet *>(m_data + NextDecodeOffset());
        args->pDescriptorSets = CopyArray(ptr,
                                          (uint64_t)(static_cast<uint32_t>(0U)),
                                          src->descriptorSetCount);
    }
    if (src->pDynamicOffsets)
    {
        if (NextDecodeOffset() + sizeof(uint32_t) > m_data_size)
        {
            args->pDynamicOffsets = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const uint32_t *>(m_data + NextDecodeOffset());
        args->pDynamicOffsets = CopyArray(ptr,
                                          (uint64_t)(static_cast<uint32_t>(0U)),
                                          src->dynamicOffsetCount);
    }
    return args;
}

CmdPushConstantsArgs *CommandDecoder::DecodeCmdPushConstants(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdPushConstantsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdPushConstantsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdPushConstantsArgs *src = reinterpret_cast<const CmdPushConstantsArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->layout = src->layout;                // VkPipelineLayout
    args->stageFlags = src->stageFlags;        // VkShaderStageFlags
    args->offset = src->offset;                // u32
    args->size = src->size;                    // u32
    args->pValues = src->pValues;              // void*
    return args;
}

CmdBindIndexBufferArgs *CommandDecoder::DecodeCmdBindIndexBuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdBindIndexBufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBindIndexBufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBindIndexBufferArgs *src = reinterpret_cast<const CmdBindIndexBufferArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->indexType = src->indexType;          // VkIndexType
    return args;
}

CmdBindVertexBuffersArgs *CommandDecoder::DecodeCmdBindVertexBuffers(const char *data,
                                                                     size_t      data_size)
{
    if (data_size < sizeof(CmdBindVertexBuffersArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBindVertexBuffersArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBindVertexBuffersArgs *src = reinterpret_cast<const CmdBindVertexBuffersArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->firstBinding = src->firstBinding;    // u32
    args->bindingCount = src->bindingCount;    // u32
    args->pBuffers = src->pBuffers;            // VkBuffer*
    args->pOffsets = src->pOffsets;            // VkDeviceSize*
    if (src->pBuffers)
    {
        if (NextDecodeOffset() + sizeof(VkBuffer) > m_data_size)
        {
            args->pBuffers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBuffer *>(m_data + NextDecodeOffset());
        args->pBuffers = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->bindingCount);
    }
    if (src->pOffsets)
    {
        if (NextDecodeOffset() + sizeof(VkDeviceSize) > m_data_size)
        {
            args->pOffsets = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDeviceSize *>(m_data + NextDecodeOffset());
        args->pOffsets = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->bindingCount);
    }
    return args;
}

CmdDrawArgs *CommandDecoder::DecodeCmdDraw(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdDrawArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawArgs *src = reinterpret_cast<const CmdDrawArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->vertexCount = src->vertexCount;      // u32
    args->instanceCount = src->instanceCount;  // u32
    args->firstVertex = src->firstVertex;      // u32
    args->firstInstance = src->firstInstance;  // u32
    return args;
}

CmdDrawIndexedArgs *CommandDecoder::DecodeCmdDrawIndexed(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdDrawIndexedArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndexedArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndexedArgs *src = reinterpret_cast<const CmdDrawIndexedArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->indexCount = src->indexCount;        // u32
    args->instanceCount = src->instanceCount;  // u32
    args->firstIndex = src->firstIndex;        // u32
    args->vertexOffset = src->vertexOffset;    // s32
    args->firstInstance = src->firstInstance;  // u32
    return args;
}

CmdDrawIndirectArgs *CommandDecoder::DecodeCmdDrawIndirect(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdDrawIndirectArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndirectArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndirectArgs *src = reinterpret_cast<const CmdDrawIndirectArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->drawCount = src->drawCount;          // u32
    args->stride = src->stride;                // u32
    return args;
}

CmdDrawIndexedIndirectArgs *CommandDecoder::DecodeCmdDrawIndexedIndirect(const char *data,
                                                                         size_t      data_size)
{
    if (data_size < sizeof(CmdDrawIndexedIndirectArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndexedIndirectArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndexedIndirectArgs *src = reinterpret_cast<const CmdDrawIndexedIndirectArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->drawCount = src->drawCount;          // u32
    args->stride = src->stride;                // u32
    return args;
}

CmdDispatchArgs *CommandDecoder::DecodeCmdDispatch(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdDispatchArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDispatchArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDispatchArgs *src = reinterpret_cast<const CmdDispatchArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->groupCountX = src->groupCountX;      // u32
    args->groupCountY = src->groupCountY;      // u32
    args->groupCountZ = src->groupCountZ;      // u32
    return args;
}

CmdDispatchIndirectArgs *CommandDecoder::DecodeCmdDispatchIndirect(const char *data,
                                                                   size_t      data_size)
{
    if (data_size < sizeof(CmdDispatchIndirectArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDispatchIndirectArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDispatchIndirectArgs *src = reinterpret_cast<const CmdDispatchIndirectArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    return args;
}

CreateImageArgs *CommandDecoder::DecodeCreateImage(const char *data, size_t data_size)
{
    if (data_size < sizeof(CreateImageArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateImageArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateImageArgs *src = reinterpret_cast<const CreateImageArgs *>(m_data);
    args->device = src->device;            // VkDevice
    args->pCreateInfo = src->pCreateInfo;  // VkImageCreateInfo*
    args->pAllocator = src->pAllocator;    // AllocationCallbacks
    args->pImage = src->pImage;            // VkImage*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkImageCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageCreateInfo *>(m_data + NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkImage) > m_data_size)
        {
            args->pImage = nullptr;
            return args;
        }
        args->pImage = CopyArray(reinterpret_cast<const VkImage *>(m_data + NextDecodeOffset()),
                                 0,
                                 1);
    }
    return args;
}

CreateImageViewArgs *CommandDecoder::DecodeCreateImageView(const char *data, size_t data_size)
{
    if (data_size < sizeof(CreateImageViewArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateImageViewArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateImageViewArgs *src = reinterpret_cast<const CreateImageViewArgs *>(m_data);
    args->device = src->device;            // VkDevice
    args->pCreateInfo = src->pCreateInfo;  // VkImageViewCreateInfo*
    args->pAllocator = src->pAllocator;    // AllocationCallbacks
    args->pView = src->pView;              // VkImageView*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkImageViewCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageViewCreateInfo *>(m_data + NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkImageView) > m_data_size)
        {
            args->pView = nullptr;
            return args;
        }
        args->pView = CopyArray(reinterpret_cast<const VkImageView *>(m_data + NextDecodeOffset()),
                                0,
                                1);
    }
    return args;
}

CmdBindPipelineArgs *CommandDecoder::DecodeCmdBindPipeline(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdBindPipelineArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBindPipelineArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBindPipelineArgs *src = reinterpret_cast<const CmdBindPipelineArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;          // VkCommandBuffer
    args->pipelineBindPoint = src->pipelineBindPoint;  // VkPipelineBindPoint
    args->pipeline = src->pipeline;                    // VkPipeline
    return args;
}

CmdSetViewportArgs *CommandDecoder::DecodeCmdSetViewport(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetViewportArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetViewportArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetViewportArgs *src = reinterpret_cast<const CmdSetViewportArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->firstViewport = src->firstViewport;  // u32
    args->viewportCount = src->viewportCount;  // u32
    args->pViewports = src->pViewports;        // VkViewport*
    if (src->pViewports)
    {
        if (NextDecodeOffset() + sizeof(VkViewport) > m_data_size)
        {
            args->pViewports = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkViewport *>(m_data + NextDecodeOffset());
        args->pViewports = CopyArray(ptr,
                                     (uint64_t)(static_cast<uint32_t>(0U)),
                                     src->viewportCount);
    }
    return args;
}

CmdSetScissorArgs *CommandDecoder::DecodeCmdSetScissor(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetScissorArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetScissorArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetScissorArgs *src = reinterpret_cast<const CmdSetScissorArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->firstScissor = src->firstScissor;    // u32
    args->scissorCount = src->scissorCount;    // u32
    args->pScissors = src->pScissors;          // VkRect2D*
    if (src->pScissors)
    {
        if (NextDecodeOffset() + sizeof(VkRect2D) > m_data_size)
        {
            args->pScissors = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkRect2D *>(m_data + NextDecodeOffset());
        args->pScissors = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->scissorCount);
    }
    return args;
}

CmdSetLineWidthArgs *CommandDecoder::DecodeCmdSetLineWidth(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetLineWidthArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetLineWidthArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetLineWidthArgs *src = reinterpret_cast<const CmdSetLineWidthArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->lineWidth = src->lineWidth;          // f32
    return args;
}

CmdSetDepthBiasArgs *CommandDecoder::DecodeCmdSetDepthBias(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetDepthBiasArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetDepthBiasArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetDepthBiasArgs *src = reinterpret_cast<const CmdSetDepthBiasArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;                      // VkCommandBuffer
    args->depthBiasConstantFactor = src->depthBiasConstantFactor;  // f32
    args->depthBiasClamp = src->depthBiasClamp;                    // f32
    args->depthBiasSlopeFactor = src->depthBiasSlopeFactor;        // f32
    return args;
}

CmdSetBlendConstantsArgs *CommandDecoder::DecodeCmdSetBlendConstants(const char *data,
                                                                     size_t      data_size)
{
    if (data_size < sizeof(CmdSetBlendConstantsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetBlendConstantsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetBlendConstantsArgs *src = reinterpret_cast<const CmdSetBlendConstantsArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    for (uint32_t i = 0; i < 4; ++i)
    {
        args->blendConstants[i] = src->blendConstants[i];
    }  // f32[4]
    return args;
}

CmdSetDepthBoundsArgs *CommandDecoder::DecodeCmdSetDepthBounds(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetDepthBoundsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetDepthBoundsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetDepthBoundsArgs *src = reinterpret_cast<const CmdSetDepthBoundsArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;    // VkCommandBuffer
    args->minDepthBounds = src->minDepthBounds;  // f32
    args->maxDepthBounds = src->maxDepthBounds;  // f32
    return args;
}

CmdSetStencilCompareMaskArgs *CommandDecoder::DecodeCmdSetStencilCompareMask(const char *data,
                                                                             size_t      data_size)
{
    if (data_size < sizeof(CmdSetStencilCompareMaskArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetStencilCompareMaskArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetStencilCompareMaskArgs
    *src = reinterpret_cast<const CmdSetStencilCompareMaskArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->faceMask = src->faceMask;            // VkStencilFaceFlags
    args->compareMask = src->compareMask;      // u32
    return args;
}

CmdSetStencilWriteMaskArgs *CommandDecoder::DecodeCmdSetStencilWriteMask(const char *data,
                                                                         size_t      data_size)
{
    if (data_size < sizeof(CmdSetStencilWriteMaskArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetStencilWriteMaskArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetStencilWriteMaskArgs *src = reinterpret_cast<const CmdSetStencilWriteMaskArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->faceMask = src->faceMask;            // VkStencilFaceFlags
    args->writeMask = src->writeMask;          // u32
    return args;
}

CmdSetStencilReferenceArgs *CommandDecoder::DecodeCmdSetStencilReference(const char *data,
                                                                         size_t      data_size)
{
    if (data_size < sizeof(CmdSetStencilReferenceArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetStencilReferenceArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetStencilReferenceArgs *src = reinterpret_cast<const CmdSetStencilReferenceArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->faceMask = src->faceMask;            // VkStencilFaceFlags
    args->reference = src->reference;          // u32
    return args;
}

CmdBeginQueryArgs *CommandDecoder::DecodeCmdBeginQuery(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdBeginQueryArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBeginQueryArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBeginQueryArgs *src = reinterpret_cast<const CmdBeginQueryArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->queryPool = src->queryPool;          // VkQueryPool
    args->query = src->query;                  // u32
    args->flags = src->flags;                  // VkQueryControlFlags
    return args;
}

CmdEndQueryArgs *CommandDecoder::DecodeCmdEndQuery(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdEndQueryArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdEndQueryArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdEndQueryArgs *src = reinterpret_cast<const CmdEndQueryArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->queryPool = src->queryPool;          // VkQueryPool
    args->query = src->query;                  // u32
    return args;
}

CmdResetQueryPoolArgs *CommandDecoder::DecodeCmdResetQueryPool(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdResetQueryPoolArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdResetQueryPoolArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdResetQueryPoolArgs *src = reinterpret_cast<const CmdResetQueryPoolArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->queryPool = src->queryPool;          // VkQueryPool
    args->firstQuery = src->firstQuery;        // u32
    args->queryCount = src->queryCount;        // u32
    return args;
}

CmdWriteTimestampArgs *CommandDecoder::DecodeCmdWriteTimestamp(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdWriteTimestampArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdWriteTimestampArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdWriteTimestampArgs *src = reinterpret_cast<const CmdWriteTimestampArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pipelineStage = src->pipelineStage;  // VkPipelineStageFlagBits
    args->queryPool = src->queryPool;          // VkQueryPool
    args->query = src->query;                  // u32
    return args;
}

CmdCopyQueryPoolResultsArgs *CommandDecoder::DecodeCmdCopyQueryPoolResults(const char *data,
                                                                           size_t      data_size)
{
    if (data_size < sizeof(CmdCopyQueryPoolResultsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdCopyQueryPoolResultsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdCopyQueryPoolResultsArgs *src = reinterpret_cast<const CmdCopyQueryPoolResultsArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->queryPool = src->queryPool;          // VkQueryPool
    args->firstQuery = src->firstQuery;        // u32
    args->queryCount = src->queryCount;        // u32
    args->dstBuffer = src->dstBuffer;          // VkBuffer
    args->dstOffset = src->dstOffset;          // VkDeviceSize
    args->stride = src->stride;                // VkDeviceSize
    args->flags = src->flags;                  // VkQueryResultFlags
    return args;
}

QueueSubmitArgs *CommandDecoder::DecodeQueueSubmit(const char *data, size_t data_size)
{
    if (data_size < sizeof(QueueSubmitArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<QueueSubmitArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const QueueSubmitArgs *src = reinterpret_cast<const QueueSubmitArgs *>(m_data);
    args->queue = src->queue;              // VkQueue
    args->submitCount = src->submitCount;  // u32
    args->pSubmits = src->pSubmits;        // VkSubmitInfo*
    args->fence = src->fence;              // VkFence
    if (src->pSubmits)
    {
        if (NextDecodeOffset() + sizeof(VkSubmitInfo) > m_data_size)
        {
            args->pSubmits = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkSubmitInfo *>(m_data + NextDecodeOffset());
        args->pSubmits = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->submitCount);
    }
    return args;
}

CreateFramebufferArgs *CommandDecoder::DecodeCreateFramebuffer(const char *data, size_t data_size)
{
    if (data_size < sizeof(CreateFramebufferArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateFramebufferArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateFramebufferArgs *src = reinterpret_cast<const CreateFramebufferArgs *>(m_data);
    args->device = src->device;              // VkDevice
    args->pCreateInfo = src->pCreateInfo;    // VkFramebufferCreateInfo*
    args->pAllocator = src->pAllocator;      // AllocationCallbacks
    args->pFramebuffer = src->pFramebuffer;  // VkFramebuffer*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkFramebufferCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkFramebufferCreateInfo *>(m_data + NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkFramebuffer) > m_data_size)
        {
            args->pFramebuffer = nullptr;
            return args;
        }
        args->pFramebuffer = CopyArray(reinterpret_cast<const VkFramebuffer *>(m_data +
                                                                               NextDecodeOffset()),
                                       0,
                                       1);
    }
    return args;
}

CreateRenderPassArgs *CommandDecoder::DecodeCreateRenderPass(const char *data, size_t data_size)
{
    if (data_size < sizeof(CreateRenderPassArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CreateRenderPassArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CreateRenderPassArgs *src = reinterpret_cast<const CreateRenderPassArgs *>(m_data);
    args->device = src->device;            // VkDevice
    args->pCreateInfo = src->pCreateInfo;  // VkRenderPassCreateInfo*
    args->pAllocator = src->pAllocator;    // AllocationCallbacks
    args->pRenderPass = src->pRenderPass;  // VkRenderPass*
    if (src->pCreateInfo)
    {
        if (NextDecodeOffset() + sizeof(VkRenderPassCreateInfo) > m_data_size)
        {
            args->pCreateInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkRenderPassCreateInfo *>(m_data + NextDecodeOffset());
        args->pCreateInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (m_metadata_version.m_major_version > 0 ||
        (m_metadata_version.m_major_version == 0 && m_metadata_version.m_minor_version > 2))
    {
        if (NextDecodeOffset() + sizeof(VkRenderPass) > m_data_size)
        {
            args->pRenderPass = nullptr;
            return args;
        }
        args->pRenderPass = CopyArray(reinterpret_cast<const VkRenderPass *>(m_data +
                                                                             NextDecodeOffset()),
                                      0,
                                      1);
    }
    return args;
}

CmdBeginRenderPassArgs *CommandDecoder::DecodeCmdBeginRenderPass(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdBeginRenderPassArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBeginRenderPassArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBeginRenderPassArgs *src = reinterpret_cast<const CmdBeginRenderPassArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;        // VkCommandBuffer
    args->pRenderPassBegin = src->pRenderPassBegin;  // VkRenderPassBeginInfo*
    args->contents = src->contents;                  // VkSubpassContents
    if (src->pRenderPassBegin)
    {
        if (NextDecodeOffset() + sizeof(VkRenderPassBeginInfo) > m_data_size)
        {
            args->pRenderPassBegin = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkRenderPassBeginInfo *>(m_data + NextDecodeOffset());
        args->pRenderPassBegin = CopyArray(ptr,
                                           static_cast<uint64_t>(0U),
                                           static_cast<uint64_t>(1U));
    }
    return args;
}

CmdNextSubpassArgs *CommandDecoder::DecodeCmdNextSubpass(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdNextSubpassArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdNextSubpassArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdNextSubpassArgs *src = reinterpret_cast<const CmdNextSubpassArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->contents = src->contents;            // VkSubpassContents
    return args;
}

CmdEndRenderPassArgs *CommandDecoder::DecodeCmdEndRenderPass(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdEndRenderPassArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdEndRenderPassArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdEndRenderPassArgs *src = reinterpret_cast<const CmdEndRenderPassArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    return args;
}

CmdSetEventArgs *CommandDecoder::DecodeCmdSetEvent(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetEventArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetEventArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetEventArgs *src = reinterpret_cast<const CmdSetEventArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->event = src->event;                  // VkEvent
    args->stageMask = src->stageMask;          // VkPipelineStageFlags
    return args;
}

CmdResetEventArgs *CommandDecoder::DecodeCmdResetEvent(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdResetEventArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdResetEventArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdResetEventArgs *src = reinterpret_cast<const CmdResetEventArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->event = src->event;                  // VkEvent
    args->stageMask = src->stageMask;          // VkPipelineStageFlags
    return args;
}

CmdWaitEventsArgs *CommandDecoder::DecodeCmdWaitEvents(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdWaitEventsArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdWaitEventsArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdWaitEventsArgs *src = reinterpret_cast<const CmdWaitEventsArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;                        // VkCommandBuffer
    args->eventCount = src->eventCount;                              // u32
    args->pEvents = src->pEvents;                                    // VkEvent*
    args->srcStageMask = src->srcStageMask;                          // VkPipelineStageFlags
    args->dstStageMask = src->dstStageMask;                          // VkPipelineStageFlags
    args->memoryBarrierCount = src->memoryBarrierCount;              // u32
    args->pMemoryBarriers = src->pMemoryBarriers;                    // VkMemoryBarrier*
    args->bufferMemoryBarrierCount = src->bufferMemoryBarrierCount;  // u32
    args->pBufferMemoryBarriers = src->pBufferMemoryBarriers;        // VkBufferMemoryBarrier*
    args->imageMemoryBarrierCount = src->imageMemoryBarrierCount;    // u32
    args->pImageMemoryBarriers = src->pImageMemoryBarriers;          // VkImageMemoryBarrier*
    if (src->pEvents)
    {
        if (NextDecodeOffset() + sizeof(VkEvent) > m_data_size)
        {
            args->pEvents = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkEvent *>(m_data + NextDecodeOffset());
        args->pEvents = CopyArray(ptr, (uint64_t)(static_cast<uint32_t>(0U)), src->eventCount);
    }
    if (src->pMemoryBarriers)
    {
        if (NextDecodeOffset() + sizeof(VkMemoryBarrier) > m_data_size)
        {
            args->pMemoryBarriers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkMemoryBarrier *>(m_data + NextDecodeOffset());
        args->pMemoryBarriers = CopyArray(ptr,
                                          (uint64_t)(static_cast<uint32_t>(0U)),
                                          src->memoryBarrierCount);
    }
    if (src->pBufferMemoryBarriers)
    {
        if (NextDecodeOffset() + sizeof(VkBufferMemoryBarrier) > m_data_size)
        {
            args->pBufferMemoryBarriers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferMemoryBarrier *>(m_data + NextDecodeOffset());
        args->pBufferMemoryBarriers = CopyArray(ptr,
                                                (uint64_t)(static_cast<uint32_t>(0U)),
                                                src->bufferMemoryBarrierCount);
    }
    if (src->pImageMemoryBarriers)
    {
        if (NextDecodeOffset() + sizeof(VkImageMemoryBarrier) > m_data_size)
        {
            args->pImageMemoryBarriers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageMemoryBarrier *>(m_data + NextDecodeOffset());
        args->pImageMemoryBarriers = CopyArray(ptr,
                                               (uint64_t)(static_cast<uint32_t>(0U)),
                                               src->imageMemoryBarrierCount);
    }
    return args;
}

CmdPipelineBarrierArgs *CommandDecoder::DecodeCmdPipelineBarrier(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdPipelineBarrierArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdPipelineBarrierArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdPipelineBarrierArgs *src = reinterpret_cast<const CmdPipelineBarrierArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;                        // VkCommandBuffer
    args->srcStageMask = src->srcStageMask;                          // VkPipelineStageFlags
    args->dstStageMask = src->dstStageMask;                          // VkPipelineStageFlags
    args->dependencyFlags = src->dependencyFlags;                    // VkDependencyFlags
    args->memoryBarrierCount = src->memoryBarrierCount;              // u32
    args->pMemoryBarriers = src->pMemoryBarriers;                    // VkMemoryBarrier*
    args->bufferMemoryBarrierCount = src->bufferMemoryBarrierCount;  // u32
    args->pBufferMemoryBarriers = src->pBufferMemoryBarriers;        // VkBufferMemoryBarrier*
    args->imageMemoryBarrierCount = src->imageMemoryBarrierCount;    // u32
    args->pImageMemoryBarriers = src->pImageMemoryBarriers;          // VkImageMemoryBarrier*
    if (src->pMemoryBarriers)
    {
        if (NextDecodeOffset() + sizeof(VkMemoryBarrier) > m_data_size)
        {
            args->pMemoryBarriers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkMemoryBarrier *>(m_data + NextDecodeOffset());
        args->pMemoryBarriers = CopyArray(ptr,
                                          (uint64_t)(static_cast<uint32_t>(0U)),
                                          src->memoryBarrierCount);
    }
    if (src->pBufferMemoryBarriers)
    {
        if (NextDecodeOffset() + sizeof(VkBufferMemoryBarrier) > m_data_size)
        {
            args->pBufferMemoryBarriers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkBufferMemoryBarrier *>(m_data + NextDecodeOffset());
        args->pBufferMemoryBarriers = CopyArray(ptr,
                                                (uint64_t)(static_cast<uint32_t>(0U)),
                                                src->bufferMemoryBarrierCount);
    }
    if (src->pImageMemoryBarriers)
    {
        if (NextDecodeOffset() + sizeof(VkImageMemoryBarrier) > m_data_size)
        {
            args->pImageMemoryBarriers = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkImageMemoryBarrier *>(m_data + NextDecodeOffset());
        args->pImageMemoryBarriers = CopyArray(ptr,
                                               (uint64_t)(static_cast<uint32_t>(0U)),
                                               src->imageMemoryBarrierCount);
    }
    return args;
}

CmdWriteBufferMarkerAMDArgs *CommandDecoder::DecodeCmdWriteBufferMarkerAMD(const char *data,
                                                                           size_t      data_size)
{
    if (data_size < sizeof(CmdWriteBufferMarkerAMDArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdWriteBufferMarkerAMDArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdWriteBufferMarkerAMDArgs *src = reinterpret_cast<const CmdWriteBufferMarkerAMDArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pipelineStage = src->pipelineStage;  // VkPipelineStageFlagBits
    args->dstBuffer = src->dstBuffer;          // VkBuffer
    args->dstOffset = src->dstOffset;          // VkDeviceSize
    args->marker = src->marker;                // u32
    return args;
}

CmdDrawIndirectCountAMDArgs *CommandDecoder::DecodeCmdDrawIndirectCountAMD(const char *data,
                                                                           size_t      data_size)
{
    if (data_size < sizeof(CmdDrawIndirectCountAMDArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndirectCountAMDArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndirectCountAMDArgs *src = reinterpret_cast<const CmdDrawIndirectCountAMDArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->countBuffer = src->countBuffer;      // VkBuffer
    args->countOffset = src->countOffset;      // VkDeviceSize
    args->maxDrawCount = src->maxDrawCount;    // u32
    args->stride = src->stride;                // u32
    return args;
}

CmdDrawIndexedIndirectCountAMDArgs *CommandDecoder::DecodeCmdDrawIndexedIndirectCountAMD(
const char *data,
size_t      data_size)
{
    if (data_size < sizeof(CmdDrawIndexedIndirectCountAMDArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndexedIndirectCountAMDArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndexedIndirectCountAMDArgs
    *src = reinterpret_cast<const CmdDrawIndexedIndirectCountAMDArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->countBuffer = src->countBuffer;      // VkBuffer
    args->countOffset = src->countOffset;      // VkDeviceSize
    args->maxDrawCount = src->maxDrawCount;    // u32
    args->stride = src->stride;                // u32
    return args;
}

CmdBeginConditionalRenderingEXTArgs *CommandDecoder::DecodeCmdBeginConditionalRenderingEXT(
const char *data,
size_t      data_size)
{
    if (data_size < sizeof(CmdBeginConditionalRenderingEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBeginConditionalRenderingEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBeginConditionalRenderingEXTArgs
    *src = reinterpret_cast<const CmdBeginConditionalRenderingEXTArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pConditinalRenderingBegin =
    src->pConditinalRenderingBegin;  // VkConditionalRenderingBeginInfoEXT*
    return args;
}

CmdEndConditionalRenderingEXTArgs *CommandDecoder::DecodeCmdEndConditionalRenderingEXT(
const char *data,
size_t      data_size)
{
    if (data_size < sizeof(CmdEndConditionalRenderingEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdEndConditionalRenderingEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdEndConditionalRenderingEXTArgs
    *src = reinterpret_cast<const CmdEndConditionalRenderingEXTArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    return args;
}

CmdDebugMarkerBeginEXTArgs *CommandDecoder::DecodeCmdDebugMarkerBeginEXT(const char *data,
                                                                         size_t      data_size)
{
    if (data_size < sizeof(CmdDebugMarkerBeginEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDebugMarkerBeginEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDebugMarkerBeginEXTArgs *src = reinterpret_cast<const CmdDebugMarkerBeginEXTArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pMarkerInfo = src->pMarkerInfo;      // VkDebugMarkerMarkerInfoEXT*
    if (src->pMarkerInfo)
    {
        if (NextDecodeOffset() + sizeof(VkDebugMarkerMarkerInfoEXT) > m_data_size)
        {
            args->pMarkerInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDebugMarkerMarkerInfoEXT *>(m_data +
                                                                        NextDecodeOffset());
        args->pMarkerInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdDebugMarkerEndEXTArgs *CommandDecoder::DecodeCmdDebugMarkerEndEXT(const char *data,
                                                                     size_t      data_size)
{
    if (data_size < sizeof(CmdDebugMarkerEndEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDebugMarkerEndEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDebugMarkerEndEXTArgs *src = reinterpret_cast<const CmdDebugMarkerEndEXTArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    return args;
}

CmdDebugMarkerInsertEXTArgs *CommandDecoder::DecodeCmdDebugMarkerInsertEXT(const char *data,
                                                                           size_t      data_size)
{
    if (data_size < sizeof(CmdDebugMarkerInsertEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDebugMarkerInsertEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDebugMarkerInsertEXTArgs *src = reinterpret_cast<const CmdDebugMarkerInsertEXTArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pMarkerInfo = src->pMarkerInfo;      // VkDebugMarkerMarkerInfoEXT*
    if (src->pMarkerInfo)
    {
        if (NextDecodeOffset() + sizeof(VkDebugMarkerMarkerInfoEXT) > m_data_size)
        {
            args->pMarkerInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDebugMarkerMarkerInfoEXT *>(m_data +
                                                                        NextDecodeOffset());
        args->pMarkerInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBeginDebugUtilsLabelEXTArgs *CommandDecoder::DecodeCmdBeginDebugUtilsLabelEXT(const char *data,
                                                                                 size_t data_size)
{
    if (data_size < sizeof(CmdBeginDebugUtilsLabelEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdBeginDebugUtilsLabelEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdBeginDebugUtilsLabelEXTArgs
    *src = reinterpret_cast<const CmdBeginDebugUtilsLabelEXTArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pLabelInfo = src->pLabelInfo;        // VkDebugUtilsLabelEXT*
    if (src->pLabelInfo)
    {
        if (NextDecodeOffset() + sizeof(VkDebugUtilsLabelEXT) > m_data_size)
        {
            args->pLabelInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDebugUtilsLabelEXT *>(m_data + NextDecodeOffset());
        args->pLabelInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndDebugUtilsLabelEXTArgs *CommandDecoder::DecodeCmdEndDebugUtilsLabelEXT(const char *data,
                                                                             size_t      data_size)
{
    if (data_size < sizeof(CmdEndDebugUtilsLabelEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdEndDebugUtilsLabelEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdEndDebugUtilsLabelEXTArgs
    *src = reinterpret_cast<const CmdEndDebugUtilsLabelEXTArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    return args;
}

CmdInsertDebugUtilsLabelEXTArgs *CommandDecoder::DecodeCmdInsertDebugUtilsLabelEXT(const char *data,
                                                                                   size_t data_size)
{
    if (data_size < sizeof(CmdInsertDebugUtilsLabelEXTArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdInsertDebugUtilsLabelEXTArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdInsertDebugUtilsLabelEXTArgs
    *src = reinterpret_cast<const CmdInsertDebugUtilsLabelEXTArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->pLabelInfo = src->pLabelInfo;        // VkDebugUtilsLabelEXT*
    if (src->pLabelInfo)
    {
        if (NextDecodeOffset() + sizeof(VkDebugUtilsLabelEXT) > m_data_size)
        {
            args->pLabelInfo = nullptr;
            return args;
        }
        auto ptr = reinterpret_cast<const VkDebugUtilsLabelEXT *>(m_data + NextDecodeOffset());
        args->pLabelInfo = CopyArray(ptr, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetDeviceMaskKHRArgs *CommandDecoder::DecodeCmdSetDeviceMaskKHR(const char *data,
                                                                   size_t      data_size)
{
    if (data_size < sizeof(CmdSetDeviceMaskKHRArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetDeviceMaskKHRArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetDeviceMaskKHRArgs *src = reinterpret_cast<const CmdSetDeviceMaskKHRArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->deviceMask = src->deviceMask;        // u32
    return args;
}

CmdSetDeviceMaskArgs *CommandDecoder::DecodeCmdSetDeviceMask(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdSetDeviceMaskArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdSetDeviceMaskArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdSetDeviceMaskArgs *src = reinterpret_cast<const CmdSetDeviceMaskArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->deviceMask = src->deviceMask;        // u32
    return args;
}

CmdDispatchBaseKHRArgs *CommandDecoder::DecodeCmdDispatchBaseKHR(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdDispatchBaseKHRArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDispatchBaseKHRArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDispatchBaseKHRArgs *src = reinterpret_cast<const CmdDispatchBaseKHRArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->baseGroupX = src->baseGroupX;        // u32
    args->baseGroupY = src->baseGroupY;        // u32
    args->baseGroupZ = src->baseGroupZ;        // u32
    args->groupCountX = src->groupCountX;      // u32
    args->groupCountY = src->groupCountY;      // u32
    args->groupCountZ = src->groupCountZ;      // u32
    return args;
}

CmdDispatchBaseArgs *CommandDecoder::DecodeCmdDispatchBase(const char *data, size_t data_size)
{
    if (data_size < sizeof(CmdDispatchBaseArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDispatchBaseArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDispatchBaseArgs *src = reinterpret_cast<const CmdDispatchBaseArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->baseGroupX = src->baseGroupX;        // u32
    args->baseGroupY = src->baseGroupY;        // u32
    args->baseGroupZ = src->baseGroupZ;        // u32
    args->groupCountX = src->groupCountX;      // u32
    args->groupCountY = src->groupCountY;      // u32
    args->groupCountZ = src->groupCountZ;      // u32
    return args;
}

CmdDrawIndirectCountKHRArgs *CommandDecoder::DecodeCmdDrawIndirectCountKHR(const char *data,
                                                                           size_t      data_size)
{
    if (data_size < sizeof(CmdDrawIndirectCountKHRArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndirectCountKHRArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndirectCountKHRArgs *src = reinterpret_cast<const CmdDrawIndirectCountKHRArgs *>(
    m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->countBuffer = src->countBuffer;      // VkBuffer
    args->countOffset = src->countOffset;      // VkDeviceSize
    args->maxDrawCount = src->maxDrawCount;    // u32
    args->stride = src->stride;                // u32
    return args;
}

CmdDrawIndexedIndirectCountKHRArgs *CommandDecoder::DecodeCmdDrawIndexedIndirectCountKHR(
const char *data,
size_t      data_size)
{
    if (data_size < sizeof(CmdDrawIndexedIndirectCountKHRArgs))
        return nullptr;
    m_data = data;
    m_data_size = data_size;
    auto *args = Alloc<CmdDrawIndexedIndirectCountKHRArgs>();
    if (args == nullptr)
    {
        return args;
    }
    const CmdDrawIndexedIndirectCountKHRArgs
    *src = reinterpret_cast<const CmdDrawIndexedIndirectCountKHRArgs *>(m_data);
    args->commandBuffer = src->commandBuffer;  // VkCommandBuffer
    args->buffer = src->buffer;                // VkBuffer
    args->offset = src->offset;                // VkDeviceSize
    args->countBuffer = src->countBuffer;      // VkBuffer
    args->countOffset = src->countOffset;      // VkDeviceSize
    args->maxDrawCount = src->maxDrawCount;    // u32
    args->stride = src->stride;                // u32
    return args;
}

char *CommandDecoder::CopyString(const char *src, uint64_t max_str_len)
{
    uint64_t str_len = strnlen(src, max_str_len);
    auto     ptr = reinterpret_cast<char *>(m_allocator->Alloc(str_len + 1));
    if (ptr == nullptr || NextDecodeOffset() > m_data_size)
        return nullptr;
    std::memcpy(ptr, src, str_len);
    ptr[str_len] = '\0';
    return ptr;
}

std::unordered_map<VkDescriptorSet, DescriptorsetInfo> DecodeDescriptorSetsInitialState(
const char *data,
uint64_t    size)
{
    std::unordered_map<VkDescriptorSet, DescriptorsetInfo> descriptorsets_state;
    uint32_t                                               set_count = 0;
    const char *                                           ptr = data;
    size_t                                                 offset = 0;
    set_count = *(reinterpret_cast<const uint32_t *>(ptr));
    offset += AlignUp(sizeof(uint32_t));
    for (uint32_t i = 0; i < set_count; i++)
    {
        DescriptorsetInfo ds;
        VkDescriptorSet descriptor_set = *(reinterpret_cast<const VkDescriptorSet *>(ptr + offset));
        offset += AlignUp(sizeof(VkDescriptorSet));
        ds.m_descriptor_set_layout = *(
        reinterpret_cast<const VkDescriptorSetLayout *>(ptr + offset));
        offset += AlignUp(sizeof(VkDescriptorSetLayout));
        ds.m_descriptor_pool = *(reinterpret_cast<const VkDescriptorPool *>(ptr + offset));
        offset += AlignUp(sizeof(VkDescriptorPool));
        uint32_t binding_count = *(reinterpret_cast<const uint32_t *>(ptr + offset));
        offset += AlignUp(sizeof(offset));
        ds.m_bindings.resize(binding_count);
        for (uint32_t j = 0; j < binding_count; j++)
        {
            auto &binding = ds.m_bindings[j];
            memcpy(&binding, (ptr + offset), sizeof(DescriptorBinding));
            offset += AlignUp(sizeof(DescriptorBinding));
        }
        descriptorsets_state[descriptor_set] = ds;
    }
    return descriptorsets_state;
}

}  // namespace Dive