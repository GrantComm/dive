/*
 * Copyright (C) 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

#include <cassert>

#include "command_arguments.h"
#include "command_decoder.h"
#include "command_printer.h"
#include "dive_core/dive_strings.h"

namespace Dive
{
auto constexpr kIndentDepth = 4;
auto constexpr kDefaultParamIndent = 2;

void PrintCommandParametersDetail(std::ostream &                   os,
                                  VKCmdID                          cmdID,
                                  char *                           data,
                                  size_t                           data_size,
                                  const VulkanMetadataBlockHeader &metadata_version)
{
    if (data == nullptr || data_size <= 0)
        return;
    CommandDecoder::AllocatorType allocator(data_size);
    CommandDecoder                decoder(&allocator, metadata_version);
    switch (cmdID)
    {
    case VKCmdID::vkBeginCommandBufferCmdID:
    {
        auto args = decoder.DecodeBeginCommandBuffer(data, data_size);
        PrintBeginCommandBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkEndCommandBufferCmdID:
    {
        auto args = decoder.DecodeEndCommandBuffer(data, data_size);
        PrintEndCommandBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdExecuteCommandsCmdID:
    {
        auto args = decoder.DecodeCmdExecuteCommands(data, data_size);
        PrintCmdExecuteCommandsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdCopyBufferCmdID:
    {
        auto args = decoder.DecodeCmdCopyBuffer(data, data_size);
        PrintCmdCopyBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdCopyImageCmdID:
    {
        auto args = decoder.DecodeCmdCopyImage(data, data_size);
        PrintCmdCopyImageArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBlitImageCmdID:
    {
        auto args = decoder.DecodeCmdBlitImage(data, data_size);
        PrintCmdBlitImageArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdCopyBufferToImageCmdID:
    {
        auto args = decoder.DecodeCmdCopyBufferToImage(data, data_size);
        PrintCmdCopyBufferToImageArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdCopyImageToBufferCmdID:
    {
        auto args = decoder.DecodeCmdCopyImageToBuffer(data, data_size);
        PrintCmdCopyImageToBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdUpdateBufferCmdID:
    {
        auto args = decoder.DecodeCmdUpdateBuffer(data, data_size);
        PrintCmdUpdateBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdFillBufferCmdID:
    {
        auto args = decoder.DecodeCmdFillBuffer(data, data_size);
        PrintCmdFillBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdClearColorImageCmdID:
    {
        auto args = decoder.DecodeCmdClearColorImage(data, data_size);
        PrintCmdClearColorImageArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdClearDepthStencilImageCmdID:
    {
        auto args = decoder.DecodeCmdClearDepthStencilImage(data, data_size);
        PrintCmdClearDepthStencilImageArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdClearAttachmentsCmdID:
    {
        auto args = decoder.DecodeCmdClearAttachments(data, data_size);
        PrintCmdClearAttachmentsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdResolveImageCmdID:
    {
        auto args = decoder.DecodeCmdResolveImage(data, data_size);
        PrintCmdResolveImageArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBindDescriptorSetsCmdID:
    {
        auto args = decoder.DecodeCmdBindDescriptorSets(data, data_size);
        PrintCmdBindDescriptorSetsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdPushConstantsCmdID:
    {
        auto args = decoder.DecodeCmdPushConstants(data, data_size);
        PrintCmdPushConstantsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBindIndexBufferCmdID:
    {
        auto args = decoder.DecodeCmdBindIndexBuffer(data, data_size);
        PrintCmdBindIndexBufferArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBindVertexBuffersCmdID:
    {
        auto args = decoder.DecodeCmdBindVertexBuffers(data, data_size);
        PrintCmdBindVertexBuffersArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawCmdID:
    {
        auto args = decoder.DecodeCmdDraw(data, data_size);
        PrintCmdDrawArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndexedCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndexed(data, data_size);
        PrintCmdDrawIndexedArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndirectCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndirect(data, data_size);
        PrintCmdDrawIndirectArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndexedIndirectCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndexedIndirect(data, data_size);
        PrintCmdDrawIndexedIndirectArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDispatchCmdID:
    {
        auto args = decoder.DecodeCmdDispatch(data, data_size);
        PrintCmdDispatchArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDispatchIndirectCmdID:
    {
        auto args = decoder.DecodeCmdDispatchIndirect(data, data_size);
        PrintCmdDispatchIndirectArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBindPipelineCmdID:
    {
        auto args = decoder.DecodeCmdBindPipeline(data, data_size);
        PrintCmdBindPipelineArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetViewportCmdID:
    {
        auto args = decoder.DecodeCmdSetViewport(data, data_size);
        PrintCmdSetViewportArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetScissorCmdID:
    {
        auto args = decoder.DecodeCmdSetScissor(data, data_size);
        PrintCmdSetScissorArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetLineWidthCmdID:
    {
        auto args = decoder.DecodeCmdSetLineWidth(data, data_size);
        PrintCmdSetLineWidthArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetDepthBiasCmdID:
    {
        auto args = decoder.DecodeCmdSetDepthBias(data, data_size);
        PrintCmdSetDepthBiasArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetBlendConstantsCmdID:
    {
        auto args = decoder.DecodeCmdSetBlendConstants(data, data_size);
        PrintCmdSetBlendConstantsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetDepthBoundsCmdID:
    {
        auto args = decoder.DecodeCmdSetDepthBounds(data, data_size);
        PrintCmdSetDepthBoundsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetStencilCompareMaskCmdID:
    {
        auto args = decoder.DecodeCmdSetStencilCompareMask(data, data_size);
        PrintCmdSetStencilCompareMaskArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetStencilWriteMaskCmdID:
    {
        auto args = decoder.DecodeCmdSetStencilWriteMask(data, data_size);
        PrintCmdSetStencilWriteMaskArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetStencilReferenceCmdID:
    {
        auto args = decoder.DecodeCmdSetStencilReference(data, data_size);
        PrintCmdSetStencilReferenceArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBeginQueryCmdID:
    {
        auto args = decoder.DecodeCmdBeginQuery(data, data_size);
        PrintCmdBeginQueryArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdEndQueryCmdID:
    {
        auto args = decoder.DecodeCmdEndQuery(data, data_size);
        PrintCmdEndQueryArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdResetQueryPoolCmdID:
    {
        auto args = decoder.DecodeCmdResetQueryPool(data, data_size);
        PrintCmdResetQueryPoolArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdWriteTimestampCmdID:
    {
        auto args = decoder.DecodeCmdWriteTimestamp(data, data_size);
        PrintCmdWriteTimestampArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdCopyQueryPoolResultsCmdID:
    {
        auto args = decoder.DecodeCmdCopyQueryPoolResults(data, data_size);
        PrintCmdCopyQueryPoolResultsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBeginRenderPassCmdID:
    {
        auto args = decoder.DecodeCmdBeginRenderPass(data, data_size);
        PrintCmdBeginRenderPassArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdNextSubpassCmdID:
    {
        auto args = decoder.DecodeCmdNextSubpass(data, data_size);
        PrintCmdNextSubpassArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdEndRenderPassCmdID:
    {
        auto args = decoder.DecodeCmdEndRenderPass(data, data_size);
        PrintCmdEndRenderPassArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetEventCmdID:
    {
        auto args = decoder.DecodeCmdSetEvent(data, data_size);
        PrintCmdSetEventArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdResetEventCmdID:
    {
        auto args = decoder.DecodeCmdResetEvent(data, data_size);
        PrintCmdResetEventArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdWaitEventsCmdID:
    {
        auto args = decoder.DecodeCmdWaitEvents(data, data_size);
        PrintCmdWaitEventsArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdPipelineBarrierCmdID:
    {
        auto args = decoder.DecodeCmdPipelineBarrier(data, data_size);
        PrintCmdPipelineBarrierArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdWriteBufferMarkerAMDCmdID:
    {
        auto args = decoder.DecodeCmdWriteBufferMarkerAMD(data, data_size);
        PrintCmdWriteBufferMarkerAMDArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndirectCountAMDCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndirectCountAMD(data, data_size);
        PrintCmdDrawIndirectCountAMDArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndexedIndirectCountAMDCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndexedIndirectCountAMD(data, data_size);
        PrintCmdDrawIndexedIndirectCountAMDArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBeginConditionalRenderingEXTCmdID:
    {
        auto args = decoder.DecodeCmdBeginConditionalRenderingEXT(data, data_size);
        PrintCmdBeginConditionalRenderingEXTArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdEndConditionalRenderingEXTCmdID:
    {
        auto args = decoder.DecodeCmdEndConditionalRenderingEXT(data, data_size);
        PrintCmdEndConditionalRenderingEXTArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdBeginDebugUtilsLabelEXTCmdID:
    {
        auto args = decoder.DecodeCmdBeginDebugUtilsLabelEXT(data, data_size);
        PrintCmdBeginDebugUtilsLabelEXTArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdEndDebugUtilsLabelEXTCmdID:
    {
        auto args = decoder.DecodeCmdEndDebugUtilsLabelEXT(data, data_size);
        PrintCmdEndDebugUtilsLabelEXTArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdInsertDebugUtilsLabelEXTCmdID:
    {
        auto args = decoder.DecodeCmdInsertDebugUtilsLabelEXT(data, data_size);
        PrintCmdInsertDebugUtilsLabelEXTArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetDeviceMaskKHRCmdID:
    {
        auto args = decoder.DecodeCmdSetDeviceMaskKHR(data, data_size);
        PrintCmdSetDeviceMaskKHRArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdSetDeviceMaskCmdID:
    {
        auto args = decoder.DecodeCmdSetDeviceMask(data, data_size);
        PrintCmdSetDeviceMaskArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDispatchBaseKHRCmdID:
    {
        auto args = decoder.DecodeCmdDispatchBaseKHR(data, data_size);
        PrintCmdDispatchBaseKHRArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDispatchBaseCmdID:
    {
        auto args = decoder.DecodeCmdDispatchBase(data, data_size);
        PrintCmdDispatchBaseArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndirectCountKHRCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndirectCountKHR(data, data_size);
        PrintCmdDrawIndirectCountKHRArgs(os, *args);
        break;
    }
    case VKCmdID::vkCmdDrawIndexedIndirectCountKHRCmdID:
    {
        auto args = decoder.DecodeCmdDrawIndexedIndirectCountKHR(data, data_size);
        PrintCmdDrawIndexedIndirectCountKHRArgs(os, *args);
        break;
    }
    case VKCmdID::vkQueueSubmit: { break;
    }
    }

    assert(decoder.DecodedArgsSize() <= data_size);
}

void PrintDescriptorSetInitialState(
std::ostream &                                                os,
const std::unordered_map<VkDescriptorSet, DescriptorsetInfo> &state)
{
    for (const auto &ds : state)
    {
        os << "VkDescriptorSet: " << ds.first << std::endl;
        os << "VkDescriptorSetLayout: " << ds.second.m_descriptor_set_layout << std::endl;
        os << "VkDescriptorPool: " << ds.second.m_descriptor_pool << std::endl;
        // for (const auto &binding : ds.second.m_bindings)
        for (uint32_t i = 0; i < ds.second.m_bindings.size(); i++)
        {
            const auto binding = ds.second.m_bindings[i];
            os << "VkDescriptorType: " << binding.m_descriptor_type << std::endl;
            switch (binding.m_descriptor_type)
            {
            case VK_DESCRIPTOR_TYPE_SAMPLER:  // fall-through...
            case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
            case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:  // fall-through...
            case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:  // fall-through...
            case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
                os << "\tpImageInfo: " << std::endl;
                os << "\t\t.sampler: " << binding.binding_info.m_image_info.sampler << std::endl;
                os << "\t\t.imageView: " << binding.binding_info.m_image_info.imageView
                   << std::endl;
                os << "\t\t.imageLayout: " << binding.binding_info.m_image_info.imageLayout
                   << std::endl;
                break;
            case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:  // fall-through...
            case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
                os << "\tpTexelBufferView:" << std::endl;
                os << "\t\t.pTexelBufferView: " << binding.binding_info.m_texel_buffer_view
                   << std::endl;
                break;
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:          // fall-through...
            case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:          // fall-through...
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:  // fall-through...
            case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
                os << "\tpBufferInfo:" << std::endl;
                os << "\t\t.buffer: " << binding.binding_info.m_buffer_info.buffer << std::endl;
                os << "\t\t.offset: " << binding.binding_info.m_buffer_info.offset << std::endl;
                os << "\t\t.range: " << binding.binding_info.m_buffer_info.range << std::endl;
            default: break;
            }
        }
    }
}

std::string GetObjectName(std::ostream &os, uint64_t h)
{
    return Uint64ToStr(h);
}

int IndentIdx()
{
    const static int indent_idx = std::ios::xalloc();
    return indent_idx;
}

std::ostream &NewEntry(std::ostream &os)
{
    return os << "\n" << std::string(static_cast<size_t>(os.iword(IndentIdx())), ' ');
}

std::string NewEntryStr(std::ostream &os)
{
    return "\n" + std::string(static_cast<size_t>(os.iword(IndentIdx())), ' ');
}

std::ostream &OpenBracket(std::ostream &os)
{
    os.iword(IndentIdx()) += kIndentDepth;
    return os;
}

std::ostream &CloseBracket(std::ostream &os)
{
    os.iword(IndentIdx()) -= kIndentDepth;
    return os;
}

class IndentGuard
{
public:
    IndentGuard(std::ostream &stream, const int indentDepth = kIndentDepth) :
        stream_(stream),
        indentDepth_(indentDepth)
    {
        stream_.iword(IndentIdx()) += indentDepth_;
    }
    ~IndentGuard() { stream_.iword(IndentIdx()) -= indentDepth_; }

private:
    std::ostream &stream_;
    int           indentDepth_;
};

std::ostream &operator<<(std::ostream &os, const VkInstance &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkPhysicalDevice &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDevice &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkQueue &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSemaphore &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkCommandBuffer &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkFence &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDeviceMemory &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBuffer &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImage &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkEvent &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkQueryPool &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBufferView &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageView &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkShaderModule &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkPipelineCache &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkPipelineLayout &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkRenderPass &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkPipeline &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorSetLayout &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSampler &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorPool &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorSet &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkFramebuffer &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkCommandPool &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSurfaceKHR &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSwapchainKHR &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDisplayKHR &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDisplayModeKHR &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorUpdateTemplate &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSamplerYcbcrConversion &a)
{
    os << GetObjectName(os, reinterpret_cast<uint64_t>(a));
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkAttachmentReference &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>attachment</b>: " << a.attachment << NewEntry;
    os << ".<b>layout</b>: " << a.layout << NewEntry;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBufferCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkBufferViewCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkCommandBufferBeginInfo &a);
std::ostream &operator<<(std::ostream &os, const VkBufferCopy &a);
std::ostream &operator<<(std::ostream &os, const VkImageCopy &a);
std::ostream &operator<<(std::ostream &os, const VkImageBlit &a);
std::ostream &operator<<(std::ostream &os, const VkBufferImageCopy &a);
std::ostream &operator<<(std::ostream &os, const VkClearColorValue &a);
std::ostream &operator<<(std::ostream &os, const VkImageSubresourceRange &a);
std::ostream &operator<<(std::ostream &os, const VkClearDepthStencilValue &a);
std::ostream &operator<<(std::ostream &os, const VkClearAttachment &a);
std::ostream &operator<<(std::ostream &os, const VkClearRect &a);
std::ostream &operator<<(std::ostream &os, const VkImageResolve &a);
std::ostream &operator<<(std::ostream &os, const VkDescriptorSetLayoutCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkDescriptorSetAllocateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkWriteDescriptorSet &a);
std::ostream &operator<<(std::ostream &os, const VkCopyDescriptorSet &a);
std::ostream &operator<<(std::ostream &os, const VkImageCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkImageViewCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkViewport &a);
std::ostream &operator<<(std::ostream &os, const VkRect2D &a);
std::ostream &operator<<(std::ostream &os, const VkSubmitInfo &a);
std::ostream &operator<<(std::ostream &os, const VkFramebufferCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkRenderPassCreateInfo &a);
std::ostream &operator<<(std::ostream &os, const VkRenderPassBeginInfo &a);
std::ostream &operator<<(std::ostream &os, const VkMemoryBarrier &a);
std::ostream &operator<<(std::ostream &os, const VkBufferMemoryBarrier &a);
std::ostream &operator<<(std::ostream &os, const VkImageMemoryBarrier &a);
std::ostream &operator<<(std::ostream &os, const VkConditionalRenderingBeginInfoEXT &a);
std::ostream &operator<<(std::ostream &os, const VkDebugMarkerMarkerInfoEXT &a);
std::ostream &operator<<(std::ostream &os, const VkDebugUtilsLabelEXT &a);
std::ostream &operator<<(std::ostream &os, const VkCommandBufferInheritanceInfo &a);
std::ostream &operator<<(std::ostream &os, const VkImageSubresourceLayers &a);
std::ostream &operator<<(std::ostream &os, const VkOffset3D &a);
std::ostream &operator<<(std::ostream &os, const VkExtent3D &a);
std::ostream &operator<<(std::ostream &os, const VkClearValue &a);
std::ostream &operator<<(std::ostream &os, const VkDescriptorSetLayoutBinding &a);
std::ostream &operator<<(std::ostream &os, const VkDescriptorImageInfo &a);
std::ostream &operator<<(std::ostream &os, const VkDescriptorBufferInfo &a);
std::ostream &operator<<(std::ostream &os, const VkComponentMapping &a);
std::ostream &operator<<(std::ostream &os, const VkOffset2D &a);
std::ostream &operator<<(std::ostream &os, const VkExtent2D &a);
std::ostream &operator<<(std::ostream &os, const VkAttachmentDescription &a);
std::ostream &operator<<(std::ostream &os, const VkSubpassDescription &a);
std::ostream &operator<<(std::ostream &os, const VkSubpassDependency &a);

std::ostream &operator<<(std::ostream &os, const VkBufferCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>size</b>: " << a.size << NewEntry;
    os << ".<b>usage</b>: " << a.usage << NewEntry;
    os << ".<b>sharingMode</b>: " << a.sharingMode << NewEntry;
    os << ".<b>queueFamilyIndexCount</b>: " << a.queueFamilyIndexCount << NewEntry;
    if (a.pQueueFamilyIndices)
    {
        os << ".<b>pQueueFamilyIndices</b>: " << *a.pQueueFamilyIndices;
    }
    else
    {
        os << ".<b>pQueueFamilyIndices</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBufferViewCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>buffer</b>: " << a.buffer << NewEntry;
    os << ".<b>format</b>: " << a.format << NewEntry;
    os << ".<b>offset</b>: " << a.offset << NewEntry;
    os << ".<b>range</b>: " << a.range;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkCommandBufferBeginInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((a.flags & (a.flags - 1)) != 0)
        os << NewEntry;
    os << GetVkCommandBufferUsageFlagBits(a.flags, NewEntryStr(os).c_str());
    os << CloseBracket << NewEntry;
    if (a.pInheritanceInfo)
    {
        os << ".<b>pInheritanceInfo</b>: " << *a.pInheritanceInfo;
    }
    else
    {
        os << ".<b>pInheritanceInfo</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBufferCopy &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>srcOffset</b>: " << a.srcOffset << NewEntry;
    os << ".<b>dstOffset</b>: " << a.dstOffset << NewEntry;
    os << ".<b>size</b>: " << a.size;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageCopy &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>srcSubresource</b>: " << a.srcSubresource << NewEntry;
    os << ".<b>srcOffset</b>: " << a.srcOffset << NewEntry;
    os << ".<b>dstSubresource</b>: " << a.dstSubresource << NewEntry;
    os << ".<b>dstOffset</b>: " << a.dstOffset << NewEntry;
    os << ".<b>extent</b>: " << a.extent;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageBlit &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>srcSubresource</b>: " << a.srcSubresource << NewEntry;
    os << ".<b>srcOffsets</b>: ";
    os << std::hex;
    for (uint32_t i = 0; i < 2; ++i)
    {
        os << "0x" << a.srcOffsets[i];
        if (i < 2 - 1)
        {
            os << ", ";
        }
    }
    os << std::dec << NewEntry;
    os << ".<b>dstSubresource</b>: " << a.dstSubresource << NewEntry;
    os << ".<b>dstOffsets</b>: ";
    os << std::hex;
    for (uint32_t i = 0; i < 2; ++i)
    {
        os << "0x" << a.dstOffsets[i];
        if (i < 2 - 1)
        {
            os << ", ";
        }
    }
    os << std::dec;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBufferImageCopy &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>bufferOffset</b>: " << a.bufferOffset << NewEntry;
    os << ".<b>bufferRowLength</b>: " << a.bufferRowLength << NewEntry;
    os << ".<b>bufferImageHeight</b>: " << a.bufferImageHeight << NewEntry;
    os << ".<b>imageSubresource</b>: " << a.imageSubresource << NewEntry;
    os << ".<b>imageOffset</b>: " << a.imageOffset << NewEntry;
    os << ".<b>imageExtent</b>: " << a.imageExtent;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkClearColorValue &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>uint32</b>: ";
    os << std::hex;
    for (uint32_t i = 0; i < 4; ++i)
    {
        os << "0x" << a.uint32[i];
        if (i < 4 - 1)
        {
            os << ", ";
        }
    }
    os << std::dec;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageSubresourceRange &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>aspectMask</b>: " << a.aspectMask << NewEntry;
    os << ".<b>baseMipLevel</b>: " << a.baseMipLevel << NewEntry;
    os << ".<b>levelCount</b>: " << a.levelCount << NewEntry;
    os << ".<b>baseArrayLayer</b>: " << a.baseArrayLayer << NewEntry;
    os << ".<b>layerCount</b>: " << a.layerCount;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkClearDepthStencilValue &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>depth</b>: " << a.depth << NewEntry;
    os << ".<b>stencil</b>: " << a.stencil;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkClearAttachment &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>aspectMask</b>: " << a.aspectMask << NewEntry;
    os << ".<b>colorAttachment</b>: " << a.colorAttachment << NewEntry;
    os << ".<b>clearValue</b>: " << a.clearValue;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkClearRect &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>rect</b>: " << a.rect << NewEntry;
    os << ".<b>baseArrayLayer</b>: " << a.baseArrayLayer << NewEntry;
    os << ".<b>layerCount</b>: " << a.layerCount;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageResolve &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>srcSubresource</b>: " << a.srcSubresource << NewEntry;
    os << ".<b>srcOffset</b>: " << a.srcOffset << NewEntry;
    os << ".<b>dstSubresource</b>: " << a.dstSubresource << NewEntry;
    os << ".<b>dstOffset</b>: " << a.dstOffset << NewEntry;
    os << ".<b>extent</b>: " << a.extent;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorSetLayoutCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>bindingCount</b>: " << a.bindingCount << NewEntry;
    if (a.pBindings)
    {
        os << ".<b>pBindings</b>: " << *a.pBindings;
    }
    else
    {
        os << ".<b>pBindings</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorSetAllocateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>descriptorPool</b>: " << a.descriptorPool << NewEntry;
    os << ".<b>descriptorSetCount</b>: " << a.descriptorSetCount << NewEntry;
    if (a.pSetLayouts)
    {
        os << ".<b>pSetLayouts</b>: " << *a.pSetLayouts;
    }
    else
    {
        os << ".<b>pSetLayouts</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkWriteDescriptorSet &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>dstSet</b>: " << a.dstSet << NewEntry;
    os << ".<b>dstBinding</b>: " << a.dstBinding << NewEntry;
    os << ".<b>dstArrayElement</b>: " << a.dstArrayElement << NewEntry;
    os << ".<b>descriptorCount</b>: " << a.descriptorCount << NewEntry;
    os << ".<b>descriptorType</b>: " << a.descriptorType << NewEntry;
    if (a.pImageInfo)
    {
        os << ".<b>pImageInfo</b>: " << *a.pImageInfo;
    }
    else
    {
        os << ".<b>pImageInfo</b>: null";
    }
    os << "" << NewEntry;
    if (a.pBufferInfo)
    {
        os << ".<b>pBufferInfo</b>: " << *a.pBufferInfo;
    }
    else
    {
        os << ".<b>pBufferInfo</b>: null";
    }
    os << "" << NewEntry;
    if (a.pTexelBufferView)
    {
        os << ".<b>pTexelBufferView</b>: " << *a.pTexelBufferView;
    }
    else
    {
        os << ".<b>pTexelBufferView</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkCopyDescriptorSet &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>srcSet</b>: " << a.srcSet << NewEntry;
    os << ".<b>srcBinding</b>: " << a.srcBinding << NewEntry;
    os << ".<b>srcArrayElement</b>: " << a.srcArrayElement << NewEntry;
    os << ".<b>dstSet</b>: " << a.dstSet << NewEntry;
    os << ".<b>dstBinding</b>: " << a.dstBinding << NewEntry;
    os << ".<b>dstArrayElement</b>: " << a.dstArrayElement << NewEntry;
    os << ".<b>descriptorCount</b>: " << a.descriptorCount;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>imageType</b>: " << a.imageType << NewEntry;
    os << ".<b>format</b>: " << a.format << NewEntry;
    os << ".<b>extent</b>: " << a.extent << NewEntry;
    os << ".<b>mipLevels</b>: " << a.mipLevels << NewEntry;
    os << ".<b>arrayLayers</b>: " << a.arrayLayers << NewEntry;
    os << ".<b>samples</b>: " << a.samples << NewEntry;
    os << ".<b>tiling</b>: " << a.tiling << NewEntry;
    os << ".<b>usage</b>: " << a.usage << NewEntry;
    os << ".<b>sharingMode</b>: " << a.sharingMode << NewEntry;
    os << ".<b>queueFamilyIndexCount</b>: " << a.queueFamilyIndexCount << NewEntry;
    if (a.pQueueFamilyIndices)
    {
        os << ".<b>pQueueFamilyIndices</b>: " << *a.pQueueFamilyIndices;
    }
    else
    {
        os << ".<b>pQueueFamilyIndices</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>initialLayout</b>: " << OpenBracket << NewEntry
       << GetVkImageLayoutString(a.initialLayout) << CloseBracket;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageViewCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>image</b>: " << a.image << NewEntry;
    os << ".<b>viewType</b>: " << a.viewType << NewEntry;
    os << ".<b>format</b>: " << a.format << NewEntry;
    os << ".<b>components</b>: " << a.components << NewEntry;
    os << ".<b>subresourceRange</b>: " << a.subresourceRange;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkViewport &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>x</b>: " << a.x << NewEntry;
    os << ".<b>y</b>: " << a.y << NewEntry;
    os << ".<b>width</b>: " << a.width << NewEntry;
    os << ".<b>height</b>: " << a.height << NewEntry;
    os << ".<b>minDepth</b>: " << a.minDepth << NewEntry;
    os << ".<b>maxDepth</b>: " << a.maxDepth;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkRect2D &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>offset</b>: " << a.offset << NewEntry;
    os << ".<b>extent</b>: " << a.extent;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSubmitInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>waitSemaphoreCount</b>: " << a.waitSemaphoreCount << NewEntry;
    if (a.pWaitSemaphores)
    {
        os << ".<b>pWaitSemaphores</b>: " << *a.pWaitSemaphores;
    }
    else
    {
        os << ".<b>pWaitSemaphores</b>: null";
    }
    os << "" << NewEntry;
    if (a.pWaitDstStageMask)
    {
        os << ".<b>pWaitDstStageMask</b>: " << *a.pWaitDstStageMask;
    }
    else
    {
        os << ".<b>pWaitDstStageMask</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>commandBufferCount</b>: " << a.commandBufferCount << NewEntry;
    if (a.pCommandBuffers)
    {
        os << ".<b>pCommandBuffers</b>: " << *a.pCommandBuffers;
    }
    else
    {
        os << ".<b>pCommandBuffers</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>signalSemaphoreCount</b>: " << a.signalSemaphoreCount << NewEntry;
    if (a.pSignalSemaphores)
    {
        os << ".<b>pSignalSemaphores</b>: " << *a.pSignalSemaphores;
    }
    else
    {
        os << ".<b>pSignalSemaphores</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkFramebufferCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>renderPass</b>: " << a.renderPass << NewEntry;
    os << ".<b>attachmentCount</b>: " << a.attachmentCount << NewEntry;
    if (a.pAttachments && a.attachmentCount > 0)
    {
        for (uint32_t i = 0; i < a.attachmentCount; i++)
        {
            os << ".<b>pAttachments</b>[" << i << "]:" << a.pAttachments[i];
            if (i < a.attachmentCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pAttachments</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>width</b>: " << a.width << NewEntry;
    os << ".<b>height</b>: " << a.height << NewEntry;
    os << ".<b>layers</b>: " << a.layers;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkRenderPassCreateInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>attachmentCount</b>: " << a.attachmentCount << NewEntry;
    if (a.pAttachments && a.attachmentCount > 0)
    {
        for (uint32_t i = 0; i < a.attachmentCount; i++)
        {
            os << ".<b>pAttachments</b>[" << i << "]:" << a.pAttachments[i];
            if (i < a.attachmentCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pAttachments</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>subpassCount</b>: " << a.subpassCount << NewEntry;
    if (a.pSubpasses && a.subpassCount > 0)
    {
        for (uint32_t i = 0; i < a.subpassCount; i++)
        {
            os << ".<b>pSubpasses</b>[" << i << "]:" << a.pSubpasses[i];
            if (i < a.subpassCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pSubpasses</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>dependencyCount</b>: " << a.dependencyCount << NewEntry;
    if (a.pDependencies && a.dependencyCount > 0)
    {
        for (uint32_t i = 0; i < a.dependencyCount; i++)
        {
            os << ".<b>pDependencies</b>[" << i << "]:" << a.pDependencies[i];
            if (i < a.dependencyCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pDependencies</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkRenderPassBeginInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>renderPass</b>: " << a.renderPass << NewEntry;
    os << ".<b>framebuffer</b>: " << a.framebuffer << NewEntry;
    os << ".<b>renderArea</b>: " << a.renderArea << NewEntry;
    os << ".<b>clearValueCount</b>: " << a.clearValueCount << NewEntry;
    if (a.pClearValues && a.clearValueCount > 0)
    {
        for (uint32_t i = 0; i < a.clearValueCount; i++)
        {
            os << ".<b>pClearValues</b>[" << i << "]:" << a.pClearValues[i];
            if (i < a.clearValueCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pClearValues</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkMemoryBarrier &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>srcAccessMask</b>: " << a.srcAccessMask << NewEntry;
    os << ".<b>dstAccessMask</b>: " << a.dstAccessMask;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkBufferMemoryBarrier &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>srcAccessMask</b>: " << a.srcAccessMask << NewEntry;
    os << ".<b>dstAccessMask</b>: " << a.dstAccessMask << NewEntry;
    os << ".<b>srcQueueFamilyIndex</b>: " << a.srcQueueFamilyIndex << NewEntry;
    os << ".<b>dstQueueFamilyIndex</b>: " << a.dstQueueFamilyIndex << NewEntry;
    os << ".<b>buffer</b>: " << a.buffer << NewEntry;
    os << ".<b>offset</b>: " << a.offset << NewEntry;
    os << ".<b>size</b>: " << a.size;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageMemoryBarrier &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>srcAccessMask</b>: " << a.srcAccessMask << NewEntry;
    os << ".<b>dstAccessMask</b>: " << a.dstAccessMask << NewEntry;
    os << ".<b>oldLayout</b>: " << OpenBracket << NewEntry << GetVkImageLayoutString(a.oldLayout)
       << CloseBracket << NewEntry;
    os << ".<b>newLayout</b>: " << OpenBracket << NewEntry << GetVkImageLayoutString(a.newLayout)
       << CloseBracket << NewEntry;
    os << ".<b>srcQueueFamilyIndex</b>: " << a.srcQueueFamilyIndex << NewEntry;
    os << ".<b>dstQueueFamilyIndex</b>: " << a.dstQueueFamilyIndex << NewEntry;
    os << ".<b>image</b>: " << a.image << NewEntry;
    os << ".<b>subresourceRange</b>: " << a.subresourceRange;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkConditionalRenderingBeginInfoEXT &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>buffer</b>: " << a.buffer << NewEntry;
    os << ".<b>offset</b>: " << a.offset << NewEntry;
    os << ".<b>flags</b>: " << a.flags;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDebugMarkerMarkerInfoEXT &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    if (a.pMarkerName)
    {
        os << ".<b>pMarkerName</b>: \"" << a.pMarkerName << "\"";
    }
    else
    {
        os << ".<b>pMarkerName</b>: \"\"";
    }
    os << "" << NewEntry;
    os << ".<b>color</b>: ";
    os << std::hex;
    for (uint32_t i = 0; i < 4; ++i)
    {
        os << "0x" << a.color[i];
        if (i < 4 - 1)
        {
            os << ", ";
        }
    }
    os << std::dec;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDebugUtilsLabelEXT &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    if (a.pLabelName)
    {
        os << ".<b>pLabelName</b>: \"" << a.pLabelName << "\"";
    }
    else
    {
        os << ".<b>pLabelName</b>: \"\"";
    }
    os << "" << NewEntry;
    os << ".<b>color</b>: ";
    os << std::hex;
    for (uint32_t i = 0; i < 4; ++i)
    {
        os << "0x" << a.color[i];
        if (i < 4 - 1)
        {
            os << ", ";
        }
    }
    os << std::dec;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkCommandBufferInheritanceInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sType</b>: " << a.sType << NewEntry;
    os << ".<b>pNext</b>: " << a.pNext << NewEntry;
    os << ".<b>renderPass</b>: " << a.renderPass << NewEntry;
    os << ".<b>subpass</b>: " << a.subpass << NewEntry;
    os << ".<b>framebuffer</b>: " << a.framebuffer << NewEntry;
    os << ".<b>occlusionQueryEnable</b>: " << a.occlusionQueryEnable << NewEntry;
    if (a.queryFlags == 0)
        os << ".<b>queryFlags</b>: " << a.queryFlags;
    else
        os << ".<b>queryFlags</b>: PRECISE_BIT";
    os << "" << NewEntry;
    os << ".<b>pipelineStatistics</b>: " << a.pipelineStatistics;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkImageSubresourceLayers &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>aspectMask</b>: " << a.aspectMask << NewEntry;
    os << ".<b>mipLevel</b>: " << a.mipLevel << NewEntry;
    os << ".<b>baseArrayLayer</b>: " << a.baseArrayLayer << NewEntry;
    os << ".<b>layerCount</b>: " << a.layerCount;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkOffset3D &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>x</b>: " << a.x << NewEntry;
    os << ".<b>y</b>: " << a.y << NewEntry;
    os << ".<b>z</b>: " << a.z;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkExtent3D &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>width</b>: " << a.width << NewEntry;
    os << ".<b>height</b>: " << a.height << NewEntry;
    os << ".<b>depth</b>: " << a.depth;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkClearValue &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>color</b>: " << a.color;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorSetLayoutBinding &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>binding</b>: " << a.binding << NewEntry;
    os << ".<b>descriptorType</b>: " << a.descriptorType << NewEntry;
    os << ".<b>descriptorCount</b>: " << a.descriptorCount << NewEntry;
    os << ".<b>stageFlags</b>: " << a.stageFlags << NewEntry;
    if (a.pImmutableSamplers)
    {
        os << ".<b>pImmutableSamplers</b>: " << *a.pImmutableSamplers;
    }
    else
    {
        os << ".<b>pImmutableSamplers</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorImageInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>sampler</b>: " << a.sampler << NewEntry;
    os << ".<b>imageView</b>: " << a.imageView << NewEntry;
    os << ".<b>imageLayout</b>: " << OpenBracket << NewEntry
       << GetVkImageLayoutString(a.imageLayout) << CloseBracket;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkDescriptorBufferInfo &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>buffer</b>: " << a.buffer << NewEntry;
    os << ".<b>offset</b>: " << a.offset << NewEntry;
    os << ".<b>range</b>: " << a.range;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkComponentMapping &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>r</b>: " << a.r << NewEntry;
    os << ".<b>g</b>: " << a.g << NewEntry;
    os << ".<b>b</b>: " << a.b << NewEntry;
    os << ".<b>a</b>: " << a.a;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkOffset2D &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>x</b>: " << a.x << NewEntry;
    os << ".<b>y</b>: " << a.y;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkExtent2D &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>width</b>: " << a.width << NewEntry;
    os << ".<b>height</b>: " << a.height;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkAttachmentDescription &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>format</b>: " << a.format << NewEntry;
    os << ".<b>samples</b>: " << a.samples << NewEntry;
    os << ".<b>loadOp</b>: " << a.loadOp << NewEntry;
    os << ".<b>storeOp</b>: " << a.storeOp << NewEntry;
    os << ".<b>stencilLoadOp</b>: " << a.stencilLoadOp << NewEntry;
    os << ".<b>stencilStoreOp</b>: " << a.stencilStoreOp << NewEntry;
    os << ".<b>initialLayout</b>: " << OpenBracket << NewEntry
       << GetVkImageLayoutString(a.initialLayout) << CloseBracket << NewEntry;
    os << ".<b>finalLayout</b>: " << OpenBracket << NewEntry
       << GetVkImageLayoutString(a.finalLayout) << CloseBracket;
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSubpassDescription &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>flags</b>: " << a.flags << NewEntry;
    os << ".<b>pipelineBindPoint</b>: " << a.pipelineBindPoint << NewEntry;
    os << ".<b>inputAttachmentCount</b>: " << a.inputAttachmentCount << NewEntry;
    if (a.pInputAttachments && a.inputAttachmentCount > 0)
    {
        for (uint32_t i = 0; i < a.inputAttachmentCount; i++)
        {
            os << ".<b>pInputAttachments</b>[" << i << "]:" << a.pInputAttachments[i];
            if (i < a.inputAttachmentCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pInputAttachments</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>colorAttachmentCount</b>: " << a.colorAttachmentCount << NewEntry;
    if (a.pColorAttachments && a.colorAttachmentCount > 0)
    {
        for (uint32_t i = 0; i < a.colorAttachmentCount; i++)
        {
            os << ".<b>pColorAttachments</b>[" << i << "]:" << a.pColorAttachments[i];
            if (i < a.colorAttachmentCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pColorAttachments</b>: null";
    }
    os << "" << NewEntry;
    if (a.pResolveAttachments && a.colorAttachmentCount > 0)
    {
        for (uint32_t i = 0; i < a.colorAttachmentCount; i++)
        {
            os << ".<b>pResolveAttachments</b>[" << i << "]:" << a.pResolveAttachments[i];
            if (i < a.colorAttachmentCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pResolveAttachments</b>: null";
    }
    os << "" << NewEntry;
    if (a.pDepthStencilAttachment)
    {
        os << ".<b>pDepthStencilAttachment</b>: " << *a.pDepthStencilAttachment;
    }
    else
    {
        os << ".<b>pDepthStencilAttachment</b>: null";
    }
    os << "" << NewEntry;
    os << ".<b>preserveAttachmentCount</b>: " << a.preserveAttachmentCount << NewEntry;
    if (a.pPreserveAttachments && a.preserveAttachmentCount > 0)
    {
        for (uint32_t i = 0; i < a.preserveAttachmentCount; i++)
        {
            os << ".<b>pPreserveAttachments</b>[" << i << "]:" << a.pPreserveAttachments[i];
            if (i < a.preserveAttachmentCount - 1)
                os << NewEntry;
        }
    }
    else
    {
        os << ".<b>pPreserveAttachments</b>: null";
    }
    os << "";
    os << CloseBracket;
    return os;
}

std::ostream &operator<<(std::ostream &os, const VkSubpassDependency &a)
{
    os << OpenBracket;
    os << NewEntry;
    os << ".<b>srcSubpass</b>: " << a.srcSubpass << NewEntry;
    os << ".<b>dstSubpass</b>: " << a.dstSubpass << NewEntry;
    os << ".<b>srcStageMask</b>: " << GetVkPipelineStageBits(a.srcStageMask) << NewEntry;
    os << ".<b>dstStageMask</b>: " << GetVkPipelineStageBits(a.dstStageMask) << NewEntry;
    os << ".<b>srcAccessMask</b>: " << a.srcAccessMask << NewEntry;
    os << ".<b>dstAccessMask</b>: " << a.dstAccessMask << NewEntry;
    os << ".<b>dependencyFlags</b>: " << a.dependencyFlags;
    os << CloseBracket;
    return os;
}

void PrintCreateBufferArgs(std::ostream &os, const CreateBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCreateBufferViewArgs(std::ostream &os, const CreateBufferViewArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintBeginCommandBufferArgs(std::ostream &os, const BeginCommandBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pBeginInfo</b>: ";
    os << OpenBracket;
    if (args.pBeginInfo)
    {
        os << *args.pBeginInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintEndCommandBufferArgs(std::ostream &os, const EndCommandBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer;
    os << NewEntry << "</pre>";
}

void PrintResetCommandBufferArgs(std::ostream &os, const ResetCommandBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>flags</b>: " << args.flags;
    os << NewEntry << "</pre>";
}

void PrintCmdExecuteCommandsArgs(std::ostream &os, const CmdExecuteCommandsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>commandBufferCount</b>: " << args.commandBufferCount;
    if ((uint64_t)args.commandBufferCount > 0 && args.pCommandBuffers == nullptr)
    {
        os << NewEntry << "<b>pCommandBuffers</b>:NOT CAPTURED";
    }
    else if (args.pCommandBuffers)
    {
        os << NewEntry << "<b>pCommandBuffers</b>: ";
        if ((uint64_t)args.commandBufferCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.commandBufferCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pCommandBuffers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pCommandBuffers</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdCopyBufferArgs(std::ostream &os, const CmdCopyBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcBuffer</b>: " << args.srcBuffer << NewEntry;
    os << "<b>dstBuffer</b>: " << args.dstBuffer << NewEntry;
    os << "<b>regionCount</b>: " << args.regionCount;
    if ((uint64_t)args.regionCount > 0 && args.pRegions == nullptr)
    {
        os << NewEntry << "<b>pRegions</b>:NOT CAPTURED";
    }
    else if (args.pRegions)
    {
        os << NewEntry << "<b>pRegions</b>: ";
        if ((uint64_t)args.regionCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.regionCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRegions[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRegions</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdCopyImageArgs(std::ostream &os, const CmdCopyImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcImage</b>: " << args.srcImage << NewEntry;
    os << "<b>srcImageLayout</b>: " << GetVkImageLayoutString(args.srcImageLayout) << NewEntry;
    os << "<b>dstImage</b>: " << args.dstImage << NewEntry;
    os << "<b>dstImageLayout</b>: " << GetVkImageLayoutString(args.dstImageLayout) << NewEntry;
    os << "<b>regionCount</b>: " << args.regionCount;
    if ((uint64_t)args.regionCount > 0 && args.pRegions == nullptr)
    {
        os << NewEntry << "<b>pRegions</b>:NOT CAPTURED";
    }
    else if (args.pRegions)
    {
        os << NewEntry << "<b>pRegions</b>: ";
        if ((uint64_t)args.regionCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.regionCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRegions[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRegions</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdBlitImageArgs(std::ostream &os, const CmdBlitImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcImage</b>: " << args.srcImage << NewEntry;
    os << "<b>srcImageLayout</b>: " << GetVkImageLayoutString(args.srcImageLayout) << NewEntry;
    os << "<b>dstImage</b>: " << args.dstImage << NewEntry;
    os << "<b>dstImageLayout</b>: " << GetVkImageLayoutString(args.dstImageLayout) << NewEntry;
    os << "<b>regionCount</b>: " << args.regionCount << NewEntry;
    os << "<b>filter</b>: " << args.filter;
    if ((uint64_t)args.regionCount > 0 && args.pRegions == nullptr)
    {
        os << NewEntry << "<b>pRegions</b>:NOT CAPTURED";
    }
    else if (args.pRegions)
    {
        os << NewEntry << "<b>pRegions</b>: ";
        if ((uint64_t)args.regionCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.regionCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRegions[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRegions</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdCopyBufferToImageArgs(std::ostream &os, const CmdCopyBufferToImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcBuffer</b>: " << args.srcBuffer << NewEntry;
    os << "<b>dstImage</b>: " << args.dstImage << NewEntry;
    os << "<b>dstImageLayout</b>: " << GetVkImageLayoutString(args.dstImageLayout) << NewEntry;
    os << "<b>regionCount</b>: " << args.regionCount;
    if ((uint64_t)args.regionCount > 0 && args.pRegions == nullptr)
    {
        os << NewEntry << "<b>pRegions</b>:NOT CAPTURED";
    }
    else if (args.pRegions)
    {
        os << NewEntry << "<b>pRegions</b>: ";
        if ((uint64_t)args.regionCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.regionCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRegions[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRegions</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdCopyImageToBufferArgs(std::ostream &os, const CmdCopyImageToBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcImage</b>: " << args.srcImage << NewEntry;
    os << "<b>srcImageLayout</b>: " << GetVkImageLayoutString(args.srcImageLayout) << NewEntry;
    os << "<b>dstBuffer</b>: " << args.dstBuffer << NewEntry;
    os << "<b>regionCount</b>: " << args.regionCount;
    if ((uint64_t)args.regionCount > 0 && args.pRegions == nullptr)
    {
        os << NewEntry << "<b>pRegions</b>:NOT CAPTURED";
    }
    else if (args.pRegions)
    {
        os << NewEntry << "<b>pRegions</b>: ";
        if ((uint64_t)args.regionCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.regionCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRegions[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRegions</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdUpdateBufferArgs(std::ostream &os, const CmdUpdateBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>dstBuffer</b>: " << args.dstBuffer << NewEntry;
    os << "<b>dstOffset</b>: " << args.dstOffset << NewEntry;
    os << "<b>dataSize</b>: " << args.dataSize;
    os << NewEntry << "</pre>";
}

void PrintCmdFillBufferArgs(std::ostream &os, const CmdFillBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>dstBuffer</b>: " << args.dstBuffer << NewEntry;
    os << "<b>dstOffset</b>: " << args.dstOffset << NewEntry;
    os << "<b>size</b>: " << args.size << NewEntry;
    os << "<b>data</b>: " << args.data;
    os << NewEntry << "</pre>";
}

void PrintCmdClearColorImageArgs(std::ostream &os, const CmdClearColorImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>image</b>: " << args.image << NewEntry;
    os << "<b>imageLayout</b>: " << GetVkImageLayoutString(args.imageLayout) << NewEntry;
    os << "<b>rangeCount</b>: " << args.rangeCount << NewEntry;
    os << "<b>pColor</b>: ";
    os << OpenBracket;
    if (args.pColor)
    {
        os << *args.pColor;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    if ((uint64_t)args.rangeCount > 0 && args.pRanges == nullptr)
    {
        os << NewEntry << "<b>pRanges</b>:NOT CAPTURED";
    }
    else if (args.pRanges)
    {
        os << NewEntry << "<b>pRanges</b>: ";
        if ((uint64_t)args.rangeCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.rangeCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRanges[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRanges</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdClearDepthStencilImageArgs(std::ostream &os, const CmdClearDepthStencilImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>image</b>: " << args.image << NewEntry;
    os << "<b>imageLayout</b>: " << GetVkImageLayoutString(args.imageLayout) << NewEntry;
    os << "<b>rangeCount</b>: " << args.rangeCount << NewEntry;
    os << "<b>pDepthStencil</b>: ";
    os << OpenBracket;
    if (args.pDepthStencil)
    {
        os << *args.pDepthStencil;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    if ((uint64_t)args.rangeCount > 0 && args.pRanges == nullptr)
    {
        os << NewEntry << "<b>pRanges</b>:NOT CAPTURED";
    }
    else if (args.pRanges)
    {
        os << NewEntry << "<b>pRanges</b>: ";
        if ((uint64_t)args.rangeCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.rangeCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRanges[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRanges</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdClearAttachmentsArgs(std::ostream &os, const CmdClearAttachmentsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>attachmentCount</b>: " << args.attachmentCount << NewEntry;
    os << "<b>rectCount</b>: " << args.rectCount;
    if ((uint64_t)args.attachmentCount > 0 && args.pAttachments == nullptr)
    {
        os << NewEntry << "<b>pAttachments</b>:NOT CAPTURED";
    }
    else if (args.pAttachments)
    {
        os << NewEntry << "<b>pAttachments</b>: ";
        if ((uint64_t)args.attachmentCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.attachmentCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pAttachments[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pAttachments</b>: null";
    }
    if ((uint64_t)args.rectCount > 0 && args.pRects == nullptr)
    {
        os << NewEntry << "<b>pRects</b>:NOT CAPTURED";
    }
    else if (args.pRects)
    {
        os << NewEntry << "<b>pRects</b>: ";
        if ((uint64_t)args.rectCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.rectCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRects[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRects</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdResolveImageArgs(std::ostream &os, const CmdResolveImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcImage</b>: " << args.srcImage << NewEntry;
    os << "<b>srcImageLayout</b>: " << GetVkImageLayoutString(args.srcImageLayout) << NewEntry;
    os << "<b>dstImage</b>: " << args.dstImage << NewEntry;
    os << "<b>dstImageLayout</b>: " << GetVkImageLayoutString(args.dstImageLayout) << NewEntry;
    os << "<b>regionCount</b>: " << args.regionCount;
    if ((uint64_t)args.regionCount > 0 && args.pRegions == nullptr)
    {
        os << NewEntry << "<b>pRegions</b>:NOT CAPTURED";
    }
    else if (args.pRegions)
    {
        os << NewEntry << "<b>pRegions</b>: ";
        if ((uint64_t)args.regionCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.regionCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pRegions[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pRegions</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCreateDescriptorSetLayoutArgs(std::ostream &os, const CreateDescriptorSetLayoutArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintAllocateDescriptorSetsArgs(std::ostream &os, const AllocateDescriptorSetsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocateInfo</b>: ";
    os << OpenBracket;
    if (args.pAllocateInfo)
    {
        os << *args.pAllocateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    if (args.pDescriptorSets)
    {
        os << NewEntry << "<b>pDescriptorSets</b>: ";
        if ((uint64_t)args.pAllocateInfo->descriptorSetCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = 0; i < (uint64_t)args.pAllocateInfo->descriptorSetCount; i++)
            {
                os << NewEntry;
                os << "- " << args.pDescriptorSets[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    os << "";
    os << NewEntry << "</pre>";
}

void PrintUpdateDescriptorSetsArgs(std::ostream &os, const UpdateDescriptorSetsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>descriptorWriteCount</b>: " << args.descriptorWriteCount << NewEntry;
    os << "<b>descriptorCopyCount</b>: " << args.descriptorCopyCount;
    if ((uint64_t)args.descriptorWriteCount > 0 && args.pDescriptorWrites == nullptr)
    {
        os << NewEntry << "<b>pDescriptorWrites</b>:NOT CAPTURED";
    }
    else if (args.pDescriptorWrites)
    {
        os << NewEntry << "<b>pDescriptorWrites</b>: ";
        if ((uint64_t)args.descriptorWriteCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.descriptorWriteCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pDescriptorWrites[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pDescriptorWrites</b>: null";
    }
    os << "";
    if ((uint64_t)args.descriptorCopyCount > 0 && args.pDescriptorCopies == nullptr)
    {
        os << NewEntry << "<b>pDescriptorCopies</b>:NOT CAPTURED";
    }
    else if (args.pDescriptorCopies)
    {
        os << NewEntry << "<b>pDescriptorCopies</b>: ";
        if ((uint64_t)args.descriptorCopyCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.descriptorCopyCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pDescriptorCopies[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pDescriptorCopies</b>: null";
    }
    os << "";
    os << NewEntry << "</pre>";
}

void PrintCmdBindDescriptorSetsArgs(std::ostream &os, const CmdBindDescriptorSetsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pipelineBindPoint</b>: " << args.pipelineBindPoint << NewEntry;
    os << "<b>layout</b>: " << args.layout << NewEntry;
    os << "<b>firstSet</b>: " << args.firstSet << NewEntry;
    os << "<b>descriptorSetCount</b>: " << args.descriptorSetCount << NewEntry;
    os << "<b>dynamicOffsetCount</b>: " << args.dynamicOffsetCount;
    if ((uint64_t)args.descriptorSetCount > 0 && args.pDescriptorSets == nullptr)
    {
        os << NewEntry << "<b>pDescriptorSets</b>:NOT CAPTURED";
    }
    else if (args.pDescriptorSets)
    {
        os << NewEntry << "<b>pDescriptorSets</b>: ";
        if ((uint64_t)args.descriptorSetCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.descriptorSetCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pDescriptorSets[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pDescriptorSets</b>: null";
    }
    if ((uint64_t)args.dynamicOffsetCount > 0 && args.pDynamicOffsets == nullptr)
    {
        os << NewEntry << "<b>pDynamicOffsets</b>:NOT CAPTURED";
    }
    else if (args.pDynamicOffsets)
    {
        os << NewEntry << "<b>pDynamicOffsets</b>: ";
        if ((uint64_t)args.dynamicOffsetCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.dynamicOffsetCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pDynamicOffsets[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pDynamicOffsets</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdPushConstantsArgs(std::ostream &os, const CmdPushConstantsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>layout</b>: " << args.layout << NewEntry;
    os << "<b>stageFlags</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.stageFlags & (args.stageFlags - 1)) != 0)
        os << NewEntry;
    os << GetVkShaderStageBits(args.stageFlags, NewEntryStr(os).c_str());
    os << CloseBracket << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>size</b>: " << args.size;
    os << NewEntry << "</pre>";
}

void PrintCmdBindIndexBufferArgs(std::ostream &os, const CmdBindIndexBufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>indexType</b>: " << args.indexType;
    os << NewEntry << "</pre>";
}

void PrintCmdBindVertexBuffersArgs(std::ostream &os, const CmdBindVertexBuffersArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>firstBinding</b>: " << args.firstBinding << NewEntry;
    os << "<b>bindingCount</b>: " << args.bindingCount;
    if ((uint64_t)args.bindingCount > 0 && args.pBuffers == nullptr)
    {
        os << NewEntry << "<b>pBuffers</b>:NOT CAPTURED";
    }
    else if (args.pBuffers)
    {
        os << NewEntry << "<b>pBuffers</b>: ";
        if ((uint64_t)args.bindingCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.bindingCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pBuffers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pBuffers</b>: null";
    }
    if ((uint64_t)args.bindingCount > 0 && args.pOffsets == nullptr)
    {
        os << NewEntry << "<b>pOffsets</b>:NOT CAPTURED";
    }
    else if (args.pOffsets)
    {
        os << NewEntry << "<b>pOffsets</b>: ";
        if ((uint64_t)args.bindingCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.bindingCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pOffsets[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pOffsets</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdDrawArgs(std::ostream &os, const CmdDrawArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>vertexCount</b>: " << args.vertexCount << NewEntry;
    os << "<b>instanceCount</b>: " << args.instanceCount << NewEntry;
    os << "<b>firstVertex</b>: " << args.firstVertex << NewEntry;
    os << "<b>firstInstance</b>: " << args.firstInstance;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndexedArgs(std::ostream &os, const CmdDrawIndexedArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>indexCount</b>: " << args.indexCount << NewEntry;
    os << "<b>instanceCount</b>: " << args.instanceCount << NewEntry;
    os << "<b>firstIndex</b>: " << args.firstIndex << NewEntry;
    os << "<b>vertexOffset</b>: " << args.vertexOffset << NewEntry;
    os << "<b>firstInstance</b>: " << args.firstInstance;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndirectArgs(std::ostream &os, const CmdDrawIndirectArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>drawCount</b>: " << args.drawCount << NewEntry;
    os << "<b>stride</b>: " << args.stride;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndexedIndirectArgs(std::ostream &os, const CmdDrawIndexedIndirectArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>drawCount</b>: " << args.drawCount << NewEntry;
    os << "<b>stride</b>: " << args.stride;
    os << NewEntry << "</pre>";
}

void PrintCmdDispatchArgs(std::ostream &os, const CmdDispatchArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>groupCountX</b>: " << args.groupCountX << NewEntry;
    os << "<b>groupCountY</b>: " << args.groupCountY << NewEntry;
    os << "<b>groupCountZ</b>: " << args.groupCountZ;
    os << NewEntry << "</pre>";
}

void PrintCmdDispatchIndirectArgs(std::ostream &os, const CmdDispatchIndirectArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset;
    os << NewEntry << "</pre>";
}

void PrintCreateImageArgs(std::ostream &os, const CreateImageArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCreateImageViewArgs(std::ostream &os, const CreateImageViewArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdBindPipelineArgs(std::ostream &os, const CmdBindPipelineArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pipelineBindPoint</b>: " << args.pipelineBindPoint << NewEntry;
    os << "<b>pipeline</b>: " << args.pipeline;
    os << NewEntry << "</pre>";
}

void PrintCmdSetViewportArgs(std::ostream &os, const CmdSetViewportArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>firstViewport</b>: " << args.firstViewport << NewEntry;
    os << "<b>viewportCount</b>: " << args.viewportCount;
    if ((uint64_t)args.viewportCount > 0 && args.pViewports == nullptr)
    {
        os << NewEntry << "<b>pViewports</b>:NOT CAPTURED";
    }
    else if (args.pViewports)
    {
        os << NewEntry << "<b>pViewports</b>: ";
        if ((uint64_t)args.viewportCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.viewportCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pViewports[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pViewports</b>: null";
    }
    os << "";
    os << NewEntry << "</pre>";
}

void PrintCmdSetScissorArgs(std::ostream &os, const CmdSetScissorArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>firstScissor</b>: " << args.firstScissor << NewEntry;
    os << "<b>scissorCount</b>: " << args.scissorCount;
    if ((uint64_t)args.scissorCount > 0 && args.pScissors == nullptr)
    {
        os << NewEntry << "<b>pScissors</b>:NOT CAPTURED";
    }
    else if (args.pScissors)
    {
        os << NewEntry << "<b>pScissors</b>: ";
        if ((uint64_t)args.scissorCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.scissorCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pScissors[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pScissors</b>: null";
    }
    os << "";
    os << NewEntry << "</pre>";
}

void PrintCmdSetLineWidthArgs(std::ostream &os, const CmdSetLineWidthArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>lineWidth</b>: " << args.lineWidth;
    os << NewEntry << "</pre>";
}

void PrintCmdSetDepthBiasArgs(std::ostream &os, const CmdSetDepthBiasArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>depthBiasConstantFactor</b>: " << args.depthBiasConstantFactor << NewEntry;
    os << "<b>depthBiasClamp</b>: " << args.depthBiasClamp << NewEntry;
    os << "<b>depthBiasSlopeFactor</b>: " << args.depthBiasSlopeFactor;
    os << NewEntry << "</pre>";
}

void PrintCmdSetBlendConstantsArgs(std::ostream &os, const CmdSetBlendConstantsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>blendConstants</b>: { ";
    os << OpenBracket;
    os << NewEntry;
    for (uint32_t i = 0; i < 4; ++i)
    {
        os << "- " << args.blendConstants[i];
    }
    os << CloseBracket;
    os << NewEntry << "</pre>";
}

void PrintCmdSetDepthBoundsArgs(std::ostream &os, const CmdSetDepthBoundsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>minDepthBounds</b>: " << args.minDepthBounds << NewEntry;
    os << "<b>maxDepthBounds</b>: " << args.maxDepthBounds;
    os << NewEntry << "</pre>";
}

void PrintCmdSetStencilCompareMaskArgs(std::ostream &os, const CmdSetStencilCompareMaskArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>faceMask</b>: " << GetVkStencilFaceFlags(args.faceMask) << NewEntry;
    os << "<b>compareMask</b>: " << args.compareMask;
    os << NewEntry << "</pre>";
}

void PrintCmdSetStencilWriteMaskArgs(std::ostream &os, const CmdSetStencilWriteMaskArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>faceMask</b>: " << GetVkStencilFaceFlags(args.faceMask) << NewEntry;
    os << "<b>writeMask</b>: " << args.writeMask;
    os << NewEntry << "</pre>";
}

void PrintCmdSetStencilReferenceArgs(std::ostream &os, const CmdSetStencilReferenceArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>faceMask</b>: " << GetVkStencilFaceFlags(args.faceMask) << NewEntry;
    os << "<b>reference</b>: " << args.reference;
    os << NewEntry << "</pre>";
}

void PrintCmdBeginQueryArgs(std::ostream &os, const CmdBeginQueryArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>queryPool</b>: " << args.queryPool << NewEntry;
    os << "<b>query</b>: " << args.query << NewEntry;
    os << "<b>flags</b>: " << args.flags;
    os << NewEntry << "</pre>";
}

void PrintCmdEndQueryArgs(std::ostream &os, const CmdEndQueryArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>queryPool</b>: " << args.queryPool << NewEntry;
    os << "<b>query</b>: " << args.query;
    os << NewEntry << "</pre>";
}

void PrintCmdResetQueryPoolArgs(std::ostream &os, const CmdResetQueryPoolArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>queryPool</b>: " << args.queryPool << NewEntry;
    os << "<b>firstQuery</b>: " << args.firstQuery << NewEntry;
    os << "<b>queryCount</b>: " << args.queryCount;
    os << NewEntry << "</pre>";
}

void PrintCmdWriteTimestampArgs(std::ostream &os, const CmdWriteTimestampArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pipelineStage</b>: " << args.pipelineStage << NewEntry;
    os << "<b>queryPool</b>: " << args.queryPool << NewEntry;
    os << "<b>query</b>: " << args.query;
    os << NewEntry << "</pre>";
}

void PrintCmdCopyQueryPoolResultsArgs(std::ostream &os, const CmdCopyQueryPoolResultsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>queryPool</b>: " << args.queryPool << NewEntry;
    os << "<b>firstQuery</b>: " << args.firstQuery << NewEntry;
    os << "<b>queryCount</b>: " << args.queryCount << NewEntry;
    os << "<b>dstBuffer</b>: " << args.dstBuffer << NewEntry;
    os << "<b>dstOffset</b>: " << args.dstOffset << NewEntry;
    os << "<b>stride</b>: " << args.stride << NewEntry;
    os << "<b>flags</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.flags & (args.flags - 1)) != 0)
        os << NewEntry;
    os << GetVkQueryResultFlagBits(args.flags, NewEntryStr(os).c_str());
    os << CloseBracket;
    os << NewEntry << "</pre>";
}

void PrintQueueSubmitArgs(std::ostream &os, const QueueSubmitArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>queue</b>: " << args.queue << NewEntry;
    os << "<b>submitCount</b>: " << args.submitCount << NewEntry;
    os << "<b>fence</b>: " << args.fence;
    if ((uint64_t)args.submitCount > 0 && args.pSubmits == nullptr)
    {
        os << NewEntry << "<b>pSubmits</b>:NOT CAPTURED";
    }
    else if (args.pSubmits)
    {
        os << NewEntry << "<b>pSubmits</b>: ";
        if ((uint64_t)args.submitCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.submitCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pSubmits[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pSubmits</b>: null";
    }
    os << "";
    os << NewEntry << "</pre>";
}

void PrintCreateFramebufferArgs(std::ostream &os, const CreateFramebufferArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCreateRenderPassArgs(std::ostream &os, const CreateRenderPassArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>device</b>: " << args.device << NewEntry;
    os << "<b>pAllocator</b>: " << args.pAllocator << NewEntry;
    os << "<b>pCreateInfo</b>: ";
    os << OpenBracket;
    if (args.pCreateInfo)
    {
        os << *args.pCreateInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdBeginRenderPassArgs(std::ostream &os, const CmdBeginRenderPassArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>contents</b>: " << args.contents << NewEntry;
    os << "<b>pRenderPassBegin</b>: ";
    os << OpenBracket;
    if (args.pRenderPassBegin)
    {
        os << *args.pRenderPassBegin;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdNextSubpassArgs(std::ostream &os, const CmdNextSubpassArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>contents</b>: " << args.contents;
    os << NewEntry << "</pre>";
}

void PrintCmdEndRenderPassArgs(std::ostream &os, const CmdEndRenderPassArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer;
    os << NewEntry << "</pre>";
}

void PrintCmdSetEventArgs(std::ostream &os, const CmdSetEventArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>event</b>: " << args.event << NewEntry;
    os << "<b>stageMask</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.stageMask & (args.stageMask - 1)) != 0)
        os << NewEntry;
    os << GetVkPipelineStageBits(args.stageMask, NewEntryStr(os).c_str());
    os << CloseBracket;
    os << NewEntry << "</pre>";
}

void PrintCmdResetEventArgs(std::ostream &os, const CmdResetEventArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>event</b>: " << args.event << NewEntry;
    os << "<b>stageMask</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.stageMask & (args.stageMask - 1)) != 0)
        os << NewEntry;
    os << GetVkPipelineStageBits(args.stageMask, NewEntryStr(os).c_str());
    os << CloseBracket;
    os << NewEntry << "</pre>";
}

void PrintCmdWaitEventsArgs(std::ostream &os, const CmdWaitEventsArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>eventCount</b>: " << args.eventCount << NewEntry;
    os << "<b>srcStageMask</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.srcStageMask & (args.srcStageMask - 1)) != 0)
        os << NewEntry;
    os << GetVkPipelineStageBits(args.srcStageMask, NewEntryStr(os).c_str());
    os << CloseBracket << NewEntry;
    os << "<b>dstStageMask</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.dstStageMask & (args.dstStageMask - 1)) != 0)
        os << NewEntry;
    os << GetVkPipelineStageBits(args.dstStageMask, NewEntryStr(os).c_str());
    os << CloseBracket << NewEntry;
    os << "<b>memoryBarrierCount</b>: " << args.memoryBarrierCount << NewEntry;
    os << "<b>bufferMemoryBarrierCount</b>: " << args.bufferMemoryBarrierCount << NewEntry;
    os << "<b>imageMemoryBarrierCount</b>: " << args.imageMemoryBarrierCount;
    if ((uint64_t)args.eventCount > 0 && args.pEvents == nullptr)
    {
        os << NewEntry << "<b>pEvents</b>:NOT CAPTURED";
    }
    else if (args.pEvents)
    {
        os << NewEntry << "<b>pEvents</b>: ";
        if ((uint64_t)args.eventCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U)); i < (uint64_t)args.eventCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pEvents[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pEvents</b>: null";
    }
    if ((uint64_t)args.memoryBarrierCount > 0 && args.pMemoryBarriers == nullptr)
    {
        os << NewEntry << "<b>pMemoryBarriers</b>:NOT CAPTURED";
    }
    else if (args.pMemoryBarriers)
    {
        os << NewEntry << "<b>pMemoryBarriers</b>: ";
        if ((uint64_t)args.memoryBarrierCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.memoryBarrierCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pMemoryBarriers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pMemoryBarriers</b>: null";
    }
    if ((uint64_t)args.bufferMemoryBarrierCount > 0 && args.pBufferMemoryBarriers == nullptr)
    {
        os << NewEntry << "<b>pBufferMemoryBarriers</b>:NOT CAPTURED";
    }
    else if (args.pBufferMemoryBarriers)
    {
        os << NewEntry << "<b>pBufferMemoryBarriers</b>: ";
        if ((uint64_t)args.bufferMemoryBarrierCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.bufferMemoryBarrierCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pBufferMemoryBarriers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pBufferMemoryBarriers</b>: null";
    }
    if ((uint64_t)args.imageMemoryBarrierCount > 0 && args.pImageMemoryBarriers == nullptr)
    {
        os << NewEntry << "<b>pImageMemoryBarriers</b>:NOT CAPTURED";
    }
    else if (args.pImageMemoryBarriers)
    {
        os << NewEntry << "<b>pImageMemoryBarriers</b>: ";
        if ((uint64_t)args.imageMemoryBarrierCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.imageMemoryBarrierCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pImageMemoryBarriers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pImageMemoryBarriers</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdPipelineBarrierArgs(std::ostream &os, const CmdPipelineBarrierArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>srcStageMask</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.srcStageMask & (args.srcStageMask - 1)) != 0)
        os << NewEntry;
    os << GetVkPipelineStageBits(args.srcStageMask, NewEntryStr(os).c_str());
    os << CloseBracket << NewEntry;
    os << "<b>dstStageMask</b>: ";
    os << OpenBracket;
    // If there is only 1 bit set (ie. pow-of-2), can put it in the same line
    if ((args.dstStageMask & (args.dstStageMask - 1)) != 0)
        os << NewEntry;
    os << GetVkPipelineStageBits(args.dstStageMask, NewEntryStr(os).c_str());
    os << CloseBracket << NewEntry;
    os << "<b>dependencyFlags</b>: " << args.dependencyFlags << NewEntry;
    os << "<b>memoryBarrierCount</b>: " << args.memoryBarrierCount << NewEntry;
    os << "<b>bufferMemoryBarrierCount</b>: " << args.bufferMemoryBarrierCount << NewEntry;
    os << "<b>imageMemoryBarrierCount</b>: " << args.imageMemoryBarrierCount;
    if ((uint64_t)args.memoryBarrierCount > 0 && args.pMemoryBarriers == nullptr)
    {
        os << NewEntry << "<b>pMemoryBarriers</b>:NOT CAPTURED";
    }
    else if (args.pMemoryBarriers)
    {
        os << NewEntry << "<b>pMemoryBarriers</b>: ";
        if ((uint64_t)args.memoryBarrierCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.memoryBarrierCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pMemoryBarriers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pMemoryBarriers</b>: null";
    }
    if ((uint64_t)args.bufferMemoryBarrierCount > 0 && args.pBufferMemoryBarriers == nullptr)
    {
        os << NewEntry << "<b>pBufferMemoryBarriers</b>:NOT CAPTURED";
    }
    else if (args.pBufferMemoryBarriers)
    {
        os << NewEntry << "<b>pBufferMemoryBarriers</b>: ";
        if ((uint64_t)args.bufferMemoryBarrierCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.bufferMemoryBarrierCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pBufferMemoryBarriers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pBufferMemoryBarriers</b>: null";
    }
    if ((uint64_t)args.imageMemoryBarrierCount > 0 && args.pImageMemoryBarriers == nullptr)
    {
        os << NewEntry << "<b>pImageMemoryBarriers</b>:NOT CAPTURED";
    }
    else if (args.pImageMemoryBarriers)
    {
        os << NewEntry << "<b>pImageMemoryBarriers</b>: ";
        if ((uint64_t)args.imageMemoryBarrierCount > 0)
        {
            os << OpenBracket;
            for (uint32_t i = (uint64_t)(static_cast<uint32_t>(0U));
                 i < (uint64_t)args.imageMemoryBarrierCount;
                 i++)
            {
                os << NewEntry;
                os << "- " << args.pImageMemoryBarriers[i];
            }
            os << CloseBracket;
        }
        else
        {
            os << "[]";
        }
    }
    else
    {
        os << NewEntry << "<b>pImageMemoryBarriers</b>: null";
    };
    os << NewEntry << "</pre>";
}

void PrintCmdWriteBufferMarkerAMDArgs(std::ostream &os, const CmdWriteBufferMarkerAMDArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pipelineStage</b>: " << args.pipelineStage << NewEntry;
    os << "<b>dstBuffer</b>: " << args.dstBuffer << NewEntry;
    os << "<b>dstOffset</b>: " << args.dstOffset << NewEntry;
    os << "<b>marker</b>: " << args.marker;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndirectCountAMDArgs(std::ostream &os, const CmdDrawIndirectCountAMDArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>countBuffer</b>: " << args.countBuffer << NewEntry;
    os << "<b>countOffset</b>: " << args.countOffset << NewEntry;
    os << "<b>maxDrawCount</b>: " << args.maxDrawCount << NewEntry;
    os << "<b>stride</b>: " << args.stride;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndexedIndirectCountAMDArgs(std::ostream &                            os,
                                             const CmdDrawIndexedIndirectCountAMDArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>countBuffer</b>: " << args.countBuffer << NewEntry;
    os << "<b>countOffset</b>: " << args.countOffset << NewEntry;
    os << "<b>maxDrawCount</b>: " << args.maxDrawCount << NewEntry;
    os << "<b>stride</b>: " << args.stride;
    os << NewEntry << "</pre>";
}

void PrintCmdBeginConditionalRenderingEXTArgs(std::ostream &                             os,
                                              const CmdBeginConditionalRenderingEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer;
    os << "pConditinalRenderingBegin: ";
    os << OpenBracket;
    if (args.pConditinalRenderingBegin)
    {
        os << *args.pConditinalRenderingBegin;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    os << NewEntry << "</pre>";
}

void PrintCmdEndConditionalRenderingEXTArgs(std::ostream &                           os,
                                            const CmdEndConditionalRenderingEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer;
    os << NewEntry << "</pre>";
}

void PrintCmdDebugMarkerBeginEXTArgs(std::ostream &os, const CmdDebugMarkerBeginEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pMarkerInfo</b>: ";
    os << OpenBracket;
    if (args.pMarkerInfo)
    {
        os << *args.pMarkerInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdDebugMarkerEndEXTArgs(std::ostream &os, const CmdDebugMarkerEndEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer;
    os << NewEntry << "</pre>";
}

void PrintCmdDebugMarkerInsertEXTArgs(std::ostream &os, const CmdDebugMarkerInsertEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pMarkerInfo</b>: ";
    os << OpenBracket;
    if (args.pMarkerInfo)
    {
        os << *args.pMarkerInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdBeginDebugUtilsLabelEXTArgs(std::ostream &                        os,
                                         const CmdBeginDebugUtilsLabelEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pLabelInfo</b>: ";
    os << OpenBracket;
    if (args.pLabelInfo)
    {
        os << *args.pLabelInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdEndDebugUtilsLabelEXTArgs(std::ostream &os, const CmdEndDebugUtilsLabelEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer;
    os << NewEntry << "</pre>";
}

void PrintCmdInsertDebugUtilsLabelEXTArgs(std::ostream &                         os,
                                          const CmdInsertDebugUtilsLabelEXTArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>pLabelInfo</b>: ";
    os << OpenBracket;
    if (args.pLabelInfo)
    {
        os << *args.pLabelInfo;  // [READ]parameter
    }
    else
    {
        os << "nullptr";
    }
    os << CloseBracket;
    ;
    os << NewEntry << "</pre>";
}

void PrintCmdSetDeviceMaskKHRArgs(std::ostream &os, const CmdSetDeviceMaskKHRArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>deviceMask</b>: " << args.deviceMask;
    os << NewEntry << "</pre>";
}

void PrintCmdSetDeviceMaskArgs(std::ostream &os, const CmdSetDeviceMaskArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>deviceMask</b>: " << args.deviceMask;
    os << NewEntry << "</pre>";
}

void PrintCmdDispatchBaseKHRArgs(std::ostream &os, const CmdDispatchBaseKHRArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>baseGroupX</b>: " << args.baseGroupX << NewEntry;
    os << "<b>baseGroupY</b>: " << args.baseGroupY << NewEntry;
    os << "<b>baseGroupZ</b>: " << args.baseGroupZ << NewEntry;
    os << "<b>groupCountX</b>: " << args.groupCountX << NewEntry;
    os << "<b>groupCountY</b>: " << args.groupCountY << NewEntry;
    os << "<b>groupCountZ</b>: " << args.groupCountZ;
    os << NewEntry << "</pre>";
}

void PrintCmdDispatchBaseArgs(std::ostream &os, const CmdDispatchBaseArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>baseGroupX</b>: " << args.baseGroupX << NewEntry;
    os << "<b>baseGroupY</b>: " << args.baseGroupY << NewEntry;
    os << "<b>baseGroupZ</b>: " << args.baseGroupZ << NewEntry;
    os << "<b>groupCountX</b>: " << args.groupCountX << NewEntry;
    os << "<b>groupCountY</b>: " << args.groupCountY << NewEntry;
    os << "<b>groupCountZ</b>: " << args.groupCountZ;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndirectCountKHRArgs(std::ostream &os, const CmdDrawIndirectCountKHRArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>countBuffer</b>: " << args.countBuffer << NewEntry;
    os << "<b>countOffset</b>: " << args.countOffset << NewEntry;
    os << "<b>maxDrawCount</b>: " << args.maxDrawCount << NewEntry;
    os << "<b>stride</b>: " << args.stride;
    os << NewEntry << "</pre>";
}

void PrintCmdDrawIndexedIndirectCountKHRArgs(std::ostream &                            os,
                                             const CmdDrawIndexedIndirectCountKHRArgs &args)
{
    IndentGuard indent(os, kDefaultParamIndent);
    os << NewEntry << "<pre>";
    os << NewEntry;
    os << "<b>commandBuffer</b>: " << args.commandBuffer << NewEntry;
    os << "<b>buffer</b>: " << args.buffer << NewEntry;
    os << "<b>offset</b>: " << args.offset << NewEntry;
    os << "<b>countBuffer</b>: " << args.countBuffer << NewEntry;
    os << "<b>countOffset</b>: " << args.countOffset << NewEntry;
    os << "<b>maxDrawCount</b>: " << args.maxDrawCount << NewEntry;
    os << "<b>stride</b>: " << args.stride;
    os << NewEntry << "</pre>";
}

}  // namespace Dive