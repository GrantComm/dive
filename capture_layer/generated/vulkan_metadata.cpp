/*
 * Copyright (C) 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

#include "vulkan_metadata.h"

#include <array>
#include <atomic>

#include "capture_service.h"
#include "command_printer.h"
#include "command_recorder.h"
#include "core/hw/gfxip/gfx9/chip/gfx9_plus_merged_f32_pfp_pm4_packets.h"
#include "dive_core/common/dive_capture_format.h"
#include "layer.h"
#include "string_crc32.h"

namespace Dive
{

namespace
{

// The limit is defined in ICD at
// proprietary/drivers/xgl/icd/imported/pal/src/core/device.h:Device::CmdStreamReserveLimit and
// needs to substract the size of PM4_PFP_NOP_SIZEDW__CORE;
constexpr size_t kMaxPayloadLen = 256 * sizeof(uint32_t) -
                                  PM4_PFP_NOP_SIZEDW__CORE * sizeof(uint32_t);
static bool kEnableCaptureDebugPrint = false;

const char* LAYER_NAME = "Dive";
#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
const VkExtensionProperties INSTANCE_EXTENSIONS[] = {
    { VK_EXT_DEBUG_UTILS_EXTENSION_NAME, VK_EXT_DEBUG_UTILS_SPEC_VERSION },
};
const uint32_t              NUM_INSTANCE_EXTENSIONS = ARRAY_SIZE(INSTANCE_EXTENSIONS);
const VkExtensionProperties DEVICE_EXTENSIONS[] = {
    { VK_EXT_DEBUG_MARKER_EXTENSION_NAME, VK_EXT_DEBUG_MARKER_SPEC_VERSION },
};
const uint32_t NUM_DEVICE_EXTENSIONS = ARRAY_SIZE(DEVICE_EXTENSIONS);
#undef ARRAY_SIZE

}  // namespace

void insertCmdMarkers(VKCmdID         cmdID,
                      VkCommandBuffer commandBuffer,
                      void*           commandArgs,
                      size_t          argsSize)
{
    PFN_vkInsertDiveMarkerGGP fn = GetVkCommandBufferDataCached(commandBuffer)
                                   .functions->insert_dive_marker;
    if (!fn)
    {
        return;
    }

    // Up-round to multiple of sizeof(uint32_t)
    argsSize = (argsSize + sizeof(uint32_t) - 1) & (~(sizeof(uint32_t) - 1));
    fn(commandBuffer, commandArgs, argsSize, VK_DIVE_MARKER_TYPE_NOP);
}

VkResult vkCreateDevice(PFN_vkCreateDevice        next,
                        VkPhysicalDevice          physicalDevice,
                        VkDeviceCreateInfo const* pCreateInfo,
                        AllocationCallbacks       pAllocator,
                        VkDevice*                 pDevice)
{
    return next(physicalDevice, pCreateInfo, pAllocator, pDevice);
}

VkResult enumerateExtensionPropertiesForLayer(uint32_t*                   pPropertyCount,
                                              VkExtensionProperties*      pProperties,
                                              uint32_t                    numExtensions,
                                              const VkExtensionProperties extensions[])
{
    if (pProperties == nullptr)
    {
        *pPropertyCount = numExtensions;
        return VK_SUCCESS;
    }
    uint32_t capacity = std::min(*pPropertyCount, numExtensions);
    memcpy(pProperties, extensions, capacity * sizeof(VkExtensionProperties));
    if (*pPropertyCount < numExtensions)
    {
        return VK_INCOMPLETE;
    }
    else
    {
        *pPropertyCount = numExtensions;
        return VK_SUCCESS;
    }
}

// This layer adds VK_EXT_debug_utils as a supported extension.
VkResult vkEnumerateInstanceExtensionProperties(PFN_vkEnumerateInstanceExtensionProperties next,
                                                char const*            pLayerName,
                                                uint32_t*              pPropertyCount,
                                                VkExtensionProperties* pProperties)
{
    if (pLayerName != nullptr && strcmp(pLayerName, LAYER_NAME) == 0)
    {
        return enumerateExtensionPropertiesForLayer(pPropertyCount,
                                                    pProperties,
                                                    NUM_INSTANCE_EXTENSIONS,
                                                    INSTANCE_EXTENSIONS);
    }
    return next(pLayerName, pPropertyCount, pProperties);
}

VkResult vkEnumerateDeviceExtensionProperties(PFN_vkEnumerateDeviceExtensionProperties next,
                                              VkPhysicalDevice       physicalDevice,
                                              char const*            pLayerName,
                                              uint32_t*              pPropertyCount,
                                              VkExtensionProperties* pProperties)
{
    if (pLayerName != nullptr && strcmp(pLayerName, LAYER_NAME) == 0)
    {
        return enumerateExtensionPropertiesForLayer(pPropertyCount,
                                                    pProperties,
                                                    NUM_DEVICE_EXTENSIONS,
                                                    DEVICE_EXTENSIONS);
    }
    uint32_t max_extensions = *pPropertyCount;
    uint32_t num_other_extensions = 0;
    VkResult result = next(physicalDevice, nullptr, &num_other_extensions, nullptr);
    if (result != VK_SUCCESS)
    {
        return result;
    }
    // Call down to get other device properties
    std::vector<VkExtensionProperties> extensions(num_other_extensions);
    result = next(physicalDevice, pLayerName, &num_other_extensions, &extensions[0]);
    // add our extensions if requested
    if (result == VK_SUCCESS)
    {
        // set and copy base extensions
        *pPropertyCount = num_other_extensions;
        if (pProperties != nullptr)
        {
            memcpy(pProperties,
                   &extensions[0],
                   num_other_extensions * sizeof(VkExtensionProperties));
        }
        // find our unique extensions that need to be added
        uint32_t                                  num_additional_extensions = 0;
        auto                                      num_device_extensions = NUM_DEVICE_EXTENSIONS;
        std::vector<const VkExtensionProperties*> additional_extensions(num_device_extensions);
        for (size_t i = 0; i < num_device_extensions; ++i)
        {
            bool is_unique_extension = true;
            for (size_t j = 0; j < num_other_extensions; ++j)
            {
                if (0 == strcmp(extensions[j].extensionName, DEVICE_EXTENSIONS[i].extensionName))
                {
                    is_unique_extension = false;
                    break;
                }
            }
            if (is_unique_extension)
            {
                additional_extensions[num_additional_extensions++] = &DEVICE_EXTENSIONS[i];
            }
        }
        // null properties, just count total extensions
        if (nullptr == pProperties)
        {
            *pPropertyCount += num_additional_extensions;
        }
        else
        {
            uint32_t numExtensions = num_other_extensions;
            for (size_t i = 0; i < num_additional_extensions && numExtensions < max_extensions; ++i)
            {
                pProperties[numExtensions++] = *additional_extensions[i];
            }
            *pPropertyCount = numExtensions;
            // not enough space for all extensions
            if (num_other_extensions + num_additional_extensions > max_extensions)
            {
                return VK_INCOMPLETE;
            }
        }
    }
    return result;
}

VkResult vkBeginCommandBuffer(PFN_vkBeginCommandBuffer        fn,
                              VkCommandBuffer                 commandBuffer,
                              VkCommandBufferBeginInfo const* pBeginInfo)
{
    auto ret = fn(commandBuffer, pBeginInfo);
    if (ret == VK_SUCCESS)
    {
        std::array<char, kMaxPayloadLen> mem{};
        LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
        void*                            reserved = allocator.Alloc(sizeof(NopVulkanCallHeader));
        if (reserved == nullptr)
        {
            return ret;
        }
        CommandRecorder recorder(&allocator);
        auto            args = recorder.RecordBeginCommandBuffer(commandBuffer, pBeginInfo);
        if (args == nullptr)
        {
            return ret;
        }
        if (kEnableCaptureDebugPrint)
        {
            PrintBeginCommandBufferArgs(std::cout, *args);
        }
        NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
        reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
        header->signature = kNopPayloadSignature;
        header->cmdID = static_cast<uint8_t>(VKCmdID::vkBeginCommandBufferCmdID);
        insertCmdMarkers(VKCmdID::vkBeginCommandBufferCmdID,
                         commandBuffer,
                         static_cast<void*>(header),
                         recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    }
    return ret;
}

VkResult vkEndCommandBuffer(PFN_vkEndCommandBuffer fn, VkCommandBuffer commandBuffer)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordEndCommandBuffer(commandBuffer);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintEndCommandBufferArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkEndCommandBufferCmdID);
    insertCmdMarkers(VKCmdID::vkEndCommandBufferCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    return fn(commandBuffer);
}

void vkCmdExecuteCommands(PFN_vkCmdExecuteCommands fn,
                          VkCommandBuffer          commandBuffer,
                          uint32_t                 commandBufferCount,
                          VkCommandBuffer const*   pCommandBuffers)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdExecuteCommands(commandBuffer,
                                                  commandBufferCount,
                                                  pCommandBuffers);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdExecuteCommandsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdExecuteCommandsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdExecuteCommandsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, commandBufferCount, pCommandBuffers);
}

void vkCmdCopyBuffer(PFN_vkCmdCopyBuffer fn,
                     VkCommandBuffer     commandBuffer,
                     VkBuffer            srcBuffer,
                     VkBuffer            dstBuffer,
                     uint32_t            regionCount,
                     VkBufferCopy const* pRegions)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdCopyBuffer(commandBuffer,
                                             srcBuffer,
                                             dstBuffer,
                                             regionCount,
                                             pRegions);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdCopyBufferArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdCopyBufferCmdID);
    insertCmdMarkers(VKCmdID::vkCmdCopyBufferCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}

void vkCmdCopyImage(PFN_vkCmdCopyImage fn,
                    VkCommandBuffer    commandBuffer,
                    VkImage            srcImage,
                    VkImageLayout      srcImageLayout,
                    VkImage            dstImage,
                    VkImageLayout      dstImageLayout,
                    uint32_t           regionCount,
                    VkImageCopy const* pRegions)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdCopyImage(commandBuffer,
                                            srcImage,
                                            srcImageLayout,
                                            dstImage,
                                            dstImageLayout,
                                            regionCount,
                                            pRegions);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdCopyImageArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdCopyImageCmdID);
    insertCmdMarkers(VKCmdID::vkCmdCopyImageCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}

void vkCmdBlitImage(PFN_vkCmdBlitImage fn,
                    VkCommandBuffer    commandBuffer,
                    VkImage            srcImage,
                    VkImageLayout      srcImageLayout,
                    VkImage            dstImage,
                    VkImageLayout      dstImageLayout,
                    uint32_t           regionCount,
                    VkImageBlit const* pRegions,
                    VkFilter           filter)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdBlitImage(commandBuffer,
                                            srcImage,
                                            srcImageLayout,
                                            dstImage,
                                            dstImageLayout,
                                            regionCount,
                                            pRegions,
                                            filter);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBlitImageArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBlitImageCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBlitImageCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer,
       srcImage,
       srcImageLayout,
       dstImage,
       dstImageLayout,
       regionCount,
       pRegions,
       filter);
}

void vkCmdCopyBufferToImage(PFN_vkCmdCopyBufferToImage fn,
                            VkCommandBuffer            commandBuffer,
                            VkBuffer                   srcBuffer,
                            VkImage                    dstImage,
                            VkImageLayout              dstImageLayout,
                            uint32_t                   regionCount,
                            VkBufferImageCopy const*   pRegions)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdCopyBufferToImage(commandBuffer,
                                                    srcBuffer,
                                                    dstImage,
                                                    dstImageLayout,
                                                    regionCount,
                                                    pRegions);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdCopyBufferToImageArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdCopyBufferToImageCmdID);
    insertCmdMarkers(VKCmdID::vkCmdCopyBufferToImageCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}

void vkCmdCopyImageToBuffer(PFN_vkCmdCopyImageToBuffer fn,
                            VkCommandBuffer            commandBuffer,
                            VkImage                    srcImage,
                            VkImageLayout              srcImageLayout,
                            VkBuffer                   dstBuffer,
                            uint32_t                   regionCount,
                            VkBufferImageCopy const*   pRegions)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdCopyImageToBuffer(commandBuffer,
                                                    srcImage,
                                                    srcImageLayout,
                                                    dstBuffer,
                                                    regionCount,
                                                    pRegions);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdCopyImageToBufferArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdCopyImageToBufferCmdID);
    insertCmdMarkers(VKCmdID::vkCmdCopyImageToBufferCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}

void vkCmdUpdateBuffer(PFN_vkCmdUpdateBuffer fn,
                       VkCommandBuffer       commandBuffer,
                       VkBuffer              dstBuffer,
                       VkDeviceSize          dstOffset,
                       VkDeviceSize          dataSize,
                       void const*           pData)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdUpdateBuffer(commandBuffer,
                                               dstBuffer,
                                               dstOffset,
                                               dataSize,
                                               pData);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdUpdateBufferArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdUpdateBufferCmdID);
    insertCmdMarkers(VKCmdID::vkCmdUpdateBufferCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}

void vkCmdFillBuffer(PFN_vkCmdFillBuffer fn,
                     VkCommandBuffer     commandBuffer,
                     VkBuffer            dstBuffer,
                     VkDeviceSize        dstOffset,
                     VkDeviceSize        size,
                     uint32_t            data)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdFillBufferArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdFillBufferCmdID);
    insertCmdMarkers(VKCmdID::vkCmdFillBufferCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, dstBuffer, dstOffset, size, data);
}

void vkCmdClearColorImage(PFN_vkCmdClearColorImage       fn,
                          VkCommandBuffer                commandBuffer,
                          VkImage                        image,
                          VkImageLayout                  imageLayout,
                          VkClearColorValue const*       pColor,
                          uint32_t                       rangeCount,
                          VkImageSubresourceRange const* pRanges)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdClearColorImage(commandBuffer,
                                                  image,
                                                  imageLayout,
                                                  pColor,
                                                  rangeCount,
                                                  pRanges);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdClearColorImageArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdClearColorImageCmdID);
    insertCmdMarkers(VKCmdID::vkCmdClearColorImageCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}

void vkCmdClearDepthStencilImage(PFN_vkCmdClearDepthStencilImage fn,
                                 VkCommandBuffer                 commandBuffer,
                                 VkImage                         image,
                                 VkImageLayout                   imageLayout,
                                 VkClearDepthStencilValue const* pDepthStencil,
                                 uint32_t                        rangeCount,
                                 VkImageSubresourceRange const*  pRanges)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdClearDepthStencilImage(commandBuffer,
                                                         image,
                                                         imageLayout,
                                                         pDepthStencil,
                                                         rangeCount,
                                                         pRanges);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdClearDepthStencilImageArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdClearDepthStencilImageCmdID);
    insertCmdMarkers(VKCmdID::vkCmdClearDepthStencilImageCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}

void vkCmdClearAttachments(PFN_vkCmdClearAttachments fn,
                           VkCommandBuffer           commandBuffer,
                           uint32_t                  attachmentCount,
                           VkClearAttachment const*  pAttachments,
                           uint32_t                  rectCount,
                           VkClearRect const*        pRects)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdClearAttachments(commandBuffer,
                                                   attachmentCount,
                                                   pAttachments,
                                                   rectCount,
                                                   pRects);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdClearAttachmentsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdClearAttachmentsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdClearAttachmentsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}

void vkCmdResolveImage(PFN_vkCmdResolveImage fn,
                       VkCommandBuffer       commandBuffer,
                       VkImage               srcImage,
                       VkImageLayout         srcImageLayout,
                       VkImage               dstImage,
                       VkImageLayout         dstImageLayout,
                       uint32_t              regionCount,
                       VkImageResolve const* pRegions)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdResolveImage(commandBuffer,
                                               srcImage,
                                               srcImageLayout,
                                               dstImage,
                                               dstImageLayout,
                                               regionCount,
                                               pRegions);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdResolveImageArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdResolveImageCmdID);
    insertCmdMarkers(VKCmdID::vkCmdResolveImageCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}

void vkCmdBindDescriptorSets(PFN_vkCmdBindDescriptorSets fn,
                             VkCommandBuffer             commandBuffer,
                             VkPipelineBindPoint         pipelineBindPoint,
                             VkPipelineLayout            layout,
                             uint32_t                    firstSet,
                             uint32_t                    descriptorSetCount,
                             VkDescriptorSet const*      pDescriptorSets,
                             uint32_t                    dynamicOffsetCount,
                             uint32_t const*             pDynamicOffsets)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdBindDescriptorSets(commandBuffer,
                                                     pipelineBindPoint,
                                                     layout,
                                                     firstSet,
                                                     descriptorSetCount,
                                                     pDescriptorSets,
                                                     dynamicOffsetCount,
                                                     pDynamicOffsets);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBindDescriptorSetsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBindDescriptorSetsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBindDescriptorSetsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer,
       pipelineBindPoint,
       layout,
       firstSet,
       descriptorSetCount,
       pDescriptorSets,
       dynamicOffsetCount,
       pDynamicOffsets);
}

void vkCmdPushConstants(PFN_vkCmdPushConstants fn,
                        VkCommandBuffer        commandBuffer,
                        VkPipelineLayout       layout,
                        VkShaderStageFlags     stageFlags,
                        uint32_t               offset,
                        uint32_t               size,
                        void const*            pValues)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder
                .RecordCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdPushConstantsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdPushConstantsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdPushConstantsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, layout, stageFlags, offset, size, pValues);
}

void vkCmdBindIndexBuffer(PFN_vkCmdBindIndexBuffer fn,
                          VkCommandBuffer          commandBuffer,
                          VkBuffer                 buffer,
                          VkDeviceSize             offset,
                          VkIndexType              indexType)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBindIndexBufferArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBindIndexBufferCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBindIndexBufferCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, indexType);
}

void vkCmdBindVertexBuffers(PFN_vkCmdBindVertexBuffers fn,
                            VkCommandBuffer            commandBuffer,
                            uint32_t                   firstBinding,
                            uint32_t                   bindingCount,
                            VkBuffer const*            pBuffers,
                            VkDeviceSize const*        pOffsets)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdBindVertexBuffers(commandBuffer,
                                                    firstBinding,
                                                    bindingCount,
                                                    pBuffers,
                                                    pOffsets);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBindVertexBuffersArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBindVertexBuffersCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBindVertexBuffersCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}

void vkCmdDraw(PFN_vkCmdDraw   fn,
               VkCommandBuffer commandBuffer,
               uint32_t        vertexCount,
               uint32_t        instanceCount,
               uint32_t        firstVertex,
               uint32_t        firstInstance)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDraw(commandBuffer,
                                       vertexCount,
                                       instanceCount,
                                       firstVertex,
                                       firstInstance);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}

void vkCmdDrawIndexed(PFN_vkCmdDrawIndexed fn,
                      VkCommandBuffer      commandBuffer,
                      uint32_t             indexCount,
                      uint32_t             instanceCount,
                      uint32_t             firstIndex,
                      int32_t              vertexOffset,
                      uint32_t             firstInstance)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDrawIndexed(commandBuffer,
                                              indexCount,
                                              instanceCount,
                                              firstIndex,
                                              vertexOffset,
                                              firstInstance);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndexedArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndexedCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndexedCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}

void vkCmdDrawIndirect(PFN_vkCmdDrawIndirect fn,
                       VkCommandBuffer       commandBuffer,
                       VkBuffer              buffer,
                       VkDeviceSize          offset,
                       uint32_t              drawCount,
                       uint32_t              stride)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndirectArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndirectCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndirectCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, drawCount, stride);
}

void vkCmdDrawIndexedIndirect(PFN_vkCmdDrawIndexedIndirect fn,
                              VkCommandBuffer              commandBuffer,
                              VkBuffer                     buffer,
                              VkDeviceSize                 offset,
                              uint32_t                     drawCount,
                              uint32_t                     stride)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDrawIndexedIndirect(commandBuffer,
                                                      buffer,
                                                      offset,
                                                      drawCount,
                                                      stride);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndexedIndirectArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndexedIndirectCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndexedIndirectCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, drawCount, stride);
}

void vkCmdDispatch(PFN_vkCmdDispatch fn,
                   VkCommandBuffer   commandBuffer,
                   uint32_t          groupCountX,
                   uint32_t          groupCountY,
                   uint32_t          groupCountZ)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDispatchArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDispatchCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDispatchCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, groupCountX, groupCountY, groupCountZ);
}

void vkCmdDispatchIndirect(PFN_vkCmdDispatchIndirect fn,
                           VkCommandBuffer           commandBuffer,
                           VkBuffer                  buffer,
                           VkDeviceSize              offset)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDispatchIndirect(commandBuffer, buffer, offset);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDispatchIndirectArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDispatchIndirectCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDispatchIndirectCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset);
}

void vkCmdBindPipeline(PFN_vkCmdBindPipeline fn,
                       VkCommandBuffer       commandBuffer,
                       VkPipelineBindPoint   pipelineBindPoint,
                       VkPipeline            pipeline)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBindPipelineArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBindPipelineCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBindPipelineCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, pipelineBindPoint, pipeline);
}

void vkCmdSetViewport(PFN_vkCmdSetViewport fn,
                      VkCommandBuffer      commandBuffer,
                      uint32_t             firstViewport,
                      uint32_t             viewportCount,
                      VkViewport const*    pViewports)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetViewport(commandBuffer,
                                              firstViewport,
                                              viewportCount,
                                              pViewports);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetViewportArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetViewportCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetViewportCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, firstViewport, viewportCount, pViewports);
}

void vkCmdSetScissor(PFN_vkCmdSetScissor fn,
                     VkCommandBuffer     commandBuffer,
                     uint32_t            firstScissor,
                     uint32_t            scissorCount,
                     VkRect2D const*     pScissors)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetScissorArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetScissorCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetScissorCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, firstScissor, scissorCount, pScissors);
}

void vkCmdSetLineWidth(PFN_vkCmdSetLineWidth fn, VkCommandBuffer commandBuffer, float lineWidth)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetLineWidth(commandBuffer, lineWidth);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetLineWidthArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetLineWidthCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetLineWidthCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, lineWidth);
}

void vkCmdSetDepthBias(PFN_vkCmdSetDepthBias fn,
                       VkCommandBuffer       commandBuffer,
                       float                 depthBiasConstantFactor,
                       float                 depthBiasClamp,
                       float                 depthBiasSlopeFactor)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetDepthBias(commandBuffer,
                                               depthBiasConstantFactor,
                                               depthBiasClamp,
                                               depthBiasSlopeFactor);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetDepthBiasArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetDepthBiasCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetDepthBiasCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}

void vkCmdSetBlendConstants(PFN_vkCmdSetBlendConstants fn,
                            VkCommandBuffer            commandBuffer,
                            float                      blendConstants[4])
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetBlendConstants(commandBuffer, blendConstants);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetBlendConstantsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetBlendConstantsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetBlendConstantsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, blendConstants);
}

void vkCmdSetDepthBounds(PFN_vkCmdSetDepthBounds fn,
                         VkCommandBuffer         commandBuffer,
                         float                   minDepthBounds,
                         float                   maxDepthBounds)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetDepthBoundsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetDepthBoundsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetDepthBoundsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, minDepthBounds, maxDepthBounds);
}

void vkCmdSetStencilCompareMask(PFN_vkCmdSetStencilCompareMask fn,
                                VkCommandBuffer                commandBuffer,
                                VkStencilFaceFlags             faceMask,
                                uint32_t                       compareMask)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetStencilCompareMaskArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetStencilCompareMaskCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetStencilCompareMaskCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, faceMask, compareMask);
}

void vkCmdSetStencilWriteMask(PFN_vkCmdSetStencilWriteMask fn,
                              VkCommandBuffer              commandBuffer,
                              VkStencilFaceFlags           faceMask,
                              uint32_t                     writeMask)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetStencilWriteMaskArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetStencilWriteMaskCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetStencilWriteMaskCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, faceMask, writeMask);
}

void vkCmdSetStencilReference(PFN_vkCmdSetStencilReference fn,
                              VkCommandBuffer              commandBuffer,
                              VkStencilFaceFlags           faceMask,
                              uint32_t                     reference)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdSetStencilReference(commandBuffer, faceMask, reference);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetStencilReferenceArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetStencilReferenceCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetStencilReferenceCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, faceMask, reference);
}

void vkCmdBeginQuery(PFN_vkCmdBeginQuery fn,
                     VkCommandBuffer     commandBuffer,
                     VkQueryPool         queryPool,
                     uint32_t            query,
                     VkQueryControlFlags flags)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdBeginQuery(commandBuffer, queryPool, query, flags);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBeginQueryArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBeginQueryCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBeginQueryCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, queryPool, query, flags);
}

void vkCmdEndQuery(PFN_vkCmdEndQuery fn,
                   VkCommandBuffer   commandBuffer,
                   VkQueryPool       queryPool,
                   uint32_t          query)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdEndQuery(commandBuffer, queryPool, query);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdEndQueryArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdEndQueryCmdID);
    insertCmdMarkers(VKCmdID::vkCmdEndQueryCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, queryPool, query);
}

void vkCmdResetQueryPool(PFN_vkCmdResetQueryPool fn,
                         VkCommandBuffer         commandBuffer,
                         VkQueryPool             queryPool,
                         uint32_t                firstQuery,
                         uint32_t                queryCount)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdResetQueryPoolArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdResetQueryPoolCmdID);
    insertCmdMarkers(VKCmdID::vkCmdResetQueryPoolCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, queryPool, firstQuery, queryCount);
}

void vkCmdWriteTimestamp(PFN_vkCmdWriteTimestamp fn,
                         VkCommandBuffer         commandBuffer,
                         VkPipelineStageFlagBits pipelineStage,
                         VkQueryPool             queryPool,
                         uint32_t                query)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdWriteTimestampArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdWriteTimestampCmdID);
    insertCmdMarkers(VKCmdID::vkCmdWriteTimestampCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, pipelineStage, queryPool, query);
}

void vkCmdCopyQueryPoolResults(PFN_vkCmdCopyQueryPoolResults fn,
                               VkCommandBuffer               commandBuffer,
                               VkQueryPool                   queryPool,
                               uint32_t                      firstQuery,
                               uint32_t                      queryCount,
                               VkBuffer                      dstBuffer,
                               VkDeviceSize                  dstOffset,
                               VkDeviceSize                  stride,
                               VkQueryResultFlags            flags)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdCopyQueryPoolResults(commandBuffer,
                                                       queryPool,
                                                       firstQuery,
                                                       queryCount,
                                                       dstBuffer,
                                                       dstOffset,
                                                       stride,
                                                       flags);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdCopyQueryPoolResultsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdCopyQueryPoolResultsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdCopyQueryPoolResultsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}

void vkCmdBeginRenderPass(PFN_vkCmdBeginRenderPass     fn,
                          VkCommandBuffer              commandBuffer,
                          VkRenderPassBeginInfo const* pRenderPassBegin,
                          VkSubpassContents            contents)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto args = recorder.RecordCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBeginRenderPassArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBeginRenderPassCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBeginRenderPassCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, pRenderPassBegin, contents);
}

void vkCmdNextSubpass(PFN_vkCmdNextSubpass fn,
                      VkCommandBuffer      commandBuffer,
                      VkSubpassContents    contents)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdNextSubpass(commandBuffer, contents);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdNextSubpassArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdNextSubpassCmdID);
    insertCmdMarkers(VKCmdID::vkCmdNextSubpassCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, contents);
}

void vkCmdEndRenderPass(PFN_vkCmdEndRenderPass fn, VkCommandBuffer commandBuffer)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdEndRenderPass(commandBuffer);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdEndRenderPassArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdEndRenderPassCmdID);
    insertCmdMarkers(VKCmdID::vkCmdEndRenderPassCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer);
}

void vkCmdSetEvent(PFN_vkCmdSetEvent    fn,
                   VkCommandBuffer      commandBuffer,
                   VkEvent              event,
                   VkPipelineStageFlags stageMask)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetEvent(commandBuffer, event, stageMask);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetEventArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetEventCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetEventCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, event, stageMask);
}

void vkCmdResetEvent(PFN_vkCmdResetEvent  fn,
                     VkCommandBuffer      commandBuffer,
                     VkEvent              event,
                     VkPipelineStageFlags stageMask)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdResetEvent(commandBuffer, event, stageMask);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdResetEventArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdResetEventCmdID);
    insertCmdMarkers(VKCmdID::vkCmdResetEventCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, event, stageMask);
}

void vkCmdWaitEvents(PFN_vkCmdWaitEvents          fn,
                     VkCommandBuffer              commandBuffer,
                     uint32_t                     eventCount,
                     VkEvent const*               pEvents,
                     VkPipelineStageFlags         srcStageMask,
                     VkPipelineStageFlags         dstStageMask,
                     uint32_t                     memoryBarrierCount,
                     VkMemoryBarrier const*       pMemoryBarriers,
                     uint32_t                     bufferMemoryBarrierCount,
                     VkBufferMemoryBarrier const* pBufferMemoryBarriers,
                     uint32_t                     imageMemoryBarrierCount,
                     VkImageMemoryBarrier const*  pImageMemoryBarriers)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdWaitEvents(commandBuffer,
                                             eventCount,
                                             pEvents,
                                             srcStageMask,
                                             dstStageMask,
                                             memoryBarrierCount,
                                             pMemoryBarriers,
                                             bufferMemoryBarrierCount,
                                             pBufferMemoryBarriers,
                                             imageMemoryBarrierCount,
                                             pImageMemoryBarriers);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdWaitEventsArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdWaitEventsCmdID);
    insertCmdMarkers(VKCmdID::vkCmdWaitEventsCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer,
       eventCount,
       pEvents,
       srcStageMask,
       dstStageMask,
       memoryBarrierCount,
       pMemoryBarriers,
       bufferMemoryBarrierCount,
       pBufferMemoryBarriers,
       imageMemoryBarrierCount,
       pImageMemoryBarriers);
}

void vkCmdPipelineBarrier(PFN_vkCmdPipelineBarrier     fn,
                          VkCommandBuffer              commandBuffer,
                          VkPipelineStageFlags         srcStageMask,
                          VkPipelineStageFlags         dstStageMask,
                          VkDependencyFlags            dependencyFlags,
                          uint32_t                     memoryBarrierCount,
                          VkMemoryBarrier const*       pMemoryBarriers,
                          uint32_t                     bufferMemoryBarrierCount,
                          VkBufferMemoryBarrier const* pBufferMemoryBarriers,
                          uint32_t                     imageMemoryBarrierCount,
                          VkImageMemoryBarrier const*  pImageMemoryBarriers)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    recorder.SetEnableCopyArray(true);
    auto args = recorder.RecordCmdPipelineBarrier(commandBuffer,
                                                  srcStageMask,
                                                  dstStageMask,
                                                  dependencyFlags,
                                                  memoryBarrierCount,
                                                  pMemoryBarriers,
                                                  bufferMemoryBarrierCount,
                                                  pBufferMemoryBarriers,
                                                  imageMemoryBarrierCount,
                                                  pImageMemoryBarriers);
    assert(recorder.EncodedSize() >= sizeof(args));
    recorder.SetEnableCopyArray(false);
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdPipelineBarrierArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdPipelineBarrierCmdID);
    insertCmdMarkers(VKCmdID::vkCmdPipelineBarrierCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer,
       srcStageMask,
       dstStageMask,
       dependencyFlags,
       memoryBarrierCount,
       pMemoryBarriers,
       bufferMemoryBarrierCount,
       pBufferMemoryBarriers,
       imageMemoryBarrierCount,
       pImageMemoryBarriers);
}

// Extension: VK_AMD_buffer_marker
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdWriteBufferMarkerAMD(PFN_vkCmdWriteBufferMarkerAMD fn,
                               VkCommandBuffer               commandBuffer,
                               VkPipelineStageFlagBits       pipelineStage,
                               VkBuffer                      dstBuffer,
                               VkDeviceSize                  dstOffset,
                               uint32_t                      marker)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdWriteBufferMarkerAMD(commandBuffer,
                                                       pipelineStage,
                                                       dstBuffer,
                                                       dstOffset,
                                                       marker);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdWriteBufferMarkerAMDArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdWriteBufferMarkerAMDCmdID);
    insertCmdMarkers(VKCmdID::vkCmdWriteBufferMarkerAMDCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
    }
}

void vkCmdDrawIndirectCountAMD(PFN_vkCmdDrawIndirectCountAMD fn,
                               VkCommandBuffer               commandBuffer,
                               VkBuffer                      buffer,
                               VkDeviceSize                  offset,
                               VkBuffer                      countBuffer,
                               VkDeviceSize                  countOffset,
                               uint32_t                      maxDrawCount,
                               uint32_t                      stride)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDrawIndirectCountAMD(commandBuffer,
                                                       buffer,
                                                       offset,
                                                       countBuffer,
                                                       countOffset,
                                                       maxDrawCount,
                                                       stride);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndirectCountAMDArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndirectCountAMDCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndirectCountAMDCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
}

void vkCmdDrawIndexedIndirectCountAMD(PFN_vkCmdDrawIndexedIndirectCountAMD fn,
                                      VkCommandBuffer                      commandBuffer,
                                      VkBuffer                             buffer,
                                      VkDeviceSize                         offset,
                                      VkBuffer                             countBuffer,
                                      VkDeviceSize                         countOffset,
                                      uint32_t                             maxDrawCount,
                                      uint32_t                             stride)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDrawIndexedIndirectCountAMD(commandBuffer,
                                                              buffer,
                                                              offset,
                                                              countBuffer,
                                                              countOffset,
                                                              maxDrawCount,
                                                              stride);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndexedIndirectCountAMDArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndexedIndirectCountAMDCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndexedIndirectCountAMDCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
}

// Extension: VK_EXT_conditional_rendering
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdBeginConditionalRenderingEXT(
PFN_vkCmdBeginConditionalRenderingEXT     fn,
VkCommandBuffer                           commandBuffer,
VkConditionalRenderingBeginInfoEXT const* pConditinalRenderingBegin)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdBeginConditionalRenderingEXT(commandBuffer,
                                                               pConditinalRenderingBegin);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBeginConditionalRenderingEXTArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBeginConditionalRenderingEXTCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBeginConditionalRenderingEXTCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer, pConditinalRenderingBegin);
    }
}

// Extension: VK_EXT_conditional_rendering
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdEndConditionalRenderingEXT(PFN_vkCmdEndConditionalRenderingEXT fn,
                                     VkCommandBuffer                     commandBuffer)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdEndConditionalRenderingEXT(commandBuffer);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdEndConditionalRenderingEXTArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdEndConditionalRenderingEXTCmdID);
    insertCmdMarkers(VKCmdID::vkCmdEndConditionalRenderingEXTCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer);
    }
}

// Extension: VK_EXT_debug_utils
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdBeginDebugUtilsLabelEXT(PFN_vkCmdBeginDebugUtilsLabelEXT fn,
                                  VkCommandBuffer                  commandBuffer,
                                  VkDebugUtilsLabelEXT const*      pLabelInfo)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdBeginDebugUtilsLabelEXTArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdBeginDebugUtilsLabelEXTCmdID);
    insertCmdMarkers(VKCmdID::vkCmdBeginDebugUtilsLabelEXTCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer, pLabelInfo);
    }
}

// Extension: VK_EXT_debug_utils
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdEndDebugUtilsLabelEXT(PFN_vkCmdEndDebugUtilsLabelEXT fn, VkCommandBuffer commandBuffer)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdEndDebugUtilsLabelEXT(commandBuffer);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdEndDebugUtilsLabelEXTArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdEndDebugUtilsLabelEXTCmdID);
    insertCmdMarkers(VKCmdID::vkCmdEndDebugUtilsLabelEXTCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer);
    }
}

// Extension: VK_EXT_debug_utils
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdInsertDebugUtilsLabelEXT(PFN_vkCmdInsertDebugUtilsLabelEXT fn,
                                   VkCommandBuffer                   commandBuffer,
                                   VkDebugUtilsLabelEXT const*       pLabelInfo)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdInsertDebugUtilsLabelEXTArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdInsertDebugUtilsLabelEXTCmdID);
    insertCmdMarkers(VKCmdID::vkCmdInsertDebugUtilsLabelEXTCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer, pLabelInfo);
    }
}

// Extension: VK_KHR_device_group
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdSetDeviceMaskKHR(PFN_vkCmdSetDeviceMaskKHR fn,
                           VkCommandBuffer           commandBuffer,
                           uint32_t                  deviceMask)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetDeviceMaskKHRArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetDeviceMaskKHRCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetDeviceMaskKHRCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer, deviceMask);
    }
}

void vkCmdSetDeviceMask(PFN_vkCmdSetDeviceMask fn,
                        VkCommandBuffer        commandBuffer,
                        uint32_t               deviceMask)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdSetDeviceMask(commandBuffer, deviceMask);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdSetDeviceMaskArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdSetDeviceMaskCmdID);
    insertCmdMarkers(VKCmdID::vkCmdSetDeviceMaskCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, deviceMask);
}

// Extension: VK_KHR_device_group
// The validation layer will return nullptr in GetDeviceProcAddr for the extensions that defined as
// kNotEnabled (checked with ApiParentExtensionEnabled), so need to check the function pointer is
// nullptr or not.
void vkCmdDispatchBaseKHR(PFN_vkCmdDispatchBaseKHR fn,
                          VkCommandBuffer          commandBuffer,
                          uint32_t                 baseGroupX,
                          uint32_t                 baseGroupY,
                          uint32_t                 baseGroupZ,
                          uint32_t                 groupCountX,
                          uint32_t                 groupCountY,
                          uint32_t                 groupCountZ)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDispatchBaseKHR(commandBuffer,
                                                  baseGroupX,
                                                  baseGroupY,
                                                  baseGroupZ,
                                                  groupCountX,
                                                  groupCountY,
                                                  groupCountZ);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDispatchBaseKHRArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDispatchBaseKHRCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDispatchBaseKHRCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    if (fn)
    {
        fn(commandBuffer,
           baseGroupX,
           baseGroupY,
           baseGroupZ,
           groupCountX,
           groupCountY,
           groupCountZ);
    }
}

void vkCmdDispatchBase(PFN_vkCmdDispatchBase fn,
                       VkCommandBuffer       commandBuffer,
                       uint32_t              baseGroupX,
                       uint32_t              baseGroupY,
                       uint32_t              baseGroupZ,
                       uint32_t              groupCountX,
                       uint32_t              groupCountY,
                       uint32_t              groupCountZ)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDispatchBase(commandBuffer,
                                               baseGroupX,
                                               baseGroupY,
                                               baseGroupZ,
                                               groupCountX,
                                               groupCountY,
                                               groupCountZ);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDispatchBaseArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDispatchBaseCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDispatchBaseCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}

void vkCmdDrawIndirectCountKHR(PFN_vkCmdDrawIndirectCountKHR fn,
                               VkCommandBuffer               commandBuffer,
                               VkBuffer                      buffer,
                               VkDeviceSize                  offset,
                               VkBuffer                      countBuffer,
                               VkDeviceSize                  countOffset,
                               uint32_t                      maxDrawCount,
                               uint32_t                      stride)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDrawIndirectCountKHR(commandBuffer,
                                                       buffer,
                                                       offset,
                                                       countBuffer,
                                                       countOffset,
                                                       maxDrawCount,
                                                       stride);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndirectCountKHRArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndirectCountKHRCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndirectCountKHRCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
}

void vkCmdDrawIndexedIndirectCountKHR(PFN_vkCmdDrawIndexedIndirectCountKHR fn,
                                      VkCommandBuffer                      commandBuffer,
                                      VkBuffer                             buffer,
                                      VkDeviceSize                         offset,
                                      VkBuffer                             countBuffer,
                                      VkDeviceSize                         countOffset,
                                      uint32_t                             maxDrawCount,
                                      uint32_t                             stride)
{
    std::array<char, kMaxPayloadLen> mem{};
    LinearAllocator<>                allocator(mem.data(), kMaxPayloadLen);
    allocator.Alloc(sizeof(NopVulkanCallHeader));
    CommandRecorder recorder(&allocator);
    auto            args = recorder.RecordCmdDrawIndexedIndirectCountKHR(commandBuffer,
                                                              buffer,
                                                              offset,
                                                              countBuffer,
                                                              countOffset,
                                                              maxDrawCount,
                                                              stride);
    assert(recorder.EncodedSize() >= sizeof(args));
    if (kEnableCaptureDebugPrint)
    {
        PrintCmdDrawIndexedIndirectCountKHRArgs(std::cout, *args);
    }
    NopVulkanCallHeader* header = reinterpret_cast<NopVulkanCallHeader*>(
    reinterpret_cast<char*>(args) - sizeof(NopVulkanCallHeader));
    header->signature = kNopPayloadSignature;
    header->cmdID = static_cast<uint8_t>(VKCmdID::vkCmdDrawIndexedIndirectCountKHRCmdID);
    insertCmdMarkers(VKCmdID::vkCmdDrawIndexedIndirectCountKHRCmdID,
                     commandBuffer,
                     static_cast<void*>(header),
                     recorder.EncodedSize() + sizeof(NopVulkanCallHeader));
    fn(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
}

}  // namespace Dive