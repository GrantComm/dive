/*
 * Copyright (C) 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

#include "command_arguments.h"
namespace Dive
{
template<>
inline size_t GetArraySize(const VkBufferCreateInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkBufferCreateInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].pQueueFamilyIndices)
        {
            total_size += GetArraySize(src[start_index + i].pQueueFamilyIndices,
                                       0,
                                       1);  // ptr uint32_t // TODO (b/184758440): do we know count?
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkBufferViewCreateInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkBufferViewCreateInfo) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkCommandBufferBeginInfo* src,
                           uint64_t                        start_index,
                           uint64_t                        count)
{
    size_t total_size = AlignUp(sizeof(VkCommandBufferBeginInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].pInheritanceInfo)
        {
            total_size += GetArraySize(src[start_index + i].pInheritanceInfo,
                                       0,
                                       1);  // ptr VkCommandBufferInheritanceInfo // TODO
                                            // (b/184758440): do we know count?
        }
    }
    return total_size;
}

template<> inline size_t GetArraySize(const VkBufferCopy* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkBufferCopy) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkImageCopy* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageCopy) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkImageBlit* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageBlit) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkBufferImageCopy* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkBufferImageCopy) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkClearColorValue* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkClearColorValue) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkImageSubresourceRange* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageSubresourceRange) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkClearDepthStencilValue* src,
                           uint64_t                        start_index,
                           uint64_t                        count)
{
    size_t total_size = AlignUp(sizeof(VkClearDepthStencilValue) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkClearAttachment* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkClearAttachment) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkClearRect* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkClearRect) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkImageResolve* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageResolve) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDescriptorSetLayoutCreateInfo* src,
                           uint64_t                               start_index,
                           uint64_t                               count)
{
    size_t total_size = AlignUp(sizeof(VkDescriptorSetLayoutCreateInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].bindingCount > 0 && src[start_index + i].pBindings)
        {
            total_size += GetArraySize(src[start_index + i].pBindings,
                                       0,
                                       src[start_index + i].bindingCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDescriptorSetAllocateInfo* src,
                           uint64_t                           start_index,
                           uint64_t                           count)
{
    size_t total_size = AlignUp(sizeof(VkDescriptorSetAllocateInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].descriptorSetCount > 0 && src[start_index + i].pSetLayouts)
        {
            total_size += GetArraySize(src[start_index + i].pSetLayouts,
                                       0,
                                       src[start_index + i].descriptorSetCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkWriteDescriptorSet* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkWriteDescriptorSet) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pImageInfo)
        {
            total_size += GetArraySize(src[start_index + i].pImageInfo,
                                       0,
                                       src[start_index + i].descriptorCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pBufferInfo)
        {
            total_size += GetArraySize(src[start_index + i].pBufferInfo,
                                       0,
                                       src[start_index + i].descriptorCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pTexelBufferView)
        {
            total_size += GetArraySize(src[start_index + i].pTexelBufferView,
                                       0,
                                       src[start_index + i].descriptorCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkCopyDescriptorSet* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkCopyDescriptorSet) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkImageCreateInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageCreateInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].pQueueFamilyIndices)
        {
            total_size += GetArraySize(src[start_index + i].pQueueFamilyIndices,
                                       0,
                                       1);  // ptr uint32_t // TODO (b/184758440): do we know count?
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkImageViewCreateInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageViewCreateInfo) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkViewport* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkViewport) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkRect2D* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkRect2D) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkSubmitInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkSubmitInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].waitSemaphoreCount > 0 && src[start_index + i].pWaitSemaphores)
        {
            total_size += GetArraySize(src[start_index + i].pWaitSemaphores,
                                       0,
                                       src[start_index + i].waitSemaphoreCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].waitSemaphoreCount > 0 && src[start_index + i].pWaitDstStageMask)
        {
            total_size += GetArraySize(src[start_index + i].pWaitDstStageMask,
                                       0,
                                       src[start_index + i].waitSemaphoreCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].commandBufferCount > 0 && src[start_index + i].pCommandBuffers)
        {
            total_size += GetArraySize(src[start_index + i].pCommandBuffers,
                                       0,
                                       src[start_index + i].commandBufferCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].signalSemaphoreCount > 0 && src[start_index + i].pSignalSemaphores)
        {
            total_size += GetArraySize(src[start_index + i].pSignalSemaphores,
                                       0,
                                       src[start_index + i].signalSemaphoreCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkFramebufferCreateInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkFramebufferCreateInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].attachmentCount > 0 && src[start_index + i].pAttachments)
        {
            total_size += GetArraySize(src[start_index + i].pAttachments,
                                       0,
                                       src[start_index + i].attachmentCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkRenderPassCreateInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkRenderPassCreateInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].attachmentCount > 0 && src[start_index + i].pAttachments)
        {
            total_size += GetArraySize(src[start_index + i].pAttachments,
                                       0,
                                       src[start_index + i].attachmentCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].subpassCount > 0 && src[start_index + i].pSubpasses)
        {
            total_size += GetArraySize(src[start_index + i].pSubpasses,
                                       0,
                                       src[start_index + i].subpassCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].dependencyCount > 0 && src[start_index + i].pDependencies)
        {
            total_size += GetArraySize(src[start_index + i].pDependencies,
                                       0,
                                       src[start_index + i].dependencyCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkRenderPassBeginInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkRenderPassBeginInfo) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if ((src[start_index + i].clearValueCount > 0) && (src[start_index + i].pClearValues))
        {
            total_size += GetArraySize(src[start_index + i].pClearValues,
                                       0,
                                       src[start_index + i].clearValueCount);  // ptr VkClearValue
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkMemoryBarrier* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkMemoryBarrier) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkBufferMemoryBarrier* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkBufferMemoryBarrier) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkImageMemoryBarrier* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkImageMemoryBarrier) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkConditionalRenderingBeginInfoEXT* src,
                           uint64_t                                  start_index,
                           uint64_t                                  count)
{
    size_t total_size = AlignUp(sizeof(VkConditionalRenderingBeginInfoEXT) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDebugMarkerMarkerInfoEXT* src,
                           uint64_t                          start_index,
                           uint64_t                          count)
{
    size_t total_size = AlignUp(sizeof(VkDebugMarkerMarkerInfoEXT) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].pMarkerName)
        {
            total_size += GetArraySize(src[start_index + i].pMarkerName,
                                       0,
                                       strlen(src[start_index + i].pMarkerName +
                                              1));  // copy tailing '\0' of the string as well
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDebugUtilsLabelEXT* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkDebugUtilsLabelEXT) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].pLabelName)
        {
            total_size += GetArraySize(src[start_index + i].pLabelName,
                                       0,
                                       strlen(src[start_index + i].pLabelName +
                                              1));  // copy tailing '\0' of the string as well
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkCommandBufferInheritanceInfo* src,
                           uint64_t                              start_index,
                           uint64_t                              count)
{
    size_t total_size = AlignUp(sizeof(VkCommandBufferInheritanceInfo) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkImageSubresourceLayers* src,
                           uint64_t                        start_index,
                           uint64_t                        count)
{
    size_t total_size = AlignUp(sizeof(VkImageSubresourceLayers) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkOffset3D* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkOffset3D) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkExtent3D* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkExtent3D) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkClearValue* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkClearValue) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDescriptorSetLayoutBinding* src,
                           uint64_t                            start_index,
                           uint64_t                            count)
{
    size_t total_size = AlignUp(sizeof(VkDescriptorSetLayoutBinding) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].descriptorCount > 0 && src[start_index + i].pImmutableSamplers)
        {
            total_size += GetArraySize(src[start_index + i].pImmutableSamplers,
                                       0,
                                       src[start_index + i].descriptorCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDescriptorImageInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkDescriptorImageInfo) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkDescriptorBufferInfo* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkDescriptorBufferInfo) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkComponentMapping* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkComponentMapping) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkOffset2D* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkOffset2D) * count);
    return total_size;
}

template<> inline size_t GetArraySize(const VkExtent2D* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkExtent2D) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkAttachmentDescription* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkAttachmentDescription) * count);
    return total_size;
}

template<>
inline size_t GetArraySize(const VkSubpassDescription* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkSubpassDescription) * count);
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].inputAttachmentCount > 0 && src[start_index + i].pInputAttachments)
        {
            total_size += GetArraySize(src[start_index + i].pInputAttachments,
                                       0,
                                       src[start_index + i].inputAttachmentCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].colorAttachmentCount > 0 && src[start_index + i].pColorAttachments)
        {
            total_size += GetArraySize(src[start_index + i].pColorAttachments,
                                       0,
                                       src[start_index + i].colorAttachmentCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].colorAttachmentCount > 0 &&
            src[start_index + i].pResolveAttachments)
        {
            total_size += GetArraySize(src[start_index + i].pResolveAttachments,
                                       0,
                                       src[start_index + i].colorAttachmentCount);
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].pDepthStencilAttachment)
        {
            total_size += GetArraySize(src[start_index + i].pDepthStencilAttachment,
                                       0,
                                       1);  // ptr VkAttachmentReference // TODO (b/184758440): do
                                            // we know count?
        }
    }
    for (uint64_t i = 0; i < count; ++i)
    {
        if (src[start_index + i].preserveAttachmentCount > 0 &&
            src[start_index + i].pPreserveAttachments)
        {
            total_size += GetArraySize(src[start_index + i].pPreserveAttachments,
                                       0,
                                       src[start_index + i].preserveAttachmentCount);
        }
    }
    return total_size;
}

template<>
inline size_t GetArraySize(const VkSubpassDependency* src, uint64_t start_index, uint64_t count)
{
    size_t total_size = AlignUp(sizeof(VkSubpassDependency) * count);
    return total_size;
}

size_t GetCreateBufferArgsSize(VkDevice                  device,
                               VkBufferCreateInfo const* pCreateInfo,
                               AllocationCallbacks       pAllocator,
                               VkBuffer*                 pBuffer)
{
    size_t total_size = AlignUp(sizeof(CreateBufferArgs));
    total_size += AlignUp(sizeof(VkBuffer));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCreateBufferViewArgsSize(VkDevice                      device,
                                   VkBufferViewCreateInfo const* pCreateInfo,
                                   AllocationCallbacks           pAllocator,
                                   VkBufferView*                 pView)
{
    size_t total_size = AlignUp(sizeof(CreateBufferViewArgs));
    total_size += AlignUp(sizeof(VkBufferView));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetBeginCommandBufferArgsSize(VkCommandBuffer                 commandBuffer,
                                     VkCommandBufferBeginInfo const* pBeginInfo)
{
    size_t total_size = AlignUp(sizeof(BeginCommandBufferArgs));
    if (pBeginInfo)
    {
        total_size += GetArraySize(pBeginInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetEndCommandBufferArgsSize(VkCommandBuffer commandBuffer)
{
    size_t total_size = AlignUp(sizeof(EndCommandBufferArgs));
    return total_size;
}

size_t GetResetCommandBufferArgsSize(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
{
    size_t total_size = AlignUp(sizeof(ResetCommandBufferArgs));
    return total_size;
}

size_t GetCmdExecuteCommandsArgsSize(VkCommandBuffer        commandBuffer,
                                     uint32_t               commandBufferCount,
                                     VkCommandBuffer const* pCommandBuffers)
{
    size_t total_size = AlignUp(sizeof(CmdExecuteCommandsArgs));
    if (pCommandBuffers)
    {
        total_size += GetArraySize(pCommandBuffers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(commandBufferCount));
    }
    return total_size;
}

size_t GetCmdCopyBufferArgsSize(VkCommandBuffer     commandBuffer,
                                VkBuffer            srcBuffer,
                                VkBuffer            dstBuffer,
                                uint32_t            regionCount,
                                VkBufferCopy const* pRegions)
{
    size_t total_size = AlignUp(sizeof(CmdCopyBufferArgs));
    if (pRegions)
    {
        total_size += GetArraySize(pRegions,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(regionCount));
    }
    return total_size;
}

size_t GetCmdCopyImageArgsSize(VkCommandBuffer    commandBuffer,
                               VkImage            srcImage,
                               uint32_t           srcImageLayout,
                               VkImage            dstImage,
                               uint32_t           dstImageLayout,
                               uint32_t           regionCount,
                               VkImageCopy const* pRegions)
{
    size_t total_size = AlignUp(sizeof(CmdCopyImageArgs));
    if (pRegions)
    {
        total_size += GetArraySize(pRegions,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(regionCount));
    }
    return total_size;
}

size_t GetCmdBlitImageArgsSize(VkCommandBuffer    commandBuffer,
                               VkImage            srcImage,
                               uint32_t           srcImageLayout,
                               VkImage            dstImage,
                               uint32_t           dstImageLayout,
                               uint32_t           regionCount,
                               VkImageBlit const* pRegions,
                               uint32_t           filter)
{
    size_t total_size = AlignUp(sizeof(CmdBlitImageArgs));
    if (pRegions)
    {
        total_size += GetArraySize(pRegions,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(regionCount));
    }
    return total_size;
}

size_t GetCmdCopyBufferToImageArgsSize(VkCommandBuffer          commandBuffer,
                                       VkBuffer                 srcBuffer,
                                       VkImage                  dstImage,
                                       uint32_t                 dstImageLayout,
                                       uint32_t                 regionCount,
                                       VkBufferImageCopy const* pRegions)
{
    size_t total_size = AlignUp(sizeof(CmdCopyBufferToImageArgs));
    if (pRegions)
    {
        total_size += GetArraySize(pRegions,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(regionCount));
    }
    return total_size;
}

size_t GetCmdCopyImageToBufferArgsSize(VkCommandBuffer          commandBuffer,
                                       VkImage                  srcImage,
                                       uint32_t                 srcImageLayout,
                                       VkBuffer                 dstBuffer,
                                       uint32_t                 regionCount,
                                       VkBufferImageCopy const* pRegions)
{
    size_t total_size = AlignUp(sizeof(CmdCopyImageToBufferArgs));
    if (pRegions)
    {
        total_size += GetArraySize(pRegions,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(regionCount));
    }
    return total_size;
}

size_t GetCmdUpdateBufferArgsSize(VkCommandBuffer commandBuffer,
                                  VkBuffer        dstBuffer,
                                  VkDeviceSize    dstOffset,
                                  VkDeviceSize    dataSize,
                                  void const*     pData)
{
    size_t total_size = AlignUp(sizeof(CmdUpdateBufferArgs));
    return total_size;
}

size_t GetCmdFillBufferArgsSize(VkCommandBuffer commandBuffer,
                                VkBuffer        dstBuffer,
                                VkDeviceSize    dstOffset,
                                VkDeviceSize    size,
                                uint32_t        data)
{
    size_t total_size = AlignUp(sizeof(CmdFillBufferArgs));
    return total_size;
}

size_t GetCmdClearColorImageArgsSize(VkCommandBuffer                commandBuffer,
                                     VkImage                        image,
                                     uint32_t                       imageLayout,
                                     VkClearColorValue const*       pColor,
                                     uint32_t                       rangeCount,
                                     VkImageSubresourceRange const* pRanges)
{
    size_t total_size = AlignUp(sizeof(CmdClearColorImageArgs));
    if (pColor)
    {
        total_size += GetArraySize(pColor, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pRanges)
    {
        total_size += GetArraySize(pRanges,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(rangeCount));
    }
    return total_size;
}

size_t GetCmdClearDepthStencilImageArgsSize(VkCommandBuffer                 commandBuffer,
                                            VkImage                         image,
                                            uint32_t                        imageLayout,
                                            VkClearDepthStencilValue const* pDepthStencil,
                                            uint32_t                        rangeCount,
                                            VkImageSubresourceRange const*  pRanges)
{
    size_t total_size = AlignUp(sizeof(CmdClearDepthStencilImageArgs));
    if (pDepthStencil)
    {
        total_size += GetArraySize(pDepthStencil,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    if (pRanges)
    {
        total_size += GetArraySize(pRanges,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(rangeCount));
    }
    return total_size;
}

size_t GetCmdClearAttachmentsArgsSize(VkCommandBuffer          commandBuffer,
                                      uint32_t                 attachmentCount,
                                      VkClearAttachment const* pAttachments,
                                      uint32_t                 rectCount,
                                      VkClearRect const*       pRects)
{
    size_t total_size = AlignUp(sizeof(CmdClearAttachmentsArgs));
    if (pAttachments)
    {
        total_size += GetArraySize(pAttachments,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(attachmentCount));
    }
    if (pRects)
    {
        total_size += GetArraySize(pRects,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(rectCount));
    }
    return total_size;
}

size_t GetCmdResolveImageArgsSize(VkCommandBuffer       commandBuffer,
                                  VkImage               srcImage,
                                  uint32_t              srcImageLayout,
                                  VkImage               dstImage,
                                  uint32_t              dstImageLayout,
                                  uint32_t              regionCount,
                                  VkImageResolve const* pRegions)
{
    size_t total_size = AlignUp(sizeof(CmdResolveImageArgs));
    if (pRegions)
    {
        total_size += GetArraySize(pRegions,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(regionCount));
    }
    return total_size;
}

size_t GetCreateDescriptorSetLayoutArgsSize(VkDevice                               device,
                                            VkDescriptorSetLayoutCreateInfo const* pCreateInfo,
                                            AllocationCallbacks                    pAllocator,
                                            VkDescriptorSetLayout*                 pSetLayout)
{
    size_t total_size = AlignUp(sizeof(CreateDescriptorSetLayoutArgs));
    total_size += AlignUp(sizeof(VkDescriptorSetLayout));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetAllocateDescriptorSetsArgsSize(VkDevice                           device,
                                         VkDescriptorSetAllocateInfo const* pAllocateInfo,
                                         VkDescriptorSet*                   pDescriptorSets)
{
    size_t total_size = AlignUp(sizeof(AllocateDescriptorSetsArgs));
    if (pAllocateInfo)
    {
        total_size += GetArraySize(pAllocateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    total_size += GetArraySize(pDescriptorSets, 0, pAllocateInfo->descriptorSetCount);
    return total_size;
}

size_t GetUpdateDescriptorSetsArgsSize(VkDevice                    device,
                                       uint32_t                    descriptorWriteCount,
                                       VkWriteDescriptorSet const* pDescriptorWrites,
                                       uint32_t                    descriptorCopyCount,
                                       VkCopyDescriptorSet const*  pDescriptorCopies)
{
    size_t total_size = AlignUp(sizeof(UpdateDescriptorSetsArgs));
    if (pDescriptorWrites)
    {
        total_size += GetArraySize(pDescriptorWrites,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(descriptorWriteCount));
    }
    if (pDescriptorCopies)
    {
        total_size += GetArraySize(pDescriptorCopies,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(descriptorCopyCount));
    }
    return total_size;
}

size_t GetCmdBindDescriptorSetsArgsSize(VkCommandBuffer        commandBuffer,
                                        uint32_t               pipelineBindPoint,
                                        VkPipelineLayout       layout,
                                        uint32_t               firstSet,
                                        uint32_t               descriptorSetCount,
                                        VkDescriptorSet const* pDescriptorSets,
                                        uint32_t               dynamicOffsetCount,
                                        uint32_t const*        pDynamicOffsets)
{
    size_t total_size = AlignUp(sizeof(CmdBindDescriptorSetsArgs));
    if (pDescriptorSets)
    {
        total_size += GetArraySize(pDescriptorSets,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(descriptorSetCount));
    }
    if (pDynamicOffsets)
    {
        total_size += GetArraySize(pDynamicOffsets,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(dynamicOffsetCount));
    }
    return total_size;
}

size_t GetCmdPushConstantsArgsSize(VkCommandBuffer    commandBuffer,
                                   VkPipelineLayout   layout,
                                   VkShaderStageFlags stageFlags,
                                   uint32_t           offset,
                                   uint32_t           size,
                                   void const*        pValues)
{
    size_t total_size = AlignUp(sizeof(CmdPushConstantsArgs));
    return total_size;
}

size_t GetCmdBindIndexBufferArgsSize(VkCommandBuffer commandBuffer,
                                     VkBuffer        buffer,
                                     VkDeviceSize    offset,
                                     uint32_t        indexType)
{
    size_t total_size = AlignUp(sizeof(CmdBindIndexBufferArgs));
    return total_size;
}

size_t GetCmdBindVertexBuffersArgsSize(VkCommandBuffer     commandBuffer,
                                       uint32_t            firstBinding,
                                       uint32_t            bindingCount,
                                       VkBuffer const*     pBuffers,
                                       VkDeviceSize const* pOffsets)
{
    size_t total_size = AlignUp(sizeof(CmdBindVertexBuffersArgs));
    if (pBuffers)
    {
        total_size += GetArraySize(pBuffers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(bindingCount));
    }
    if (pOffsets)
    {
        total_size += GetArraySize(pOffsets,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(bindingCount));
    }
    return total_size;
}

size_t GetCmdDrawArgsSize(VkCommandBuffer commandBuffer,
                          uint32_t        vertexCount,
                          uint32_t        instanceCount,
                          uint32_t        firstVertex,
                          uint32_t        firstInstance)
{
    size_t total_size = AlignUp(sizeof(CmdDrawArgs));
    return total_size;
}

size_t GetCmdDrawIndexedArgsSize(VkCommandBuffer commandBuffer,
                                 uint32_t        indexCount,
                                 uint32_t        instanceCount,
                                 uint32_t        firstIndex,
                                 int32_t         vertexOffset,
                                 uint32_t        firstInstance)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndexedArgs));
    return total_size;
}

size_t GetCmdDrawIndirectArgsSize(VkCommandBuffer commandBuffer,
                                  VkBuffer        buffer,
                                  VkDeviceSize    offset,
                                  uint32_t        drawCount,
                                  uint32_t        stride)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndirectArgs));
    return total_size;
}

size_t GetCmdDrawIndexedIndirectArgsSize(VkCommandBuffer commandBuffer,
                                         VkBuffer        buffer,
                                         VkDeviceSize    offset,
                                         uint32_t        drawCount,
                                         uint32_t        stride)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndexedIndirectArgs));
    return total_size;
}

size_t GetCmdDispatchArgsSize(VkCommandBuffer commandBuffer,
                              uint32_t        groupCountX,
                              uint32_t        groupCountY,
                              uint32_t        groupCountZ)
{
    size_t total_size = AlignUp(sizeof(CmdDispatchArgs));
    return total_size;
}

size_t GetCmdDispatchIndirectArgsSize(VkCommandBuffer commandBuffer,
                                      VkBuffer        buffer,
                                      VkDeviceSize    offset)
{
    size_t total_size = AlignUp(sizeof(CmdDispatchIndirectArgs));
    return total_size;
}

size_t GetCreateImageArgsSize(VkDevice                 device,
                              VkImageCreateInfo const* pCreateInfo,
                              AllocationCallbacks      pAllocator,
                              VkImage*                 pImage)
{
    size_t total_size = AlignUp(sizeof(CreateImageArgs));
    total_size += AlignUp(sizeof(VkImage));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCreateImageViewArgsSize(VkDevice                     device,
                                  VkImageViewCreateInfo const* pCreateInfo,
                                  AllocationCallbacks          pAllocator,
                                  VkImageView*                 pView)
{
    size_t total_size = AlignUp(sizeof(CreateImageViewArgs));
    total_size += AlignUp(sizeof(VkImageView));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdBindPipelineArgsSize(VkCommandBuffer commandBuffer,
                                  uint32_t        pipelineBindPoint,
                                  VkPipeline      pipeline)
{
    size_t total_size = AlignUp(sizeof(CmdBindPipelineArgs));
    return total_size;
}

size_t GetCmdSetViewportArgsSize(VkCommandBuffer   commandBuffer,
                                 uint32_t          firstViewport,
                                 uint32_t          viewportCount,
                                 VkViewport const* pViewports)
{
    size_t total_size = AlignUp(sizeof(CmdSetViewportArgs));
    if (pViewports)
    {
        total_size += GetArraySize(pViewports,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(viewportCount));
    }
    return total_size;
}

size_t GetCmdSetScissorArgsSize(VkCommandBuffer commandBuffer,
                                uint32_t        firstScissor,
                                uint32_t        scissorCount,
                                VkRect2D const* pScissors)
{
    size_t total_size = AlignUp(sizeof(CmdSetScissorArgs));
    if (pScissors)
    {
        total_size += GetArraySize(pScissors,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(scissorCount));
    }
    return total_size;
}

size_t GetCmdSetLineWidthArgsSize(VkCommandBuffer commandBuffer, float lineWidth)
{
    size_t total_size = AlignUp(sizeof(CmdSetLineWidthArgs));
    return total_size;
}

size_t GetCmdSetDepthBiasArgsSize(VkCommandBuffer commandBuffer,
                                  float           depthBiasConstantFactor,
                                  float           depthBiasClamp,
                                  float           depthBiasSlopeFactor)
{
    size_t total_size = AlignUp(sizeof(CmdSetDepthBiasArgs));
    return total_size;
}

size_t GetCmdSetBlendConstantsArgsSize(VkCommandBuffer commandBuffer, float blendConstants[4])
{
    size_t total_size = AlignUp(sizeof(CmdSetBlendConstantsArgs));
    for (uint32_t i = 0; i < 4; ++i)
    {
        total_size += AlignUp(sizeof(blendConstants[i]));
    }  // f32[4]
    return total_size;
}

size_t GetCmdSetDepthBoundsArgsSize(VkCommandBuffer commandBuffer,
                                    float           minDepthBounds,
                                    float           maxDepthBounds)
{
    size_t total_size = AlignUp(sizeof(CmdSetDepthBoundsArgs));
    return total_size;
}

size_t GetCmdSetStencilCompareMaskArgsSize(VkCommandBuffer    commandBuffer,
                                           VkStencilFaceFlags faceMask,
                                           uint32_t           compareMask)
{
    size_t total_size = AlignUp(sizeof(CmdSetStencilCompareMaskArgs));
    return total_size;
}

size_t GetCmdSetStencilWriteMaskArgsSize(VkCommandBuffer    commandBuffer,
                                         VkStencilFaceFlags faceMask,
                                         uint32_t           writeMask)
{
    size_t total_size = AlignUp(sizeof(CmdSetStencilWriteMaskArgs));
    return total_size;
}

size_t GetCmdSetStencilReferenceArgsSize(VkCommandBuffer    commandBuffer,
                                         VkStencilFaceFlags faceMask,
                                         uint32_t           reference)
{
    size_t total_size = AlignUp(sizeof(CmdSetStencilReferenceArgs));
    return total_size;
}

size_t GetCmdBeginQueryArgsSize(VkCommandBuffer     commandBuffer,
                                VkQueryPool         queryPool,
                                uint32_t            query,
                                VkQueryControlFlags flags)
{
    size_t total_size = AlignUp(sizeof(CmdBeginQueryArgs));
    return total_size;
}

size_t GetCmdEndQueryArgsSize(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
{
    size_t total_size = AlignUp(sizeof(CmdEndQueryArgs));
    return total_size;
}

size_t GetCmdResetQueryPoolArgsSize(VkCommandBuffer commandBuffer,
                                    VkQueryPool     queryPool,
                                    uint32_t        firstQuery,
                                    uint32_t        queryCount)
{
    size_t total_size = AlignUp(sizeof(CmdResetQueryPoolArgs));
    return total_size;
}

size_t GetCmdWriteTimestampArgsSize(VkCommandBuffer commandBuffer,
                                    uint32_t        pipelineStage,
                                    VkQueryPool     queryPool,
                                    uint32_t        query)
{
    size_t total_size = AlignUp(sizeof(CmdWriteTimestampArgs));
    return total_size;
}

size_t GetCmdCopyQueryPoolResultsArgsSize(VkCommandBuffer    commandBuffer,
                                          VkQueryPool        queryPool,
                                          uint32_t           firstQuery,
                                          uint32_t           queryCount,
                                          VkBuffer           dstBuffer,
                                          VkDeviceSize       dstOffset,
                                          VkDeviceSize       stride,
                                          VkQueryResultFlags flags)
{
    size_t total_size = AlignUp(sizeof(CmdCopyQueryPoolResultsArgs));
    return total_size;
}

size_t GetQueueSubmitArgsSize(VkQueue             queue,
                              uint32_t            submitCount,
                              VkSubmitInfo const* pSubmits,
                              VkFence             fence)
{
    size_t total_size = AlignUp(sizeof(QueueSubmitArgs));
    if (pSubmits)
    {
        total_size += GetArraySize(pSubmits,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(submitCount));
    }
    return total_size;
}

size_t GetCreateFramebufferArgsSize(VkDevice                       device,
                                    VkFramebufferCreateInfo const* pCreateInfo,
                                    AllocationCallbacks            pAllocator,
                                    VkFramebuffer*                 pFramebuffer)
{
    size_t total_size = AlignUp(sizeof(CreateFramebufferArgs));
    total_size += AlignUp(sizeof(VkFramebuffer));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCreateRenderPassArgsSize(VkDevice                      device,
                                   VkRenderPassCreateInfo const* pCreateInfo,
                                   AllocationCallbacks           pAllocator,
                                   VkRenderPass*                 pRenderPass)
{
    size_t total_size = AlignUp(sizeof(CreateRenderPassArgs));
    total_size += AlignUp(sizeof(VkRenderPass));
    if (pCreateInfo)
    {
        total_size += GetArraySize(pCreateInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdBeginRenderPassArgsSize(VkCommandBuffer              commandBuffer,
                                     VkRenderPassBeginInfo const* pRenderPassBegin,
                                     uint32_t                     contents)
{
    size_t total_size = AlignUp(sizeof(CmdBeginRenderPassArgs));
    if (pRenderPassBegin)
    {
        total_size += GetArraySize(pRenderPassBegin,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdNextSubpassArgsSize(VkCommandBuffer commandBuffer, uint32_t contents)
{
    size_t total_size = AlignUp(sizeof(CmdNextSubpassArgs));
    return total_size;
}

size_t GetCmdEndRenderPassArgsSize(VkCommandBuffer commandBuffer)
{
    size_t total_size = AlignUp(sizeof(CmdEndRenderPassArgs));
    return total_size;
}

size_t GetCmdSetEventArgsSize(VkCommandBuffer      commandBuffer,
                              VkEvent              event,
                              VkPipelineStageFlags stageMask)
{
    size_t total_size = AlignUp(sizeof(CmdSetEventArgs));
    return total_size;
}

size_t GetCmdResetEventArgsSize(VkCommandBuffer      commandBuffer,
                                VkEvent              event,
                                VkPipelineStageFlags stageMask)
{
    size_t total_size = AlignUp(sizeof(CmdResetEventArgs));
    return total_size;
}

size_t GetCmdWaitEventsArgsSize(VkCommandBuffer              commandBuffer,
                                uint32_t                     eventCount,
                                VkEvent const*               pEvents,
                                VkPipelineStageFlags         srcStageMask,
                                VkPipelineStageFlags         dstStageMask,
                                uint32_t                     memoryBarrierCount,
                                VkMemoryBarrier const*       pMemoryBarriers,
                                uint32_t                     bufferMemoryBarrierCount,
                                VkBufferMemoryBarrier const* pBufferMemoryBarriers,
                                uint32_t                     imageMemoryBarrierCount,
                                VkImageMemoryBarrier const*  pImageMemoryBarriers)
{
    size_t total_size = AlignUp(sizeof(CmdWaitEventsArgs));
    if (pEvents)
    {
        total_size += GetArraySize(pEvents,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(eventCount));
    }
    if (pMemoryBarriers)
    {
        total_size += GetArraySize(pMemoryBarriers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(memoryBarrierCount));
    }
    if (pBufferMemoryBarriers)
    {
        total_size += GetArraySize(pBufferMemoryBarriers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(bufferMemoryBarrierCount));
    }
    if (pImageMemoryBarriers)
    {
        total_size += GetArraySize(pImageMemoryBarriers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(imageMemoryBarrierCount));
    }
    return total_size;
}

size_t GetCmdPipelineBarrierArgsSize(VkCommandBuffer              commandBuffer,
                                     VkPipelineStageFlags         srcStageMask,
                                     VkPipelineStageFlags         dstStageMask,
                                     VkDependencyFlags            dependencyFlags,
                                     uint32_t                     memoryBarrierCount,
                                     VkMemoryBarrier const*       pMemoryBarriers,
                                     uint32_t                     bufferMemoryBarrierCount,
                                     VkBufferMemoryBarrier const* pBufferMemoryBarriers,
                                     uint32_t                     imageMemoryBarrierCount,
                                     VkImageMemoryBarrier const*  pImageMemoryBarriers)
{
    size_t total_size = AlignUp(sizeof(CmdPipelineBarrierArgs));
    if (pMemoryBarriers)
    {
        total_size += GetArraySize(pMemoryBarriers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(memoryBarrierCount));
    }
    if (pBufferMemoryBarriers)
    {
        total_size += GetArraySize(pBufferMemoryBarriers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(bufferMemoryBarrierCount));
    }
    if (pImageMemoryBarriers)
    {
        total_size += GetArraySize(pImageMemoryBarriers,
                                   (uint64_t)(static_cast<uint32_t>(0U)),
                                   (uint64_t)(imageMemoryBarrierCount));
    }
    return total_size;
}

size_t GetCmdWriteBufferMarkerAMDArgsSize(VkCommandBuffer commandBuffer,
                                          uint32_t        pipelineStage,
                                          VkBuffer        dstBuffer,
                                          VkDeviceSize    dstOffset,
                                          uint32_t        marker)
{
    size_t total_size = AlignUp(sizeof(CmdWriteBufferMarkerAMDArgs));
    return total_size;
}

size_t GetCmdDrawIndirectCountAMDArgsSize(VkCommandBuffer commandBuffer,
                                          VkBuffer        buffer,
                                          VkDeviceSize    offset,
                                          VkBuffer        countBuffer,
                                          VkDeviceSize    countOffset,
                                          uint32_t        maxDrawCount,
                                          uint32_t        stride)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndirectCountAMDArgs));
    return total_size;
}

size_t GetCmdDrawIndexedIndirectCountAMDArgsSize(VkCommandBuffer commandBuffer,
                                                 VkBuffer        buffer,
                                                 VkDeviceSize    offset,
                                                 VkBuffer        countBuffer,
                                                 VkDeviceSize    countOffset,
                                                 uint32_t        maxDrawCount,
                                                 uint32_t        stride)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndexedIndirectCountAMDArgs));
    return total_size;
}

size_t GetCmdBeginConditionalRenderingEXTArgsSize(
VkCommandBuffer                           commandBuffer,
VkConditionalRenderingBeginInfoEXT const* pConditinalRenderingBegin)
{
    size_t total_size = AlignUp(sizeof(CmdBeginConditionalRenderingEXTArgs));
    return total_size;
}

size_t GetCmdEndConditionalRenderingEXTArgsSize(VkCommandBuffer commandBuffer)
{
    size_t total_size = AlignUp(sizeof(CmdEndConditionalRenderingEXTArgs));
    return total_size;
}

size_t GetCmdDebugMarkerBeginEXTArgsSize(VkCommandBuffer                   commandBuffer,
                                         VkDebugMarkerMarkerInfoEXT const* pMarkerInfo)
{
    size_t total_size = AlignUp(sizeof(CmdDebugMarkerBeginEXTArgs));
    if (pMarkerInfo)
    {
        total_size += GetArraySize(pMarkerInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdDebugMarkerEndEXTArgsSize(VkCommandBuffer commandBuffer)
{
    size_t total_size = AlignUp(sizeof(CmdDebugMarkerEndEXTArgs));
    return total_size;
}

size_t GetCmdDebugMarkerInsertEXTArgsSize(VkCommandBuffer                   commandBuffer,
                                          VkDebugMarkerMarkerInfoEXT const* pMarkerInfo)
{
    size_t total_size = AlignUp(sizeof(CmdDebugMarkerInsertEXTArgs));
    if (pMarkerInfo)
    {
        total_size += GetArraySize(pMarkerInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdBeginDebugUtilsLabelEXTArgsSize(VkCommandBuffer             commandBuffer,
                                             VkDebugUtilsLabelEXT const* pLabelInfo)
{
    size_t total_size = AlignUp(sizeof(CmdBeginDebugUtilsLabelEXTArgs));
    if (pLabelInfo)
    {
        total_size += GetArraySize(pLabelInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdEndDebugUtilsLabelEXTArgsSize(VkCommandBuffer commandBuffer)
{
    size_t total_size = AlignUp(sizeof(CmdEndDebugUtilsLabelEXTArgs));
    return total_size;
}

size_t GetCmdInsertDebugUtilsLabelEXTArgsSize(VkCommandBuffer             commandBuffer,
                                              VkDebugUtilsLabelEXT const* pLabelInfo)
{
    size_t total_size = AlignUp(sizeof(CmdInsertDebugUtilsLabelEXTArgs));
    if (pLabelInfo)
    {
        total_size += GetArraySize(pLabelInfo,
                                   static_cast<uint64_t>(0U),
                                   static_cast<uint64_t>(1U));
    }
    return total_size;
}

size_t GetCmdSetDeviceMaskKHRArgsSize(VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
    size_t total_size = AlignUp(sizeof(CmdSetDeviceMaskKHRArgs));
    return total_size;
}

size_t GetCmdSetDeviceMaskArgsSize(VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
    size_t total_size = AlignUp(sizeof(CmdSetDeviceMaskArgs));
    return total_size;
}

size_t GetCmdDispatchBaseKHRArgsSize(VkCommandBuffer commandBuffer,
                                     uint32_t        baseGroupX,
                                     uint32_t        baseGroupY,
                                     uint32_t        baseGroupZ,
                                     uint32_t        groupCountX,
                                     uint32_t        groupCountY,
                                     uint32_t        groupCountZ)
{
    size_t total_size = AlignUp(sizeof(CmdDispatchBaseKHRArgs));
    return total_size;
}

size_t GetCmdDispatchBaseArgsSize(VkCommandBuffer commandBuffer,
                                  uint32_t        baseGroupX,
                                  uint32_t        baseGroupY,
                                  uint32_t        baseGroupZ,
                                  uint32_t        groupCountX,
                                  uint32_t        groupCountY,
                                  uint32_t        groupCountZ)
{
    size_t total_size = AlignUp(sizeof(CmdDispatchBaseArgs));
    return total_size;
}

size_t GetCmdDrawIndirectCountKHRArgsSize(VkCommandBuffer commandBuffer,
                                          VkBuffer        buffer,
                                          VkDeviceSize    offset,
                                          VkBuffer        countBuffer,
                                          VkDeviceSize    countOffset,
                                          uint32_t        maxDrawCount,
                                          uint32_t        stride)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndirectCountKHRArgs));
    return total_size;
}

size_t GetCmdDrawIndexedIndirectCountKHRArgsSize(VkCommandBuffer commandBuffer,
                                                 VkBuffer        buffer,
                                                 VkDeviceSize    offset,
                                                 VkBuffer        countBuffer,
                                                 VkDeviceSize    countOffset,
                                                 uint32_t        maxDrawCount,
                                                 uint32_t        stride)
{
    size_t total_size = AlignUp(sizeof(CmdDrawIndexedIndirectCountKHRArgs));
    return total_size;
}

}  // namespace Dive